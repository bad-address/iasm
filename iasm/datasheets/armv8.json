[
  [
    "C6.2.1",
    "ADC",
    "adc",
    "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register. ",
    "ADC <Wd>, <Wn>, <Wm>\nADC <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.2",
    "ADCS",
    "adcs",
    "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result. ",
    "ADCS <Wd>, <Wn>, <Wm>\nADCS <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.3",
    "ADD (extended register)",
    "add",
    "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. ",
    "ADD <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nADD <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.4",
    "ADD (immediate)",
    "add",
    "Add (immediate) adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. This instruction is used by the alias MOV (to/from SP). See Alias conditions for details of when each alias is preferred. ",
    "ADD <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\nADD <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.5",
    "ADD (shifted register)",
    "add",
    "Add (shifted register) adds a register value and an optionally-shifted register value, and writes the result to the destination register. ",
    "ADD <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.6",
    "ADDG",
    "addg",
    "Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.  ARMv8.5",
    "ADDG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
  ],
  [
    "C6.2.7",
    "ADDS (extended register)",
    "adds",
    "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result. This instruction is used by the alias CMN (extended register). See Alias conditions for details of when each alias is preferred. ",
    "ADDS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nADDS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.8",
    "ADDS (immediate)",
    "adds",
    "Add (immediate), setting flags, adds a register value and an optionally-shifted immediate value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias CMN (immediate). See Alias conditions for details of when each alias is preferred. ",
    "ADDS <Wd>, <Wn|WSP>, #<imm>{, <shift>}\nADDS <Xd>, <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.9",
    "ADDS (shifted register)",
    "adds",
    "Add (shifted register), setting flags, adds a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias CMN (shifted register). See Alias conditions for details of when each alias is preferred. ",
    "ADDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nADDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.10",
    "ADR",
    "adr",
    "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register. ",
    "ADR <Xd>, <label>"
  ],
  [
    "C6.2.11",
    "ADRP",
    "adrp",
    "Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register. ",
    "ADRP <Xd>, <label>"
  ],
  [
    "C6.2.12",
    "AND (immediate)",
    "and",
    "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. ",
    "AND <Wd|WSP>, <Wn>, #<imm>\nAND <Xd|SP>, <Xn>, #<imm>"
  ],
  [
    "C6.2.13",
    "AND (shifted register)",
    "and",
    "Bitwise AND (shifted register) performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. ",
    "AND <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nAND <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.14",
    "ANDS (immediate)",
    "ands",
    "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias TST (immediate). See Alias conditions for details of when each alias is preferred. ",
    "ANDS <Wd>, <Wn>, #<imm>\nANDS <Xd>, <Xn>, #<imm>"
  ],
  [
    "C6.2.15",
    "ANDS (shifted register)",
    "ands",
    "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias TST (shifted register). See Alias conditions for details of when each alias is preferred. ",
    "ANDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nANDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.16",
    "ASR (register)",
    "asr",
    "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is an alias of the ASRV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ASRV.  \n  -  The description of ASRV gives the operational pseudocode for this instruction. ",
    "ASR <Wd>, <Wn>, <Wm>\nASRV <Wd>, <Wn>, <Wm>\nASR <Xd>, <Xn>, <Xm>\nASRV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.17",
    "ASR (immediate)",
    "asr",
    "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "ASR <Wd>, <Wn>, #<shift>\nASR <Xd>, <Xn>, #<shift>"
  ],
  [
    "C6.2.18",
    "ASRV",
    "asrv",
    "Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is used by the alias ASR (register). The alias is always the preferred disassembly. ",
    "ASRV <Wd>, <Wn>, <Wm>\nASRV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.19",
    "AT",
    "at",
    "Address Translate. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction. ",
    "AT <at_op>, <Xt>"
  ],
  [
    "C6.2.20",
    "AUTDA, AUTDZA",
    "autda,",
    "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A. The address is in the general-purpose register that is specified by <Xd>. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTDA.  \n  -  The value zero, for AUTDZA.  If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.  ARMv8.3",
    ""
  ],
  [
    "C6.2.21",
    "AUTDB, AUTDZB",
    "autdb,",
    "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B. The address is in the general-purpose register that is specified by <Xd>. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTDB.  \n  -  The value zero, for AUTDZB.  If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.  ARMv8.3",
    ""
  ],
  [
    "C6.2.22",
    "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA",
    "autia,",
    "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A. The address is: \n  -  In the general-purpose register that is specified by <Xd> for AUTIA and AUTIZA.  \n  -  In X17, for AUTIA1716.  \n  -  In X30, for AUTIASP and AUTIAZ.  The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTIA.  \n  -  The value zero, for AUTIZA and AUTIAZ.  \n  -  In X16, for AUTIA1716.  \n  -  In SP, for AUTIASP.  If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.  Integer ARMv8.3",
    ""
  ],
  [
    "C6.2.23",
    "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB",
    "autib,",
    "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B. The address is: \n  -  In the general-purpose register that is specified by <Xd> for AUTIB and AUTIZB.  \n  -  In X17, for AUTIB1716.  \n  -  In X30, for AUTIBSP and AUTIBZ.  The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTIB.  \n  -  The value zero, for AUTIZB and AUTIBZ.  \n  -  In X16, for AUTIB1716.  \n  -  In SP, for AUTIBSP.  If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.  Integer ARMv8.3",
    ""
  ],
  [
    "C6.2.24",
    "AXFLAG",
    "axflag",
    "Convert floating-point condition flags from Arm to external format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction to an alternative representation required by some software.  ARMv8.5",
    "AXFLAG"
  ],
  [
    "C6.2.25",
    "B.cond",
    "b.cond",
    "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return. ",
    ""
  ],
  [
    "C6.2.26",
    "B",
    "b",
    "Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call or return. ",
    "B <label>"
  ],
  [
    "C6.2.27",
    "BFC",
    "bfc",
    "Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the destination register to zero, leaving the other destination bits unchanged. This instruction is an alias of the BFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of BFM.  \n  -  The description of BFM gives the operational pseudocode for this instruction.  ARMv8.2",
    "BFC <Wd>, #<lsb>, #<width>\nBFC <Xd>, #<lsb>, #<width>"
  ],
  [
    "C6.2.28",
    "BFI",
    "bfi",
    "Bitfield Insert copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, leaving the other destination bits unchanged. This instruction is an alias of the BFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of BFM.  \n  -  The description of BFM gives the operational pseudocode for this instruction. ",
    "BFI <Wd>, <Wn>, #<lsb>, #<width>\nBFI <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.29",
    "BFM",
    "bfm",
    "Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly. If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register. If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits. In both cases the other bits of the destination register remain unchanged. This instruction is used by the aliases BFC, BFI, and BFXIL. See Alias conditions on page C6-823 for details of when each alias is preferred. ",
    "BFM <Wd>, <Wn>, #<immr>, #<imms>\nBFM <Xd>, <Xn>, #<immr>, #<imms>"
  ],
  [
    "C6.2.30",
    "BFXIL",
    "bfxil",
    "Bitfield Extract and Insert Low copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, leaving the other destination bits unchanged. This instruction is an alias of the BFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of BFM.  \n  -  The description of BFM gives the operational pseudocode for this instruction. ",
    "BFXIL <Wd>, <Wn>, #<lsb>, #<width>\nBFXIL <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.31",
    "BIC (shifted register)",
    "bic",
    "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. ",
    "BIC <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nBIC <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.32",
    "BICS (shifted register)",
    "bics",
    "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result. ",
    "BICS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nBICS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.33",
    "BL",
    "bl",
    "Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call. ",
    "BL <label>"
  ],
  [
    "C6.2.34",
    "BLR",
    "blr",
    "Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4. ",
    "BLR <Xn>"
  ],
  [
    "C6.2.35",
    "BLRAA, BLRAAZ, BLRAB, BLRABZ",
    "blraa,",
    "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by <Xn>, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xm|SP> for BLRAA and BLRAB.  \n  -  The value zero, for BLRAAZ and BLRABZ.  Key A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ. If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated. The authenticated address is not written back to the general-purpose register.  ARMv8.3",
    ""
  ],
  [
    "C6.2.36",
    "BR",
    "br",
    "Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return. ",
    "BR <Xn>"
  ],
  [
    "C6.2.37",
    "BRAA, BRAAZ, BRAB, BRABZ",
    "braa,",
    "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by <Xn>, using a modifier and the specified key, and branches to the authenticated address. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xm|SP> for BRAA and BRAB.  \n  -  The value zero, for BRAAZ and BRABZ.  Key A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ. If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated. The authenticated address is not written back to the general-purpose register.  ARMv8.3",
    ""
  ],
  [
    "C6.2.38",
    "BRK",
    "brk",
    "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction exception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and captures the value of the immediate argument in ESR_ELx.ISS. ",
    "BRK #<imm>"
  ],
  [
    "C6.2.39",
    "BTI",
    "bti",
    "Branch Target Identification. A BTI instruction is used to guard against the execution of instructions which are not the intended target of a branch. Outside of a guarded memory region, a BTI instruction executes as a NOP. Within a guarded memory region while PSTATE.BTYPE != 0b00, a BTI instruction compatible with the current value of PSTATE.BTYPE will not generate a Branch Target Exception and will allow execution of subsequent instructions within the memory region. The operand <targets> passed to a BTI instruction determines the values of PSTATE.BTYPE which the BTI instruction is compatible with.  Note Within a guarded memory region, while PSTATE.BTYPE != 0b00, all instructions will generate a Branch Target Exception, other than BRK, BTI, HLT, PACIASP, and PACIBSP, which may not. See the individual instructions for details.  ARMv8.5",
    "BTI {<targets>}"
  ],
  [
    "C6.2.40",
    "CASB, CASAB, CASALB, CASLB",
    "casb,",
    "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write. \n  -  CASAB and CASALB load from memory with acquire semantics.  \n  -  CASLB and CASALB store to memory with release semantics.  \n  -  CASB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails. If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.  ARMv8.1",
    ""
  ],
  [
    "C6.2.41",
    "CASH, CASAH, CASALH, CASLH",
    "cash,",
    "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write. \n  -  CASAH and CASALH load from memory with acquire semantics.  \n  -  CASLH and CASALH store to memory with release semantics.  \n  -  CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails. If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is restored to the values held in the register before the instruction was executed.  ARMv8.1",
    ""
  ],
  [
    "C6.2.42",
    "CASP, CASPA, CASPAL, CASPL",
    "casp,",
    "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes. \n  -  CASPA and CASPAL load from memory with acquire semantics.  \n  -  CASPL and CASPAL store to memory with release semantics.  \n  -  CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails. If the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are restored to the values held in the registers before the instruction was executed.  ARMv8.1",
    ""
  ],
  [
    "C6.2.43",
    "CAS, CASA, CASAL, CASL",
    "cas,",
    "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write. \n  -  CASA and CASAL load from memory with acquire semantics.  \n  -  CASL and CASAL store to memory with release semantics.  \n  -  CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. The architecture permits that the data read clears any exclusive monitors associated with that location, even if the compare subsequently fails. If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in the register before the instruction was executed.  ARMv8.1",
    ""
  ],
  [
    "C6.2.44",
    "CBNZ",
    "cbnz",
    "Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags. ",
    "CBNZ <Wt>, <label>\nCBNZ <Xt>, <label>"
  ],
  [
    "C6.2.45",
    "CBZ",
    "cbz",
    "Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags. ",
    "CBZ <Wt>, <label>\nCBZ <Xt>, <label>"
  ],
  [
    "C6.2.46",
    "CCMN (immediate)",
    "ccmn",
    "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise. ",
    "CCMN <Wn>, #<imm>, #<nzcv>, <cond>\nCCMN <Xn>, #<imm>, #<nzcv>, <cond>"
  ],
  [
    "C6.2.47",
    "CCMN (register)",
    "ccmn",
    "Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise. ",
    "CCMN <Wn>, <Wm>, #<nzcv>, <cond>\nCCMN <Xn>, <Xm>, #<nzcv>, <cond>"
  ],
  [
    "C6.2.48",
    "CCMP (immediate)",
    "ccmp",
    "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise. ",
    "CCMP <Wn>, #<imm>, #<nzcv>, <cond>\nCCMP <Xn>, #<imm>, #<nzcv>, <cond>"
  ],
  [
    "C6.2.49",
    "CCMP (register)",
    "ccmp",
    "Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise. ",
    "CCMP <Wn>, <Wm>, #<nzcv>, <cond>\nCCMP <Xn>, <Xm>, #<nzcv>, <cond>"
  ],
  [
    "C6.2.50",
    "CFINV",
    "cfinv",
    "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.  ARMv8.4",
    "CFINV"
  ],
  [
    "C6.2.51",
    "CFP",
    "cfp",
    "Control Flow Prediction Restriction by Context prevents control flow predictions that predict execution addresses, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels. For more information, see CFP RCTX. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction.  ARMv8.5",
    "CFP RCTX, <Xt>"
  ],
  [
    "C6.2.52",
    "CINC",
    "cinc",
    "Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register. This instruction is an alias of the CSINC instruction. This means that: \n  -  The encodings in this description are named to match the encodings of CSINC.  \n  -  The description of CSINC gives the operational pseudocode for this instruction. ",
    "CINC <Wd>, <Wn>, <cond>\nCINC <Xd>, <Xn>, <cond>"
  ],
  [
    "C6.2.53",
    "CINV",
    "cinv",
    "Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register. This instruction is an alias of the CSINV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of CSINV.  \n  -  The description of CSINV gives the operational pseudocode for this instruction. ",
    "CINV <Wd>, <Wn>, <cond>\nCINV <Xd>, <Xn>, <cond>"
  ],
  [
    "C6.2.54",
    "CLREX",
    "clrex",
    "Clear Exclusive clears the local monitor of the executing PE. ",
    "CLREX {#<imm>}"
  ],
  [
    "C6.2.55",
    "CLS",
    "cls",
    "Count Leading Sign bits counts the number of leading bits of the source register that have the same value as the most significant bit of the register, and writes the result to the destination register. This count does not include the most significant bit of the source register. ",
    "CLS <Wd>, <Wn>\nCLS <Xd>, <Xn>"
  ],
  [
    "C6.2.56",
    "CLZ",
    "clz",
    "Count Leading Zeros counts the number of binary zero bits before the first binary one bit in the value of the source register, and writes the result to the destination register. ",
    "CLZ <Wd>, <Wn>\nCLZ <Xd>, <Xn>"
  ],
  [
    "C6.2.57",
    "CMN (extended register)",
    "cmn",
    "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the ADDS (extended register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ADDS (extended register).  \n  -  The description of ADDS (extended register) gives the operational pseudocode for this instruction. ",
    "CMN <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nCMN <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.58",
    "CMN (immediate)",
    "cmn",
    "Compare Negative (immediate) adds a register value and an optionally-shifted immediate value. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the ADDS (immediate) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ADDS (immediate).  \n  -  The description of ADDS (immediate) gives the operational pseudocode for this instruction. ",
    "CMN <Wn|WSP>, #<imm>{, <shift>}\nCMN <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.59",
    "CMN (shifted register)",
    "cmn",
    "Compare Negative (shifted register) adds a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the ADDS (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ADDS (shifted register).  \n  -  The description of ADDS (shifted register) gives the operational pseudocode for this instruction. ",
    "CMN <Wn>, <Wm>{, <shift> #<amount>}\nCMN <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.60",
    "CMP (extended register)",
    "cmp",
    "Compare (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the SUBS (extended register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUBS (extended register).  \n  -  The description of SUBS (extended register) gives the operational pseudocode for this instruction. ",
    "CMP <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nCMP <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.61",
    "CMP (immediate)",
    "cmp",
    "Compare (immediate) subtracts an optionally-shifted immediate value from a register value. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the SUBS (immediate) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUBS (immediate).  \n  -  The description of SUBS (immediate) gives the operational pseudocode for this instruction. ",
    "CMP <Wn|WSP>, #<imm>{, <shift>}\nCMP <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.62",
    "CMP (shifted register)",
    "cmp",
    "Compare (shifted register) subtracts an optionally-shifted register value from a register value. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the SUBS (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUBS (shifted register).  \n  -  The description of SUBS (shifted register) gives the operational pseudocode for this instruction. ",
    "CMP <Wn>, <Wm>{, <shift> #<amount>}\nCMP <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.63",
    "CMPP",
    "cmpp",
    "Compare with Tag subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, updates the condition flags based on the result of the subtraction, and discards the result. This instruction is an alias of the SUBPS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUBPS.  \n  -  The description of SUBPS gives the operational pseudocode for this instruction.  ARMv8.5",
    "CMPP <Xn|SP>, <Xm|SP>"
  ],
  [
    "C6.2.64",
    "CNEG",
    "cneg",
    "Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register. This instruction is an alias of the CSNEG instruction. This means that: \n  -  The encodings in this description are named to match the encodings of CSNEG.  \n  -  The description of CSNEG gives the operational pseudocode for this instruction. ",
    "CNEG <Wd>, <Wn>, <cond>\nCNEG <Xd>, <Xn>, <cond>"
  ],
  [
    "C6.2.65",
    "CPP",
    "cpp",
    "Cache Prefetch Prediction Restriction by Context prevents cache allocation predictions, based on information gathered from earlier execution within a particular execution context, from allowing later speculative execution within that context to be observable through side-channels. For more information, see CPP RCTX. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction.  ARMv8.5",
    "CPP RCTX, <Xt>"
  ],
  [
    "C6.2.66",
    "CRC32B, CRC32H, CRC32W, CRC32X",
    "crc32b,",
    "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose  register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation. In Armv8-A, this is an OPTIONAL instruction, and in Armv8.1 it is mandatory for all implementations to implement it.  Note ID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported. ",
    ""
  ],
  [
    "C6.2.67",
    "CRC32CB, CRC32CH, CRC32CW, CRC32CX",
    "crc32cb,",
    "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose  register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation. In Armv8-A, this is an OPTIONAL instruction, and in Armv8.1 it is mandatory for all implementations to implement it.  Note ID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported. ",
    ""
  ],
  [
    "C6.2.68",
    "CSDB",
    "csdb",
    "Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value prediction. No instruction other than branch instructions appearing in program order after the CSDB can be speculatively executed using the results of any: \n  -  Data value predictions of any instructions.  \n  -  PSTATE.{N,Z,C,V} predictions of any instructions other than conditional branch instructions appearing in program order before the CSDB that have not been architecturally resolved.  \n  -  Predictions of SVE predication state for any SVE instructions.  Note For purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a data value. This definition permits: \n  -  Control flow speculation before and after the CSDB.  \n  -  Speculative execution of conditional data processing instructions after the CSDB, unless they use the results of data value or PSTATE.{N,Z,C,V} predictions of instructions appearing in program order before the CSDB that have not been architecturally resolved. ",
    "CSDB"
  ],
  [
    "C6.2.69",
    "CSEL",
    "csel",
    "If the condition is true, Conditional Select writes the value of the first source register to the destination register. If the condition is false, it writes the value of the second source register to the destination register. ",
    "CSEL <Wd>, <Wn>, <Wm>, <cond>\nCSEL <Xd>, <Xn>, <Xm>, <cond>"
  ],
  [
    "C6.2.70",
    "CSET",
    "cset",
    "Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0. This instruction is an alias of the CSINC instruction. This means that: \n  -  The encodings in this description are named to match the encodings of CSINC.  \n  -  The description of CSINC gives the operational pseudocode for this instruction. ",
    "CSET <Wd>, <cond>\nCSET <Xd>, <cond>"
  ],
  [
    "C6.2.71",
    "CSETM",
    "csetm",
    "Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0. This instruction is an alias of the CSINV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of CSINV.  \n  -  The description of CSINV gives the operational pseudocode for this instruction. ",
    "CSETM <Wd>, <cond>\nCSETM <Xd>, <cond>"
  ],
  [
    "C6.2.72",
    "CSINC",
    "csinc",
    "Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1. This instruction is used by the aliases CINC and CSET. See Alias conditions for details of when each alias is preferred. ",
    "CSINC <Wd>, <Wn>, <Wm>, <cond>\nCSINC <Xd>, <Xn>, <Xm>, <cond>"
  ],
  [
    "C6.2.73",
    "CSINV",
    "csinv",
    "Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register. This instruction is used by the aliases CINV and CSETM. See Alias conditions for details of when each alias is preferred. ",
    "CSINV <Wd>, <Wn>, <Wm>, <cond>\nCSINV <Xd>, <Xn>, <Xm>, <cond>"
  ],
  [
    "C6.2.74",
    "CSNEG",
    "csneg",
    "Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register. This instruction is used by the alias CNEG. See Alias conditions for details of when each alias is preferred. ",
    "CSNEG <Wd>, <Wn>, <Wm>, <cond>\nCSNEG <Xd>, <Xn>, <Xm>, <cond>"
  ],
  [
    "C6.2.75",
    "DC",
    "dc",
    "Data Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction. ",
    "DC <dc_op>, <Xt>"
  ],
  [
    "C6.2.76",
    "DCPS1",
    "dcps1",
    "Debug Change PE State to EL1, when executed in Debug state: \n  -  If executed at EL0 changes the current Exception level and SP to EL1 using SP_EL1.  \n  -  Otherwise, if executed at ELx, selects SP_ELx.  The target exception level of a DCPS1 instruction is: \n  -  EL1 if the instruction is executed at EL0.  \n  -  Otherwise, the Exception level at which the instruction is executed.  When the target Exception level of a DCPS1 instruction is ELx, on executing this instruction: \n  -  ELR_ELx becomes UNKNOWN.  \n  -  SPSR_ELx becomes UNKNOWN.  \n  -  ESR_ELx becomes UNKNOWN.  \n  -  DLR_EL0 and DSPSR_EL0 become UNKNOWN.  \n  -  The endianness is set according to SCTLR_ELx.EE.  This instruction is UNDEFINED at EL0 in Non-secure state if EL2 is implemented and HCR_EL2.TGE == 1. This instruction is always UNDEFINED in Non-debug state. For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042. ",
    "DCPS1 {#<imm>}"
  ],
  [
    "C6.2.77",
    "DCPS2",
    "dcps2",
    "Debug Change PE State to EL2, when executed in Debug state: \n  -  If executed at EL0 or EL1 changes the current Exception level and SP to EL2 using SP_EL2.  \n  -  Otherwise, if executed at ELx, selects SP_ELx.  The target exception level of a DCPS2 instruction is: \n  -  EL2 if the instruction is executed at an exception level that is not EL3.  \n  -  EL3 if the instruction is executed at EL3.  When the target Exception level of a DCPS2 instruction is ELx, on executing this instruction: \n  -  ELR_ELx becomes UNKNOWN.  \n  -  SPSR_ELx becomes UNKNOWN.  \n  -  ESR_ELx becomes UNKNOWN.  \n  -  DLR_EL0 and DSPSR_EL0 become UNKNOWN.  \n  -  The endianness is set according to SCTLR_ELx.EE.  This instruction is UNDEFINED at the following exception levels: \n  -  All exception levels if EL2 is not implemented.  \n  -  At EL0 and EL1 if EL2 is disabled in the current Security state.  This instruction is always UNDEFINED in Non-debug state. For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042. ",
    "DCPS2 {#<imm>}"
  ],
  [
    "C6.2.78",
    "DCPS3",
    "dcps3",
    "Debug Change PE State to EL3, when executed in Debug state: \n  -  If executed at EL3 selects SP_EL3.  \n  -  Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.  The target exception level of a DCPS3 instruction is EL3. On executing a DCPS3 instruction: \n  -  ELR_EL3 becomes UNKNOWN.  \n  -  SPSR_EL3 becomes UNKNOWN.  \n  -  ESR_EL3 becomes UNKNOWN.  \n  -  DLR_EL0 and DSPSR_EL0 become UNKNOWN.  \n  -  The endianness is set according to SCTLR_EL3.EE.  This instruction is UNDEFINED at all exception levels if either: \n  -  EDSCR.SDD == 1.  \n  -  EL3 is not implemented.  This instruction is always UNDEFINED in Non-debug state. For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042. ",
    "DCPS3 {#<imm>}"
  ],
  [
    "C6.2.79",
    "DGH",
    "dgh",
    "DGH is a hint instruction. A DGH instruction is not expected to be performance optimal to merge memory accesses with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect.  ARMv8.6",
    "DGH"
  ],
  [
    "C6.2.80",
    "DMB",
    "dmb",
    "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier (DMB) on page B2-135. ",
    "DMB <option>|#<imm>"
  ],
  [
    "C6.2.81",
    "DRPS",
    "drps",
    "Debug restore process state ",
    "DRPS\nDRPSInstruction();"
  ],
  [
    "C6.2.82",
    "DSB",
    "dsb",
    "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier (DSB) on page B2-138. ",
    "DSB <option>|#<imm>"
  ],
  [
    "C6.2.83",
    "DVP",
    "dvp",
    "Data Value Prediction Restriction by Context prevents data value predictions, based on information gathered from earlier execution within an particular execution context, from allowing later speculative execution within that context to be observable through side-channels. For more information, see DVP RCTX. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction.  ARMv8.5",
    "DVP RCTX, <Xt>"
  ],
  [
    "C6.2.84",
    "EON (shifted register)",
    "eon",
    "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register. ",
    "EON <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nEON <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.85",
    "EOR (immediate)",
    "eor",
    "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register. ",
    "EOR <Wd|WSP>, <Wn>, #<imm>\nEOR <Xd|SP>, <Xn>, #<imm>"
  ],
  [
    "C6.2.86",
    "EOR (shifted register)",
    "eor",
    "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register. ",
    "EOR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nEOR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.87",
    "ERET",
    "eret",
    "Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores PSTATE from the SPSR, and branches to the address held in the ELR. The PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from AArch64 state on page D1-2345. ERET is UNDEFINED at EL0. ",
    "ERET"
  ],
  [
    "C6.2.88",
    "ERETAA, ERETAB",
    "eretaa,",
    "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address. Key A is used for ERETAA, and key B is used for ERETAB. If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated. The authenticated address is not written back to ELR. The PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from AArch64 state on page D1-2345. ERETAA and ERETAB are UNDEFINED at EL0.  ARMv8.3",
    ""
  ],
  [
    "C6.2.89",
    "ESB",
    "esb",
    "Error Synchronization Barrier is an error synchronization event that might also update DISR_EL1 and VDISR_EL2. This instruction can be used at all Exception levels and in Debug state. In Debug state, this instruction behaves as if SError interrupts are masked at all Exception levels. See Error Synchronization Barrier in the Arm(R) Reliability, Availability, and Serviceability (RAS) Specification, Armv8, for Armv8-A architecture profile. If the RAS Extension is not implemented, this instruction executes as a NOP.  ARMv8.2",
    "ESB"
  ],
  [
    "C6.2.90",
    "EXTR",
    "extr",
    "Extract register extracts a register from a pair of registers. This instruction is used by the alias ROR (immediate). See Alias conditions for details of when each alias is preferred. ",
    "EXTR <Wd>, <Wn>, <Wm>, #<lsb>\nEXTR <Xd>, <Xn>, <Xm>, #<lsb>"
  ],
  [
    "C6.2.91",
    "GMI",
    "gmi",
    "Tag Mask Insert inserts the tag in the first source register into the excluded set specified in the second source register, writing the new excluded set to the destination register.  ARMv8.5",
    "GMI <Xd>, <Xn|SP>, <Xm>"
  ],
  [
    "C6.2.92",
    "HINT",
    "hint",
    "Hint instruction is for the instruction set space that is reserved for architectural hint instructions. Some encodings described here are not allocated in this revision of the architecture, and behave as NOPs. These encodings might be allocated to other hint functionality in future revisions of the architecture and therefore must not be used by software. ",
    "HINT #<imm>"
  ],
  [
    "C6.2.93",
    "HLT",
    "hlt",
    "Halt instruction. An HLT instruction can generate a Halt Instruction debug event, which causes entry into Debug state. ",
    "HLT #<imm>"
  ],
  [
    "C6.2.94",
    "HVC",
    "hvc",
    "Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a service. The HVC instruction is UNDEFINED: \n  -  At EL0.  \n  -  At EL1 if EL2 is not enabled in the current Security state.  \n  -  When SCR_EL3.HCE is set to 0.  On executing an HVC instruction, the PE records the exception as a Hypervisor Call exception in ESR_ELx, using the EC value 0x16, and the value of the immediate argument. ",
    "HVC #<imm>"
  ],
  [
    "C6.2.95",
    "IC",
    "ic",
    "Instruction Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction. ",
    "IC <ic_op>{, <Xt>}"
  ],
  [
    "C6.2.96",
    "IRG",
    "irg",
    "Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register. Any tags specified in the optional second source register or in GCR_EL1.Exclude are excluded from the selection of the random Logical Address Tag.  ARMv8.5",
    "IRG <Xd|SP>, <Xn|SP>{, <Xm>}"
  ],
  [
    "C6.2.97",
    "ISB",
    "isb",
    "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB) on page B2-135. ",
    "ISB {<option>|#<imm>}"
  ],
  [
    "C6.2.98",
    "LDADDB, LDADDAB, LDADDALB, LDADDLB",
    "ldaddb,",
    "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDADDAB and LDADDALB load from memory with acquire semantics.  \n  -  LDADDLB and LDADDALB store to memory with release semantics.  \n  -  LDADDB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STADDB, STADDLB. See Alias conditions on page C6-935 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.99",
    "LDADDH, LDADDAH, LDADDALH, LDADDLH",
    "ldaddh,",
    "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDADDAH and LDADDALH load from memory with acquire semantics.  \n  -  LDADDLH and LDADDALH store to memory with release semantics.  \n  -  LDADDH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STADDH, STADDLH. See Alias conditions on page C6-937 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.100",
    "LDADD, LDADDA, LDADDAL, LDADDL",
    "ldadd,",
    "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDADDA and LDADDAL load from memory with acquire semantics.  \n  -  LDADDL and LDADDAL store to memory with release semantics.  \n  -  LDADD has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STADD, STADDL. See Alias conditions on page C6-939 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.101",
    "LDAPR",
    "ldapr",
    "Load-Acquire RCpc Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from the derived address in memory, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.3",
    "LDAPR <Wt>, [<Xn|SP> {,#0}]\nLDAPR <Xt>, [<Xn|SP> {,#0}]"
  ],
  [
    "C6.2.102",
    "LDAPRB",
    "ldaprb",
    "Load-Acquire RCpc Register Byte derives an address from a base register value, loads a byte from the derived address in memory, zero-extends it and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.3",
    "LDAPRB <Wt>, [<Xn|SP> {,#0}]"
  ],
  [
    "C6.2.103",
    "LDAPRH",
    "ldaprh",
    "Load-Acquire RCpc Register Halfword derives an address from a base register value, loads a halfword from the derived address in memory, zero-extends it and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.3",
    "LDAPRH <Wt>, [<Xn|SP> {,#0}]"
  ],
  [
    "C6.2.104",
    "LDAPUR",
    "ldapur",
    "Load-Acquire RCpc Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPUR <Wt>, [<Xn|SP>{, #<simm>}]\nLDAPUR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.105",
    "LDAPURB",
    "ldapurb",
    "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPURB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.106",
    "LDAPURH",
    "ldapurh",
    "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPURH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.107",
    "LDAPURSB",
    "ldapursb",
    "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPURSB <Wt>, [<Xn|SP>{, #<simm>}]\nLDAPURSB <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.108",
    "LDAPURSH",
    "ldapursh",
    "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPURSH <Wt>, [<Xn|SP>{, #<simm>}]\nLDAPURSH <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.109",
    "LDAPURSW",
    "ldapursw",
    "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139, except that: \n  -  There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release, created by having a Store-Release followed by a Load-AcquirePC instruction.  \n  -  The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer does not make the write of the Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "LDAPURSW <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.110",
    "LDAR",
    "ldar",
    "Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints. ",
    "LDAR <Wt>, [<Xn|SP>{,#0}]\nLDAR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.111",
    "LDARB",
    "ldarb",
    "Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints. ",
    "LDARB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.112",
    "LDARH",
    "ldarh",
    "Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints. ",
    "LDARH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.113",
    "LDAXP",
    "ldaxp",
    "Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDAXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\nLDAXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.114",
    "LDAXR",
    "ldaxr",
    "Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDAXR <Wt>, [<Xn|SP>{,#0}]\nLDAXR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.115",
    "LDAXRB",
    "ldaxrb",
    "Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDAXRB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.116",
    "LDAXRH",
    "ldaxrh",
    "Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDAXRH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.117",
    "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB",
    "ldclrb,",
    "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDCLRAB and LDCLRALB load from memory with acquire semantics.  \n  -  LDCLRLB and LDCLRALB store to memory with release semantics.  \n  -  LDCLRB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STCLRB, STCLRLB. See Alias conditions on page C6-970 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.118",
    "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH",
    "ldclrh,",
    "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDCLRAH and LDCLRALH load from memory with acquire semantics.  \n  -  LDCLRLH and LDCLRALH store to memory with release semantics.  \n  -  LDCLRH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STCLRH, STCLRLH. See Alias conditions on page C6-972 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.119",
    "LDCLR, LDCLRA, LDCLRAL, LDCLRL",
    "ldclr,",
    "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL load from memory with acquire semantics.  \n  -  LDCLRL and LDCLRAL store to memory with release semantics.  \n  -  LDCLR has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STCLR, STCLRL. See Alias conditions on page C6-974 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.120",
    "LDEORB, LDEORAB, LDEORALB, LDEORLB",
    "ldeorb,",
    "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDEORAB and LDEORALB load from memory with acquire semantics.  \n  -  LDEORLB and LDEORALB store to memory with release semantics.  \n  -  LDEORB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STEORB, STEORLB. See Alias conditions on page C6-977 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.121",
    "LDEORH, LDEORAH, LDEORALH, LDEORLH",
    "ldeorh,",
    "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDEORAH and LDEORALH load from memory with acquire semantics.  \n  -  LDEORLH and LDEORALH store to memory with release semantics.  \n  -  LDEORH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STEORH, STEORLH. See Alias conditions on page C6-979 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.122",
    "LDEOR, LDEORA, LDEORAL, LDEORL",
    "ldeor,",
    "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDEORA and LDEORAL load from memory with acquire semantics.  \n  -  LDEORL and LDEORAL store to memory with release semantics.  \n  -  LDEOR has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STEOR, STEORL. See Alias conditions on page C6-981 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.123",
    "LDG",
    "ldg",
    "Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base register and an immediate signed offset scaled by the Tag granule.  ARMv8.5",
    "LDG <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.124",
    "LDGM",
    "ldgm",
    "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read from address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the destination register not written with an Allocation Tag are set to 0. This instruction is UNDEFINED at EL0. This instruction generates an Unchecked access. If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.  ARMv8.5",
    "LDGM <Xt>, [<Xn|SP>]"
  ],
  [
    "C6.2.125",
    "LDLARB",
    "ldlarb",
    "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints.  ARMv8.1",
    "LDLARB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.126",
    "LDLARH",
    "ldlarh",
    "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints.  ARMv8.1",
    "LDLARH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.127",
    "LDLAR",
    "ldlar",
    "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Note For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the acquire semantic other than its effect on the arrival at endpoints.  ARMv8.1",
    "LDLAR <Wt>, [<Xn|SP>{,#0}]\nLDLAR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.128",
    "LDNP",
    "ldnp",
    "Load Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes on page C1-187. For information about Non-temporal pair instructions, see Load/Store Non-temporal Pair on page C3-210. ",
    "LDNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\nLDNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
  ],
  [
    "C6.2.129",
    "LDP",
    "ldp",
    "Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\nLDP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C6.2.130",
    "LDPSW",
    "ldpsw",
    "Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDPSW <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C6.2.131",
    "LDR (immediate)",
    "ldr",
    "Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187. The Unsigned offset variant scales the immediate offset value by the size of the value accessed before adding it to the base register value.  Post-index",
    "LDR <Wt>, [<Xn|SP>], #<simm>\nLDR <Xt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.132",
    "LDR (literal)",
    "ldr",
    "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDR <Wt>, <label>\nLDR <Xt>, <label>"
  ],
  [
    "C6.2.133",
    "LDR (register)",
    "ldr",
    "Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nLDR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.134",
    "LDRAA, LDRAB",
    "ldraa,",
    "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register. Key A is used for LDRAA, and key B is used for LDRAB. If the authentication passes, the PE behaves the same as for an LDR instruction. If the authentication fails, a Translation fault is generated. The authenticated address is not written back to the base register, unless the pre-indexed variant of the instruction is used. In this case, the address that is written back to the base register does not include the pointer authentication code. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.3",
    ""
  ],
  [
    "C6.2.135",
    "LDRB (immediate)",
    "ldrb",
    "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDRB <Wt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.136",
    "LDRB (register)",
    "ldrb",
    "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nLDRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
  ],
  [
    "C6.2.137",
    "LDRH (immediate)",
    "ldrh",
    "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDRH <Wt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.138",
    "LDRH (register)",
    "ldrh",
    "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.139",
    "LDRSB (immediate)",
    "ldrsb",
    "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDRSB <Wt>, [<Xn|SP>], #<simm>\nLDRSB <Xt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.140",
    "LDRSB (register)",
    "ldrsb",
    "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDRSB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nLDRSB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\nLDRSB <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nLDRSB <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
  ],
  [
    "C6.2.141",
    "LDRSH (immediate)",
    "ldrsh",
    "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDRSH <Wt>, [<Xn|SP>], #<simm>\nLDRSH <Xt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.142",
    "LDRSH (register)",
    "ldrsh",
    "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDRSH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nLDRSH <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.143",
    "LDRSW (immediate)",
    "ldrsw",
    "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "LDRSW <Xt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.144",
    "LDRSW (literal)",
    "ldrsw",
    "Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDRSW <Xt>, <label>"
  ],
  [
    "C6.2.145",
    "LDRSW (register)",
    "ldrsw",
    "Load Register Signed Word (register) calculates an address from a base register value and an offset register value, loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value can be shifted left by 0 or 2 bits. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDRSW <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.146",
    "LDSETB, LDSETAB, LDSETALB, LDSETLB",
    "ldsetb,",
    "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSETAB and LDSETALB load from memory with acquire semantics.  \n  -  LDSETLB and LDSETALB store to memory with release semantics.  \n  -  LDSETB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSETB, STSETLB. See Alias conditions on page C6-1033 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.147",
    "LDSETH, LDSETAH, LDSETALH, LDSETLH",
    "ldseth,",
    "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSETAH and LDSETALH load from memory with acquire semantics.  \n  -  LDSETLH and LDSETALH store to memory with release semantics.  \n  -  LDSETH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSETH, STSETLH. See Alias conditions on page C6-1035 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.148",
    "LDSET, LDSETA, LDSETAL, LDSETL",
    "ldset,",
    "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDSETA and LDSETAL load from memory with acquire semantics.  \n  -  LDSETL and LDSETAL store to memory with release semantics.  \n  -  LDSET has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSET, STSETL. See Alias conditions on page C6-1037 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.149",
    "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB",
    "ldsmaxb,",
    "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from memory with acquire semantics.  \n  -  LDSMAXLB and LDSMAXALB store to memory with release semantics.  \n  -  LDSMAXB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMAXB, STSMAXLB. See Alias conditions on page C6-1040 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.150",
    "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH",
    "ldsmaxh,",
    "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from memory with acquire semantics.  \n  -  LDSMAXLH and LDSMAXALH store to memory with release semantics.  \n  -  LDSMAXH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMAXH, STSMAXLH. See Alias conditions on page C6-1042 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.151",
    "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL",
    "ldsmax,",
    "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL load from memory with acquire semantics.  \n  -  LDSMAXL and LDSMAXAL store to memory with release semantics.  \n  -  LDSMAX has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMAX, STSMAXL. See Alias conditions on page C6-1044 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.152",
    "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB",
    "ldsminb,",
    "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSMINAB and LDSMINALB load from memory with acquire semantics.  \n  -  LDSMINLB and LDSMINALB store to memory with release semantics.  \n  -  LDSMINB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMINB, STSMINLB. See Alias conditions on page C6-1047 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.153",
    "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH",
    "ldsminh,",
    "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDSMINAH and LDSMINALH load from memory with acquire semantics.  \n  -  LDSMINLH and LDSMINALH store to memory with release semantics.  \n  -  LDSMINH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMINH, STSMINLH. See Alias conditions on page C6-1049 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.154",
    "LDSMIN, LDSMINA, LDSMINAL, LDSMINL",
    "ldsmin,",
    "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL load from memory with acquire semantics.  \n  -  LDSMINL and LDSMINAL store to memory with release semantics.  \n  -  LDSMIN has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STSMIN, STSMINL. See Alias conditions on page C6-1051 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.155",
    "LDTR",
    "ldtr",
    "Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTR <Wt>, [<Xn|SP>{, #<simm>}]\nLDTR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.156",
    "LDTRB",
    "ldtrb",
    "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTRB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.157",
    "LDTRH",
    "ldtrh",
    "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTRH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.158",
    "LDTRSB",
    "ldtrsb",
    "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTRSB <Wt>, [<Xn|SP>{, #<simm>}]\nLDTRSB <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.159",
    "LDTRSH",
    "ldtrsh",
    "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTRSH <Wt>, [<Xn|SP>{, #<simm>}]\nLDTRSH <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.160",
    "LDTRSW",
    "ldtrsw",
    "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDTRSW <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.161",
    "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB",
    "ldumaxb,",
    "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from memory with acquire semantics.  \n  -  LDUMAXLB and LDUMAXALB store to memory with release semantics.  \n  -  LDUMAXB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMAXB, STUMAXLB. See Alias conditions on page C6-1066 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.162",
    "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH",
    "ldumaxh,",
    "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from memory with acquire semantics.  \n  -  LDUMAXLH and LDUMAXALH store to memory with release semantics.  \n  -  LDUMAXH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMAXH, STUMAXLH. See Alias conditions on page C6-1068 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.163",
    "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL",
    "ldumax,",
    "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL load from memory with acquire semantics.  \n  -  LDUMAXL and LDUMAXAL store to memory with release semantics.  \n  -  LDUMAX has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMAX, STUMAXL. See Alias conditions on page C6-1070 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.164",
    "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB",
    "lduminb,",
    "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDUMINAB and LDUMINALB load from memory with acquire semantics.  \n  -  LDUMINLB and LDUMINALB store to memory with release semantics.  \n  -  LDUMINB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMINB, STUMINLB. See Alias conditions on page C6-1073 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.165",
    "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH",
    "lduminh,",
    "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, LDUMINAH and LDUMINALH load from memory with acquire semantics.  \n  -  LDUMINLH and LDUMINALH store to memory with release semantics.  \n  -  LDUMINH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMINH, STUMINLH. See Alias conditions on page C6-1075 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.166",
    "LDUMIN, LDUMINA, LDUMINAL, LDUMINL",
    "ldumin,",
    "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL load from memory with acquire semantics.  \n  -  LDUMINL and LDUMINAL store to memory with release semantics.  \n  -  LDUMIN has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is used by the alias STUMIN, STUMINL. See Alias conditions on page C6-1077 for details of when each alias is preferred.  ARMv8.1",
    ""
  ],
  [
    "C6.2.167",
    "LDUR",
    "ldur",
    "Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDUR <Wt>, [<Xn|SP>{, #<simm>}]\nLDUR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.168",
    "LDURB",
    "ldurb",
    "Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDURB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.169",
    "LDURH",
    "ldurh",
    "Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDURH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.170",
    "LDURSB",
    "ldursb",
    "Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDURSB <Wt>, [<Xn|SP>{, #<simm>}]\nLDURSB <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.171",
    "LDURSH",
    "ldursh",
    "Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDURSH <Wt>, [<Xn|SP>{, #<simm>}]\nLDURSH <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.172",
    "LDURSW",
    "ldursw",
    "Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "LDURSW <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.173",
    "LDXP",
    "ldxp",
    "Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\nLDXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.174",
    "LDXR",
    "ldxr",
    "Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDXR <Wt>, [<Xn|SP>{,#0}]\nLDXR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.175",
    "LDXRB",
    "ldxrb",
    "Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDXRB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.176",
    "LDXRH",
    "ldxrh",
    "Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "LDXRH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.177",
    "LSL (register)",
    "lsl",
    "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted. This instruction is an alias of the LSLV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LSLV.  \n  -  The description of LSLV gives the operational pseudocode for this instruction. ",
    "LSL <Wd>, <Wn>, <Wm>\nLSLV <Wd>, <Wn>, <Wm>\nLSL <Xd>, <Xn>, <Xm>\nLSLV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.178",
    "LSL (immediate)",
    "lsl",
    "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "LSL <Wd>, <Wn>, #<shift>\nLSL <Xd>, <Xn>, #<shift>"
  ],
  [
    "C6.2.179",
    "LSLV",
    "lslv",
    "Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted. This instruction is used by the alias LSL (register). The alias is always the preferred disassembly. ",
    "LSLV <Wd>, <Wn>, <Wm>\nLSLV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.180",
    "LSR (register)",
    "lsr",
    "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is an alias of the LSRV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LSRV.  \n  -  The description of LSRV gives the operational pseudocode for this instruction. ",
    "LSR <Wd>, <Wn>, <Wm>\nLSRV <Wd>, <Wn>, <Wm>\nLSR <Xd>, <Xn>, <Xm>\nLSRV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.181",
    "LSR (immediate)",
    "lsr",
    "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "LSR <Wd>, <Wn>, #<shift>\nLSR <Xd>, <Xn>, #<shift>"
  ],
  [
    "C6.2.182",
    "LSRV",
    "lsrv",
    "Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is used by the alias LSR (register). The alias is always the preferred disassembly. ",
    "LSRV <Wd>, <Wn>, <Wm>\nLSRV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.183",
    "MADD",
    "madd",
    "Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination register. This instruction is used by the alias MUL. See Alias conditions for details of when each alias is preferred. ",
    "MADD <Wd>, <Wn>, <Wm>, <Wa>\nMADD <Xd>, <Xn>, <Xm>, <Xa>"
  ],
  [
    "C6.2.184",
    "MNEG",
    "mneg",
    "Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register. This instruction is an alias of the MSUB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of MSUB.  \n  -  The description of MSUB gives the operational pseudocode for this instruction. ",
    "MNEG <Wd>, <Wn>, <Wm>\nMNEG <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.185",
    "MOV (to/from SP)",
    "mov",
    "Move between register and stack pointer : Rd = Rn This instruction is an alias of the ADD (immediate) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ADD (immediate).  \n  -  The description of ADD (immediate) gives the operational pseudocode for this instruction. ",
    "MOV <Wd|WSP>, <Wn|WSP>\nMOV <Xd|SP>, <Xn|SP>"
  ],
  [
    "C6.2.186",
    "MOV (inverted wide immediate)",
    "mov",
    "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a register. This instruction is an alias of the MOVN instruction. This means that: \n  -  The encodings in this description are named to match the encodings of MOVN.  \n  -  The description of MOVN gives the operational pseudocode for this instruction. ",
    "MOV <Wd>, #<imm>\nMOVN <Wd>, #<imm16>, LSL #<shift>\nMOV <Xd>, #<imm>\nMOVN <Xd>, #<imm16>, LSL #<shift>"
  ],
  [
    "C6.2.187",
    "MOV (wide immediate)",
    "mov",
    "Move (wide immediate) moves a 16-bit immediate value to a register. This instruction is an alias of the MOVZ instruction. This means that: \n  -  The encodings in this description are named to match the encodings of MOVZ.  \n  -  The description of MOVZ gives the operational pseudocode for this instruction. ",
    "MOV <Wd>, #<imm>\nMOVZ <Wd>, #<imm16>, LSL #<shift>\nMOV <Xd>, #<imm>\nMOVZ <Xd>, #<imm16>, LSL #<shift>"
  ],
  [
    "C6.2.188",
    "MOV (bitmask immediate)",
    "mov",
    "Move (bitmask immediate) writes a bitmask immediate value to a register. This instruction is an alias of the ORR (immediate) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ORR (immediate).  \n  -  The description of ORR (immediate) gives the operational pseudocode for this instruction. ",
    "MOV <Wd|WSP>, #<imm>\nMOV <Xd|SP>, #<imm>"
  ],
  [
    "C6.2.189",
    "MOV (register)",
    "mov",
    "Move (register) copies the value in a source register to the destination register. This instruction is an alias of the ORR (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ORR (shifted register).  \n  -  The description of ORR (shifted register) gives the operational pseudocode for this instruction. ",
    "MOV <Wd>, <Wm>\nMOV <Xd>, <Xm>"
  ],
  [
    "C6.2.190",
    "MOVK",
    "movk",
    "Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged. ",
    "MOVK <Wd>, #<imm>{, LSL #<shift>}\nMOVK <Xd>, #<imm>{, LSL #<shift>}"
  ],
  [
    "C6.2.191",
    "MOVN",
    "movn",
    "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register. This instruction is used by the alias MOV (inverted wide immediate). See Alias conditions for details of when each alias is preferred. ",
    "MOVN <Wd>, #<imm>{, LSL #<shift>}\nMOVN <Xd>, #<imm>{, LSL #<shift>}"
  ],
  [
    "C6.2.192",
    "MOVZ",
    "movz",
    "Move wide with zero moves an optionally-shifted 16-bit immediate value to a register. This instruction is used by the alias MOV (wide immediate). See Alias conditions for details of when each alias is preferred. ",
    "MOVZ <Wd>, #<imm>{, LSL #<shift>}\nMOVZ <Xd>, #<imm>{, LSL #<shift>}"
  ],
  [
    "C6.2.193",
    "MRS",
    "mrs",
    "Move System Register allows the PE to read an AArch64 System register into a general-purpose register. ",
    "MRS <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"
  ],
  [
    "C6.2.194",
    "MSR (immediate)",
    "msr",
    "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see PSTATE. The bits that can be written by this instruction are: \n  -  PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.  \n  -  If FEAT_SSBS is implemented, PSTATE.SSBS.  \n  -  If FEAT_PAN is implemented, PSTATE.PAN.  \n  -  If FEAT_UAO is implemented, PSTATE.UAO.  \n  -  If FEAT_DIT is implemented, PSTATE.DIT.  \n  -  If FEAT_MTE is implemented, PSTATE.TCO. ",
    "MSR <pstatefield>, #<imm>"
  ],
  [
    "C6.2.195",
    "MSR (register)",
    "msr",
    "Move general-purpose register to System Register allows the PE to write an AArch64 System register from a general-purpose register. ",
    "MSR (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"
  ],
  [
    "C6.2.196",
    "MSUB",
    "msub",
    "Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register. This instruction is used by the alias MNEG. See Alias conditions for details of when each alias is preferred. ",
    "MSUB <Wd>, <Wn>, <Wm>, <Wa>\nMSUB <Xd>, <Xn>, <Xm>, <Xa>"
  ],
  [
    "C6.2.197",
    "MUL",
    "mul",
    "Multiply : Rd = Rn * Rm This instruction is an alias of the MADD instruction. This means that: \n  -  The encodings in this description are named to match the encodings of MADD.  \n  -  The description of MADD gives the operational pseudocode for this instruction. ",
    "MUL <Wd>, <Wn>, <Wm>\nMUL <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.198",
    "MVN",
    "mvn",
    "Bitwise NOT writes the bitwise inverse of a register value to the destination register. This instruction is an alias of the ORN (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ORN (shifted register).  \n  -  The description of ORN (shifted register) gives the operational pseudocode for this instruction. ",
    "MVN <Wd>, <Wm>{, <shift> #<amount>}\nMVN <Xd>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.199",
    "NEG (shifted register)",
    "neg",
    "Negate (shifted register) negates an optionally-shifted register value, and writes the result to the destination register. This instruction is an alias of the SUB (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUB (shifted register).  \n  -  The description of SUB (shifted register) gives the operational pseudocode for this instruction. ",
    "NEG <Wd>, <Wm>{, <shift> #<amount>}\nNEG <Xd>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.200",
    "NEGS",
    "negs",
    "Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is an alias of the SUBS (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SUBS (shifted register).  \n  -  The description of SUBS (shifted register) gives the operational pseudocode for this instruction. ",
    "NEGS <Wd>, <Wm>{, <shift> #<amount>}\nNEGS <Xd>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.201",
    "NGC",
    "ngc",
    "Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. This instruction is an alias of the SBC instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBC.  \n  -  The description of SBC gives the operational pseudocode for this instruction. ",
    "NGC <Wd>, <Wm>\nNGC <Xd>, <Xm>"
  ],
  [
    "C6.2.202",
    "NGCS",
    "ngcs",
    "Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result. This instruction is an alias of the SBCS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBCS.  \n  -  The description of SBCS gives the operational pseudocode for this instruction. ",
    "NGCS <Wd>, <Wm>\nNGCS <Xd>, <Xm>"
  ],
  [
    "C6.2.203",
    "NOP",
    "nop",
    "No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.  Note The timing effects of including a NOP instruction in a program are not guaranteed. It can increase execution time, leave it unchanged, or even reduce it. Therefore, NOP instructions are not suitable for timing loops. ",
    "NOP"
  ],
  [
    "C6.2.204",
    "ORN (shifted register)",
    "orn",
    "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. This instruction is used by the alias MVN. See Alias conditions for details of when each alias is preferred. ",
    "ORN <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nORN <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.205",
    "ORR (immediate)",
    "orr",
    "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate register value, and writes the result to the destination register. This instruction is used by the alias MOV (bitmask immediate). See Alias conditions for details of when each alias is preferred. ",
    "ORR <Wd|WSP>, <Wn>, #<imm>\nORR <Xd|SP>, <Xn>, #<imm>"
  ],
  [
    "C6.2.206",
    "ORR (shifted register)",
    "orr",
    "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register. This instruction is used by the alias MOV (register). See Alias conditions for details of when each alias is preferred. ",
    "ORR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nORR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.207",
    "PACDA, PACDZA",
    "pacda,",
    "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A. The address is in the general-purpose register that is specified by <Xd>. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACDA.  \n  -  The value zero, for PACDZA.  ARMv8.3",
    ""
  ],
  [
    "C6.2.208",
    "PACDB, PACDZB",
    "pacdb,",
    "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B. The address is in the general-purpose register that is specified by <Xd>. The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACDB.  \n  -  The value zero, for PACDZB.  ARMv8.3",
    ""
  ],
  [
    "C6.2.209",
    "PACGA",
    "pacga",
    "Pointer Authentication Code, using Generic key. This instruction computes the pointer authentication code for an address in the first source register, using a modifier in the second source register, and the Generic key. The computed pointer authentication code is returned in the upper 32 bits of the destination register.  ARMv8.3",
    "PACGA <Xd>, <Xn>, <Xm|SP>"
  ],
  [
    "C6.2.210",
    "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA",
    "pacia,",
    "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A. The address is: \n  -  In the general-purpose register that is specified by <Xd> for PACIA and PACIZA.  \n  -  In X17, for PACIA1716.  \n  -  In X30, for PACIASP and PACIAZ.  The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACIA.  \n  -  The value zero, for PACIZA and PACIAZ.  \n  -  In X16, for PACIA1716.  \n  -  In SP, for PACIASP.  Integer ARMv8.3",
    ""
  ],
  [
    "C6.2.211",
    "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB",
    "pacib,",
    "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B. The address is: \n  -  In the general-purpose register that is specified by <Xd> for PACIB and PACIZB.  \n  -  In X17, for PACIB1716.  \n  -  In X30, for PACIBSP and PACIBZ.  The modifier is: \n  -  In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACIB.  \n  -  The value zero, for PACIZB and PACIBZ.  \n  -  In X16, for PACIB1716.  \n  -  In SP, for PACIBSP.  Integer ARMv8.3",
    ""
  ],
  [
    "C6.2.212",
    "PRFM (immediate)",
    "prfm",
    "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches. The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on page C3-218. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "PRFM (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"
  ],
  [
    "C6.2.213",
    "PRFM (literal)",
    "prfm",
    "Prefetch Memory (literal) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches. The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on page C3-218. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "PRFM (<prfop>|#<imm5>), <label>"
  ],
  [
    "C6.2.214",
    "PRFM (register)",
    "prfm",
    "Prefetch Memory (register) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches. The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on page C3-218. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "PRFM (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.215",
    "PRFUM",
    "prfum",
    "Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches. The effect of an PRFUM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on page C3-218. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.216",
    "PSB CSYNC",
    "psb",
    "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated. A following DSB instruction completes when the writes to the profiling buffer have completed. If the Statistical Profiling Extension is not implemented, this instruction executes as a NOP.  ARMv8.2",
    "PSB CSYNC"
  ],
  [
    "C6.2.217",
    "PSSBB",
    "pssbb",
    "Physical Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same physical address. The semantics of the Physical Speculative Store Bypass Barrier are: \n  -  When a load to a location appears in program order after the PSSBB, then the load does not speculatively read an entry earlier in the coherence order for that location than the entry generated by the latest store satisfying all of the following conditions:  \n  -  \u2014  The store is to the same location as the load.  \u2014  The store appears in program order before the PSSBB.  When a load to a location appears in program order before the PSSBB, then the load does not speculatively read data from any store satisfying all of the following conditions: \u2014  The store is to the same location as the load.  \u2014  The store appears in program order after the PSSBB. ",
    "PSSBB"
  ],
  [
    "C6.2.218",
    "RBIT",
    "rbit",
    "Reverse Bits reverses the bit order in a register. ",
    "RBIT <Wd>, <Wn>\nRBIT <Xd>, <Xn>"
  ],
  [
    "C6.2.219",
    "RET",
    "ret",
    "Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return. ",
    "RET {<Xn>}"
  ],
  [
    "C6.2.220",
    "RETAA, RETAB",
    "retaa,",
    "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return. Key A is used for RETAA, and key B is used for RETAB. If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a Translation fault is generated. The authenticated address is not written back to LR.  ARMv8.3",
    ""
  ],
  [
    "C6.2.221",
    "REV",
    "rev",
    "Reverse Bytes reverses the byte order in a register. This instruction is used by the pseudo-instruction REV64. The pseudo-instruction is never the preferred disassembly. ",
    "REV <Wd>, <Wn>\nREV <Xd>, <Xn>"
  ],
  [
    "C6.2.222",
    "REV16",
    "rev16",
    "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register. ",
    "REV16 <Wd>, <Wn>\nREV16 <Xd>, <Xn>"
  ],
  [
    "C6.2.223",
    "REV32",
    "rev32",
    "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register. ",
    "REV32 <Xd>, <Xn>"
  ],
  [
    "C6.2.224",
    "REV64",
    "rev64",
    "Reverse Bytes reverses the byte order in a 64-bit general-purpose register. When assembling for Armv8.2, an assembler must support this pseudo-instruction. It is OPTIONAL whether an assembler supports this pseudo-instruction when assembling for an architecture earlier than Armv8.2. This instruction is a pseudo-instruction of the REV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of REV.  \n  -  The assembler syntax is used only for assembly, and is not used on disassembly.  \n  -  The description of REV gives the operational pseudocode for this instruction. ",
    "REV64 <Xd>, <Xn>"
  ],
  [
    "C6.2.225",
    "RMIF",
    "rmif",
    "Performs a rotation right of a value held in a general purpose register by an immediate value, and then inserts a selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second immediate mask.  ARMv8.4",
    "RMIF <Xn>, #<shift>, #<mask>"
  ],
  [
    "C6.2.226",
    "ROR (immediate)",
    "ror",
    "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. This instruction is an alias of the EXTR instruction. This means that: \n  -  The encodings in this description are named to match the encodings of EXTR.  \n  -  The description of EXTR gives the operational pseudocode for this instruction. ",
    "ROR <Wd>, <Ws>, #<shift>\nROR <Xd>, <Xs>, #<shift>"
  ],
  [
    "C6.2.227",
    "ROR (register)",
    "ror",
    "Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is an alias of the RORV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of RORV.  \n  -  The description of RORV gives the operational pseudocode for this instruction. ",
    "ROR <Wd>, <Wn>, <Wm>\nRORV <Wd>, <Wn>, <Wm>\nROR <Xd>, <Xn>, <Xm>\nRORV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.228",
    "RORV",
    "rorv",
    "Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted. This instruction is used by the alias ROR (register). The alias is always the preferred disassembly. ",
    "RORV <Wd>, <Wn>, <Wm>\nRORV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.229",
    "SB",
    "sb",
    "Speculation Barrier is a barrier that controls speculation. The semantics of the Speculation Barrier are that the execution, until the barrier completes, of any instruction that appears later in the program order than the barrier: \n  -  Cannot be performed speculatively to the extent that such speculation can be observed through side-channels as a result of control flow speculation or data value speculation.  \n  -  Can be speculatively executed as a result of predicting that a potentially exception generating instruction has not generated an exception.  In particular, any instruction that appears later in the program order than the barrier cannot cause a speculative allocation into any caching structure where the allocation of that entry could be indicative of any data value present in memory or in the registers. The SB instruction: \n  -  Cannot be speculatively executed as a result of control flow speculation or data value speculation.  \n  -  Can be speculatively executed as a result of predicting that a potentially exception generating instruction has not generated an exception. The potentially exception generating instruction can complete once it is known not to be speculative, and all data values generated by instructions appearing in program order before the SB instruction have their predicted values confirmed.  When the prediction of the instruction stream is not informed by data taken from the register outputs of the speculative execution of instructions appearing in program order after an uncompleted SB instruction, the SB instruction has no effect on the use of prediction resources to predict the instruction stream that is being fetched. ",
    "SB"
  ],
  [
    "C6.2.230",
    "SBC",
    "sbc",
    "Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. This instruction is used by the alias NGC. See Alias conditions for details of when each alias is preferred. ",
    "SBC <Wd>, <Wn>, <Wm>\nSBC <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.231",
    "SBCS",
    "sbcs",
    "Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias NGCS. See Alias conditions for details of when each alias is preferred. ",
    "SBCS <Wd>, <Wn>, <Wm>\nSBCS <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.232",
    "SBFIZ",
    "sbfiz",
    "Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, setting the destination bits below the bitfield to zero, and the bits above the bitfield to a copy of the most significant bit of the bitfield. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "SBFIZ <Wd>, <Wn>, #<lsb>, #<width>\nSBFIZ <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.233",
    "SBFM",
    "sbfm",
    "Signed Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly. If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register. If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits. In both cases the destination bits below the bitfield are set to zero, and the bits above the bitfield are set to a copy of the most significant bit of the bitfield. This instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB, SXTH, and SXTW. See Alias conditions on page C6-1193 for details of when each alias is preferred. ",
    "SBFM <Wd>, <Wn>, #<immr>, #<imms>\nSBFM <Xd>, <Xn>, #<immr>, #<imms>"
  ],
  [
    "C6.2.234",
    "SBFX",
    "sbfx",
    "Signed Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most significant bit of the bitfield. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "SBFX <Wd>, <Wn>, #<lsb>, #<width>\nSBFX <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.235",
    "SDIV",
    "sdiv",
    "Signed Divide divides a signed integer register value by another signed integer register value, and writes the result to the destination register. The condition flags are not affected. ",
    "SDIV <Wd>, <Wn>, <Wm>\nSDIV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.236",
    "SETF8, SETF16",
    "setf8,",
    "Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8 bit value, and SETF16 treats the value as an 16 bit value. The PSTATE.C flag is not affected by these instructions.  ARMv8.4",
    ""
  ],
  [
    "C6.2.237",
    "SEV",
    "sev",
    "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see Wait for Event mechanism and Send event on page D1-2391. ",
    "SEV"
  ],
  [
    "C6.2.238",
    "SEVL",
    "sevl",
    "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction. ",
    "SEVL"
  ],
  [
    "C6.2.239",
    "SMADDL",
    "smaddl",
    "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register. This instruction is used by the alias SMULL. See Alias conditions for details of when each alias is preferred. ",
    "SMADDL <Xd>, <Wn>, <Wm>, <Xa>"
  ],
  [
    "C6.2.240",
    "SMC",
    "smc",
    "Secure Monitor Call causes an exception to EL3. SMC is available only for software executing at EL1 or higher. It is UNDEFINED in EL0.  If the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC instruction at EL1 or higher generates a Secure Monitor Call exception, recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3. If the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security state, execution of an SMC instruction at EL1 generates an exception that is taken to EL2, regardless of the value of SCR_EL3.SMD. For more information, see Traps to EL2 of EL1 execution of SMC instructions on page D1-2379. If the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC instruction is UNDEFINED. ",
    "SMC #<imm>"
  ],
  [
    "C6.2.241",
    "SMNEGL",
    "smnegl",
    "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register. This instruction is an alias of the SMSUBL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SMSUBL.  \n  -  The description of SMSUBL gives the operational pseudocode for this instruction. ",
    "SMNEGL <Xd>, <Wn>, <Wm>"
  ],
  [
    "C6.2.242",
    "SMSUBL",
    "smsubl",
    "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register. This instruction is used by the alias SMNEGL. See Alias conditions for details of when each alias is preferred. ",
    "SMSUBL <Xd>, <Wn>, <Wm>, <Xa>"
  ],
  [
    "C6.2.243",
    "SMULH",
    "smulh",
    "Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register. ",
    "SMULH <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.244",
    "SMULL",
    "smull",
    "Signed Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register. This instruction is an alias of the SMADDL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SMADDL.  \n  -  The description of SMADDL gives the operational pseudocode for this instruction. ",
    "SMULL <Xd>, <Wn>, <Wm>"
  ],
  [
    "C6.2.245",
    "SSBB",
    "ssbb",
    "Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions. The semantics of the Speculative Store Bypass Barrier are: \n  -  When a load to a location appears in program order after the SSBB, then the load does not speculatively read an entry earlier in the coherence order for that location than the entry generated by the latest store satisfying all of the following conditions:  \n  -  \u2014  The store is to the same location as the load.  \u2014  The store uses the same virtual address as the load.  \u2014  The store appears in program order before the SSBB.  When a load to a location appears in program order before the SSBB, then the load does not speculatively read data from any store satisfying all of the following conditions: \u2014  The store is to the same location as the load.  \u2014  The store uses the same virtual address as the load.  \u2014  The store appears in program order after the SSBB. ",
    "SSBB"
  ],
  [
    "C6.2.246",
    "ST2G",
    "st2g",
    "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register. This instruction generates an Unchecked access.  Post-index ARMv8.5",
    "ST2G <Xt|SP>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.247",
    "STADDB, STADDLB",
    "staddb,",
    "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. \n  -  STADDB does not have release semantics.  \n  -  STADDLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDADDB, LDADDAB, LDADDALB, LDADDLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDADDB, LDADDAB, LDADDALB, LDADDLB.  \n  -  The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.248",
    "STADDH, STADDLH",
    "staddh,",
    "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. \n  -  STADDH does not have release semantics.  \n  -  STADDLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDADDH, LDADDAH, LDADDALH, LDADDLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDADDH, LDADDAH, LDADDALH, LDADDLH.  \n  -  The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.249",
    "STADD, STADDL",
    "stadd,",
    "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. \n  -  STADD does not have release semantics.  \n  -  STADDL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDADD, LDADDA, LDADDAL, LDADDL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDADD, LDADDA, LDADDAL, LDADDL.  \n  -  The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.250",
    "STCLRB, STCLRLB",
    "stclrb,",
    "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. \n  -  STCLRB does not have release semantics.  \n  -  STCLRLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB.  \n  -  The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.251",
    "STCLRH, STCLRLH",
    "stclrh,",
    "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. \n  -  STCLRH does not have release semantics.  \n  -  STCLRLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH.  \n  -  The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.252",
    "STCLR, STCLRL",
    "stclr,",
    "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. \n  -  STCLR does not have release semantics.  \n  -  STCLRL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDCLR, LDCLRA, LDCLRAL, LDCLRL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDCLR, LDCLRA, LDCLRAL, LDCLRL.  \n  -  The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.253",
    "STEORB, STEORLB",
    "steorb,",
    "Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. \n  -  STEORB does not have release semantics.  \n  -  STEORLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDEORB, LDEORAB, LDEORALB, LDEORLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDEORB, LDEORAB, LDEORALB, LDEORLB.  \n  -  The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.254",
    "STEORH, STEORLH",
    "steorh,",
    "Atomic exclusive OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. \n  -  STEORH does not have release semantics.  \n  -  STEORLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDEORH, LDEORAH, LDEORALH, LDEORLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDEORH, LDEORAH, LDEORALH, LDEORLH.  \n  -  The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.255",
    "STEOR, STEORL",
    "steor,",
    "Atomic exclusive OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. \n  -  STEOR does not have release semantics.  \n  -  STEORL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDEOR, LDEORA, LDEORAL, LDEORL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDEOR, LDEORA, LDEORAL, LDEORL.  \n  -  The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.256",
    "STG",
    "stg",
    "Store Allocation Tag stores an Allocation Tag to memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register. This instruction generates an Unchecked access.  Post-index ARMv8.5",
    "STG <Xt|SP>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.257",
    "STGM",
    "stgm",
    "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and the Allocation Tag written to address A is taken from the source register at 4*A<7:4>+3:4*A<7:4>. This instruction is UNDEFINED at EL0. This instruction generates an Unchecked access. If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.  ARMv8.5",
    "STGM <Xt>, [<Xn|SP>]"
  ],
  [
    "C6.2.258",
    "STGP",
    "stgp",
    "Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from two registers. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the base register. This instruction generates an Unchecked access.  Post-index ARMv8.5",
    "STGP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C6.2.259",
    "STLLRB",
    "stllrb",
    "Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.1",
    "STLLRB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.260",
    "STLLRH",
    "stllrh",
    "Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.1",
    "STLLRH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.261",
    "STLLR",
    "stllr",
    "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.1",
    "STLLR <Wt>, [<Xn|SP>{,#0}]\nSTLLR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.262",
    "STLR",
    "stlr",
    "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STLR <Wt>, [<Xn|SP>{,#0}]\nSTLR <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.263",
    "STLRB",
    "stlrb",
    "Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STLRB <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.264",
    "STLRH",
    "stlrh",
    "Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STLRH <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.265",
    "STLUR",
    "stlur",
    "Store-Release Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139 For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "STLUR <Wt>, [<Xn|SP>{, #<simm>}]\nSTLUR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.266",
    "STLURB",
    "stlurb",
    "Store-Release Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139 For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "STLURB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.267",
    "STLURH",
    "stlurh",
    "Store-Release Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139 For information about memory accesses, see Load/Store addressing modes on page C1-187.  ARMv8.4",
    "STLURH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.268",
    "STLXP",
    "stlxp",
    "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STLXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\nSTLXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.269",
    "STLXR",
    "stlxr",
    "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STLXR <Ws>, <Wt>, [<Xn|SP>{,#0}]\nSTLXR <Ws>, <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.270",
    "STLXRB",
    "stlxrb",
    "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STLXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.271",
    "STLXRH",
    "stlxrh",
    "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STLXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.272",
    "STNP",
    "stnp",
    "Store Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes on page C1-187. For information about Non-temporal pair instructions, see Load/Store Non-temporal Pair on page C3-210. ",
    "STNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]\nSTNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
  ],
  [
    "C6.2.273",
    "STP",
    "stp",
    "Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "STP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>\nSTP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C6.2.274",
    "STR (immediate)",
    "str",
    "Store Register (immediate) stores a word or a doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "STR <Wt>, [<Xn|SP>], #<simm>\nSTR <Xt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.275",
    "STR (register)",
    "str",
    "Store Register (register) calculates an address from a base register value and an offset register value, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended. ",
    "STR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nSTR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.276",
    "STRB (immediate)",
    "strb",
    "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "STRB <Wt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.277",
    "STRB (register)",
    "strb",
    "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes on page C1-187. The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended. ",
    "STRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nSTRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
  ],
  [
    "C6.2.278",
    "STRH (immediate)",
    "strh",
    "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.  Post-index",
    "STRH <Wt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.279",
    "STRH (register)",
    "strh",
    "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store addressing modes on page C1-187. The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base register value and an offset register value. The offset can be optionally shifted and extended. ",
    "STRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C6.2.280",
    "STSETB, STSETLB",
    "stsetb,",
    "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. \n  -  STSETB does not have release semantics.  \n  -  STSETLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSETB, LDSETAB, LDSETALB, LDSETLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSETB, LDSETAB, LDSETALB, LDSETLB.  \n  -  The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.281",
    "STSETH, STSETLH",
    "stseth,",
    "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. \n  -  STSETH does not have release semantics.  \n  -  STSETLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSETH, LDSETAH, LDSETALH, LDSETLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSETH, LDSETAH, LDSETALH, LDSETLH.  \n  -  The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.282",
    "STSET, STSETL",
    "stset,",
    "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. \n  -  STSET does not have release semantics.  \n  -  STSETL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSET, LDSETA, LDSETAL, LDSETL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSET, LDSETA, LDSETAL, LDSETL.  \n  -  The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.283",
    "STSMAXB, STSMAXLB",
    "stsmaxb,",
    "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. \n  -  STSMAXB does not have release semantics.  \n  -  STSMAXLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB.  \n  -  The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.284",
    "STSMAXH, STSMAXLH",
    "stsmaxh,",
    "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. \n  -  STSMAXH does not have release semantics.  \n  -  STSMAXLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH.  \n  -  The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.285",
    "STSMAX, STSMAXL",
    "stsmax,",
    "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. \n  -  STSMAX does not have release semantics.  \n  -  STSMAXL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL.  \n  -  The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.286",
    "STSMINB, STSMINLB",
    "stsminb,",
    "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. \n  -  STSMINB does not have release semantics.  \n  -  STSMINLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB.  \n  -  The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.287",
    "STSMINH, STSMINLH",
    "stsminh,",
    "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. \n  -  STSMINH does not have release semantics.  \n  -  STSMINLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH.  \n  -  The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.288",
    "STSMIN, STSMINL",
    "stsmin,",
    "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. \n  -  STSMIN does not have release semantics.  \n  -  STSMINL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDSMIN, LDSMINA, LDSMINAL, LDSMINL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDSMIN, LDSMINA, LDSMINAL, LDSMINL.  \n  -  The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.289",
    "STTR",
    "sttr",
    "Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STTR <Wt>, [<Xn|SP>{, #<simm>}]\nSTTR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.290",
    "STTRB",
    "sttrb",
    "Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STTRB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.291",
    "STTRH",
    "sttrh",
    "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n  -  The instruction is executed at EL1.  \n  -  The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STTRH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.292",
    "STUMAXB, STUMAXLB",
    "stumaxb,",
    "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. \n  -  STUMAXB does not have release semantics.  \n  -  STUMAXLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB.  \n  -  The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.293",
    "STUMAXH, STUMAXLH",
    "stumaxh,",
    "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. \n  -  STUMAXH does not have release semantics.  \n  -  STUMAXLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH.  \n  -  The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.294",
    "STUMAX, STUMAXL",
    "stumax,",
    "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. \n  -  STUMAX does not have release semantics.  \n  -  STUMAXL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL.  \n  -  The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.295",
    "STUMINB, STUMINLB",
    "stuminb,",
    "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. \n  -  STUMINB does not have release semantics.  \n  -  STUMINLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB.  \n  -  The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.296",
    "STUMINH, STUMINLH",
    "stuminh,",
    "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. \n  -  STUMINH does not have release semantics.  \n  -  STUMINLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and  Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH.  \n  -  The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.297",
    "STUMIN, STUMINL",
    "stumin,",
    "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. \n  -  STUMIN does not have release semantics.  \n  -  STUMINL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.  For information about memory accesses see Load/Store addressing modes on page C1-187. This instruction is an alias of the LDUMIN, LDUMINA, LDUMINAL, LDUMINL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of LDUMIN, LDUMINA, LDUMINAL, LDUMINL.  \n  -  The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational pseudocode for this instruction.  ARMv8.1",
    ""
  ],
  [
    "C6.2.298",
    "STUR",
    "stur",
    "Store Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STUR <Wt>, [<Xn|SP>{, #<simm>}]\nSTUR <Xt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.299",
    "STURB",
    "sturb",
    "Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STURB <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.300",
    "STURH",
    "sturh",
    "Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes on page C1-187. ",
    "STURH <Wt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C6.2.301",
    "STXP",
    "stxp",
    "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. A 32-bit pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]\nSTXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.302",
    "STXR",
    "stxr",
    "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STXR <Ws>, <Wt>, [<Xn|SP>{,#0}]\nSTXR <Ws>, <Xt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.303",
    "STXRB",
    "stxrb",
    "Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.304",
    "STXRH",
    "stxrh",
    "Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. For information about memory accesses see Load/Store addressing modes on page C1-187. ",
    "STXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
  ],
  [
    "C6.2.305",
    "STZ2G",
    "stz2g",
    "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register. This instruction generates an Unchecked access.  Post-index ARMv8.5",
    "STZ2G <Xt|SP>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.306",
    "STZG",
    "stzg",
    "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the associated data location. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register. This instruction generates an Unchecked access.  Post-index ARMv8.5",
    "STZG <Xt|SP>, [<Xn|SP>], #<simm>"
  ],
  [
    "C6.2.307",
    "STZGM",
    "stzgm",
    "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation Tags and stores zero to the associated data locations, where the size of N is identified in DCZID_EL0.BS, and the Allocation Tag written to address A is taken from the source register bits<3:0>. This instruction is UNDEFINED at EL0. This instruction generates an Unchecked access. If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.  ARMv8.5",
    "STZGM <Xt>, [<Xn|SP>]"
  ],
  [
    "C6.2.308",
    "SUB (extended register)",
    "sub",
    "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. ",
    "SUB <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nSUB <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.309",
    "SUB (immediate)",
    "sub",
    "Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. ",
    "SUB <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}\nSUB <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.310",
    "SUB (shifted register)",
    "sub",
    "Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. This instruction is used by the alias NEG (shifted register). See Alias conditions for details of when each alias is preferred. ",
    "SUB <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nSUB <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.311",
    "SUBG",
    "subg",
    "Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.  ARMv8.5",
    "SUBG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"
  ],
  [
    "C6.2.312",
    "SUBP",
    "subp",
    "Subtract Pointer subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register.  ARMv8.5",
    "SUBP <Xd>, <Xn|SP>, <Xm|SP>"
  ],
  [
    "C6.2.313",
    "SUBPS",
    "subps",
    "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register. It updates the condition flags based on the result of the subtraction. This instruction is used by the alias CMPP. See Alias conditions for details of when each alias is preferred.  ARMv8.5",
    "SUBPS <Xd>, <Xn|SP>, <Xm|SP>"
  ],
  [
    "C6.2.314",
    "SUBS (extended register)",
    "subs",
    "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result. This instruction is used by the alias CMP (extended register). See Alias conditions for details of when each alias is preferred. ",
    "SUBS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}\nSUBS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
  ],
  [
    "C6.2.315",
    "SUBS (immediate)",
    "subs",
    "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate value from a register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the alias CMP (immediate). See Alias conditions for details of when each alias is preferred. ",
    "SUBS <Wd>, <Wn|WSP>, #<imm>{, <shift>}\nSUBS <Xd>, <Xn|SP>, #<imm>{, <shift>}"
  ],
  [
    "C6.2.316",
    "SUBS (shifted register)",
    "subs",
    "Subtract (shifted register), setting flags, subtracts an optionally-shifted register value from a register value, and writes the result to the destination register. It updates the condition flags based on the result. This instruction is used by the aliases CMP (shifted register) and NEGS. See Alias conditions for details of when each alias is preferred. ",
    "SUBS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}\nSUBS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.317",
    "SVC",
    "svc",
    "Supervisor Call causes an exception to be taken to EL1. On executing an SVC instruction, the PE records the exception as a Supervisor Call exception in ESR_ELx, using the EC value 0x15, and the value of the immediate argument. ",
    "SVC #<imm>"
  ],
  [
    "C6.2.318",
    "SWPB, SWPAB, SWPALB, SWPLB",
    "swpb,",
    "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, SWPAB and SWPALB load from memory with acquire semantics.  \n  -  SWPLB and SWPALB store to memory with release semantics.  \n  -  SWPB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187.  ARMv8.1",
    ""
  ],
  [
    "C6.2.319",
    "SWPH, SWPAH, SWPALH, SWPLH",
    "swph,",
    "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not WZR, SWPAH and SWPALH load from memory with acquire semantics.  \n  -  SWPLH and SWPALH store to memory with release semantics.  \n  -  SWPH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187.  ARMv8.1",
    ""
  ],
  [
    "C6.2.320",
    "SWP, SWPA, SWPAL, SWPL",
    "swp,",
    "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register. \n  -  If the destination register is not one of WZR or XZR, SWPA and SWPAL load from memory with acquire semantics.  \n  -  SWPL and SWPAL store to memory with release semantics.  \n  -  SWP has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187.  ARMv8.1",
    ""
  ],
  [
    "C6.2.321",
    "SXTB",
    "sxtb",
    "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "SXTB <Wd>, <Wn>\nSXTB <Xd>, <Wn>"
  ],
  [
    "C6.2.322",
    "SXTH",
    "sxth",
    "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the destination register. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "SXTH <Wd>, <Wn>\nSXTH <Xd>, <Wn>"
  ],
  [
    "C6.2.323",
    "SXTW",
    "sxtw",
    "Sign Extend Word sign-extends a word to the size of the register, and writes the result to the destination register. This instruction is an alias of the SBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SBFM.  \n  -  The description of SBFM gives the operational pseudocode for this instruction. ",
    "SXTW <Xd>, <Wn>"
  ],
  [
    "C6.2.324",
    "SYS",
    "sys",
    "System instruction. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377 for the encodings of System instructions. This instruction is used by the aliases AT, CFP, CPP, DC, DVP, IC, and TLBI. See Alias conditions for details of when each alias is preferred. ",
    "SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"
  ],
  [
    "C6.2.325",
    "SYSL",
    "sysl",
    "System instruction with result. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377 for the encodings of System instructions. ",
    "SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"
  ],
  [
    "C6.2.326",
    "TBNZ",
    "tbnz",
    "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags. ",
    "TBNZ <R><t>, #<imm>, <label>"
  ],
  [
    "C6.2.327",
    "TBZ",
    "tbz",
    "Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags. ",
    "TBZ <R><t>, #<imm>, <label>"
  ],
  [
    "C6.2.328",
    "TLBI",
    "tlbi",
    "TLB Invalidate operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions on page C5-377. This instruction is an alias of the SYS instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SYS.  \n  -  The description of SYS gives the operational pseudocode for this instruction. ",
    "TLBI <tlbi_op>{, <Xt>}"
  ],
  [
    "C6.2.329",
    "TSB CSYNC",
    "tsb",
    "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions. If FEAT_TRF is not implemented, this instruction executes as a NOP.  ARMv8.4",
    "TSB CSYNC"
  ],
  [
    "C6.2.330",
    "TST (immediate)",
    "tst",
    "Test bits (immediate), setting the condition flags and discarding the result : Rn AND imm This instruction is an alias of the ANDS (immediate) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ANDS (immediate).  \n  -  The description of ANDS (immediate) gives the operational pseudocode for this instruction. ",
    "TST <Wn>, #<imm>\nTST <Xn>, #<imm>"
  ],
  [
    "C6.2.331",
    "TST (shifted register)",
    "tst",
    "Test (shifted register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result. This instruction is an alias of the ANDS (shifted register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ANDS (shifted register).  \n  -  The description of ANDS (shifted register) gives the operational pseudocode for this instruction. ",
    "TST <Wn>, <Wm>{, <shift> #<amount>}\nTST <Xn>, <Xm>{, <shift> #<amount>}"
  ],
  [
    "C6.2.332",
    "UBFIZ",
    "ubfiz",
    "Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register to bit position <lsb> of the destination register, setting the destination bits above and below the bitfield to zero. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "UBFIZ <Wd>, <Wn>, #<lsb>, #<width>\nUBFIZ <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.333",
    "UBFM",
    "ubfm",
    "Unsigned Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly. If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position <immr> in the source register to the least significant bits of the destination register. If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32 or 64 bits. In both cases the destination bits below and above the bitfield are set to zero. This instruction is used by the aliases LSL (immediate), LSR (immediate), UBFIZ, UBFX, UXTB, and UXTH. See Alias conditions on page C6-1374 for details of when each alias is preferred. ",
    "UBFM <Wd>, <Wn>, #<immr>, #<imms>\nUBFM <Xd>, <Xn>, #<immr>, #<imms>"
  ],
  [
    "C6.2.334",
    "UBFX",
    "ubfx",
    "Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to zero. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "UBFX <Wd>, <Wn>, #<lsb>, #<width>\nUBFX <Xd>, <Xn>, #<lsb>, #<width>"
  ],
  [
    "C6.2.335",
    "UDF",
    "udf",
    "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC = 0b000000). The encodings for UDF used in this section are defined as permanently UNDEFINED in the Armv8-A architecture. ",
    "UDF #<imm>"
  ],
  [
    "C6.2.336",
    "UDIV",
    "udiv",
    "Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes the result to the destination register. The condition flags are not affected. ",
    "UDIV <Wd>, <Wn>, <Wm>\nUDIV <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.337",
    "UMADDL",
    "umaddl",
    "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register. This instruction is used by the alias UMULL. See Alias conditions for details of when each alias is preferred. ",
    "UMADDL <Xd>, <Wn>, <Wm>, <Xa>"
  ],
  [
    "C6.2.338",
    "UMNEGL",
    "umnegl",
    "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register. This instruction is an alias of the UMSUBL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UMSUBL.  \n  -  The description of UMSUBL gives the operational pseudocode for this instruction. ",
    "UMNEGL <Xd>, <Wn>, <Wm>"
  ],
  [
    "C6.2.339",
    "UMSUBL",
    "umsubl",
    "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register. This instruction is used by the alias UMNEGL. See Alias conditions for details of when each alias is preferred. ",
    "UMSUBL <Xd>, <Wn>, <Wm>, <Xa>"
  ],
  [
    "C6.2.340",
    "UMULH",
    "umulh",
    "Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register. ",
    "UMULH <Xd>, <Xn>, <Xm>"
  ],
  [
    "C6.2.341",
    "UMULL",
    "umull",
    "Unsigned Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register. This instruction is an alias of the UMADDL instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UMADDL.  \n  -  The description of UMADDL gives the operational pseudocode for this instruction. ",
    "UMULL <Xd>, <Wn>, <Wm>"
  ],
  [
    "C6.2.342",
    "UXTB",
    "uxtb",
    "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "UXTB <Wd>, <Wn>"
  ],
  [
    "C6.2.343",
    "UXTH",
    "uxth",
    "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register. This instruction is an alias of the UBFM instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UBFM.  \n  -  The description of UBFM gives the operational pseudocode for this instruction. ",
    "UXTH <Wd>, <Wn>"
  ],
  [
    "C6.2.344",
    "WFE",
    "wfe",
    "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait for Event mechanism and Send event on page D1-2391. As described in Wait for Event mechanism and Send event on page D1-2391, the execution of a WFE instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See: \n  -  Traps to EL1 of EL0 execution of WFE and WFI instructions on page D1-2371.  \n  -  Traps to EL2 of EL0 and EL1 execution of WFE and WFI instructions on page D1-2380.  \n  -  Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions on page D1-2387. ",
    "WFE"
  ],
  [
    "C6.2.345",
    "WFI",
    "wfi",
    "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see Wait For Interrupt on page D1-2394. As described in Wait For Interrupt on page D1-2394, the execution of a WFI instruction that would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See: \n  -  Traps to EL1 of EL0 execution of WFE and WFI instructions on page D1-2371.  \n  -  Traps to EL2 of EL0 and EL1 execution of WFE and WFI instructions on page D1-2380.  \n  -  Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions on page D1-2387. ",
    "WFI"
  ],
  [
    "C6.2.346",
    "XAFLAG",
    "xaflag",
    "Convert floating-point condition flags from external format to Arm format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the result of an Arm floating-point scalar compare instruction.  ARMv8.5",
    "XAFLAG"
  ],
  [
    "C6.2.347",
    "XPACD, XPACI, XPACLRI",
    "xpacd,",
    "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI. The XPACD instruction is used for data addresses, and XPACI and XPACLRI are used for instruction addresses.  Integer ARMv8.3",
    ""
  ],
  [
    "C6.2.348",
    "YIELD",
    "yield",
    "YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability. For more information about the recommended use of this instruction, see The YIELD instruction on page B1-112. ",
    "YIELD"
  ],
  [
    "C7.2.1",
    "ABS",
    "abs",
    "Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "ABS <V><d>, <V><n>"
  ],
  [
    "C7.2.2",
    "ADD (vector)",
    "add",
    "Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "ADD <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.3",
    "ADDHN, ADDHN2",
    "addhn,",
    "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The results are truncated. For rounded results, see RADDHN, RADDHN2. The ADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the ADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.4",
    "ADDP (scalar)",
    "addp",
    "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ADDP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.5",
    "ADDP (vector)",
    "addp",
    "Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.6",
    "ADDV",
    "addv",
    "Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ADDV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.7",
    "AESD",
    "aesd",
    "AES single round decryption. ",
    "AESD <Vd>.16B, <Vn>.16B"
  ],
  [
    "C7.2.8",
    "AESE",
    "aese",
    "AES single round encryption. ",
    "AESE <Vd>.16B, <Vn>.16B"
  ],
  [
    "C7.2.9",
    "AESIMC",
    "aesimc",
    "AES inverse mix columns. ",
    "AESIMC <Vd>.16B, <Vn>.16B"
  ],
  [
    "C7.2.10",
    "AESMC",
    "aesmc",
    "AES mix columns. ",
    "AESMC <Vd>.16B, <Vn>.16B"
  ],
  [
    "C7.2.11",
    "AND (vector)",
    "and",
    "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "AND <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.12",
    "BCAX",
    "bcax",
    "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA3 is implemented.  ARMv8.2",
    "BCAX <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
  ],
  [
    "C7.2.13",
    "BFCVT",
    "bfcvt",
    "Floating-point convert from single-precision to BFloat16 format (scalar) converts the single-precision floating-point value in the 32-bit SIMD&FP source register to BFloat16 format and writes the result in the 16-bit SIMD&FP destination register. Unlike the BFloat16 multiplication instructions, this instruction honors all the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. This instruction can generate a floating-point exception that causes a cumulative exception bit in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.  ARMv8.6",
    "BFCVT <Hd>, <Sn>"
  ],
  [
    "C7.2.14",
    "BFCVTN, BFCVTN2",
    "bfcvtn,",
    "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&FP destination vector. The result elements are half the width of the source elements. The BFCVTN instruction writes the half-width results to the lower half of the destination vector and clears the upper half to zero, while the BFCVTN2 instruction writes the results to the upper half of the destination vector without affecting the other bits in the register. Unlike the BFloat16 multiplication instructions, this instruction honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR.  ARMv8.6",
    ""
  ],
  [
    "C7.2.15",
    "BFDOT (by element)",
    "bfdot",
    "BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Each pair of elements in the first source vector is multiplied by the specified pair of elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the FPCR and does not update the FPSR exception status. The BF16 pair within the second source vector is specified using an immediate index. The index range is from 0 to 3 inclusive. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.  ARMv8.6",
    "BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]"
  ],
  [
    "C7.2.16",
    "BFDOT (vector)",
    "bfdot",
    "BFloat16 floating-point dot product (vector). This instruction delimits the source vectors into pairs of 16-bit BF16 elements. Within each pair, the elements in the first source vector are multiplied by the corresponding elements in the second source vector. The resulting single-precision products are then summed and added destructively to the single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector. The instruction ignores the FPCR and does not update the FPSR exception status.  ARMv8.6",
    "BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
  ],
  [
    "C7.2.17",
    "BFMLALB, BFMLALT (by element)",
    "bfmlalb,",
    "BFloat16 floating-point widening multiply-add long (by element) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first source vector, and the indexed element in the second source vector from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector. This performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.  ARMv8.6",
    ""
  ],
  [
    "C7.2.18",
    "BFMLALB, BFMLALT (vector)",
    "bfmlalb,",
    "BFloat16 floating-point widening multiply-add long (vector) widens the even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping single-precision elements of the destination vector. This performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.  ARMv8.6",
    ""
  ],
  [
    "C7.2.19",
    "BFMMLA",
    "bfmmla",
    "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This instruction multiplies the 2x4 matrix of BF16 values held in the first 128-bit source vector by the 4x2 BF16 matrix in the second 128-bit source vector. The resulting 2x2 single-precision matrix product is then added destructively to the 2x2 single-precision matrix in the 128-bit destination vector. This is equivalent to performing a 4-way dot product per destination element. The instruction ignores the FPCR and does not update the FPSR exception status.  Note Arm expects that the BFMMLA instruction will deliver a peak BF16 multiply throughput that is at least as high as can be achieved using two BFDOT instructions, with a goal that it should have significantly higher throughput.  ARMv8.6",
    "BFMMLA <Vd>.4S, <Vn>.8H, <Vm>.8H"
  ],
  [
    "C7.2.20",
    "BIC (vector, immediate)",
    "bic",
    "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}\nBIC <Vd>.<T>, #<imm8>{, LSL #<amount>}"
  ],
  [
    "C7.2.21",
    "BIC (vector, register)",
    "bic",
    "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP register and the complement of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "BIC <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.22",
    "BIF",
    "bif",
    "Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&FP register into the destination SIMD&FP register if the corresponding bit of the second source SIMD&FP register is 0, otherwise leaves the bit in the destination register unchanged. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "BIF <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.23",
    "BIT",
    "bit",
    "Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&FP register into the SIMD&FP destination register if the corresponding bit of the second source SIMD&FP register is 1, otherwise leaves the bit in the destination register unchanged. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "BIT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.24",
    "BSL",
    "bsl",
    "Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "BSL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.25",
    "CLS (vector)",
    "cls",
    "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include the most significant bit itself. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "CLS <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.26",
    "CLZ (vector)",
    "clz",
    "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "CLZ <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.27",
    "CMEQ (register)",
    "cmeq",
    "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMEQ <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.28",
    "CMEQ (zero)",
    "cmeq",
    "Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMEQ <V><d>, <V><n>, #0"
  ],
  [
    "C7.2.29",
    "CMGE (register)",
    "cmge",
    "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMGE <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.30",
    "CMGE (zero)",
    "cmge",
    "Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMGE <V><d>, <V><n>, #0"
  ],
  [
    "C7.2.31",
    "CMGT (register)",
    "cmgt",
    "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMGT <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.32",
    "CMGT (zero)",
    "cmgt",
    "Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMGT <V><d>, <V><n>, #0"
  ],
  [
    "C7.2.33",
    "CMHI (register)",
    "cmhi",
    "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMHI <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.34",
    "CMHS (register)",
    "cmhs",
    "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMHS <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.35",
    "CMLE (zero)",
    "cmle",
    "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMLE <V><d>, <V><n>, #0"
  ],
  [
    "C7.2.36",
    "CMLT (zero)",
    "cmlt",
    "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMLT <V><d>, <V><n>, #0"
  ],
  [
    "C7.2.37",
    "CMTST",
    "cmtst",
    "Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "CMTST <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.38",
    "CNT",
    "cnt",
    "Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "CNT <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.39",
    "DUP (element)",
    "dup",
    "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MOV (scalar). The alias is always the preferred disassembly.  Scalar",
    "DUP <V><d>, <Vn>.<T>[<index>]"
  ],
  [
    "C7.2.40",
    "DUP (general)",
    "dup",
    "Duplicate general-purpose register to vector. This instruction duplicates the contents of the source general-purpose register into a scalar or each element in a vector, and writes the result to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "DUP <Vd>.<T>, <R><n>"
  ],
  [
    "C7.2.41",
    "EOR (vector)",
    "eor",
    "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source SIMD&FP registers, and places the result in the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "EOR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.42",
    "EOR3",
    "eor3",
    "Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers, and writes the result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA3 is implemented.  ARMv8.2",
    "EOR3 <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
  ],
  [
    "C7.2.43",
    "EXT",
    "ext",
    "Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source SIMD&FP register and the highest vector elements from the first source SIMD&FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled. The following figure shows the operation of EXT doubleword operation for Q = 0 and imm4<2:0> = 3. 7 6 5 4 3 2 1 0 Vm  7 6 5 4 3 2 1 0 Vn  Vd  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "EXT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>"
  ],
  [
    "C7.2.44",
    "FABD",
    "fabd",
    "Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FABD <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.45",
    "FABS (vector)",
    "fabs",
    "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FABS <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.46",
    "FABS (scalar)",
    "fabs",
    "Floating-point Absolute value (scalar). This instruction calculates the absolute value in the SIMD&FP source register and writes the result to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FABS <Hd>, <Hn>\nFABS <Sd>, <Sn>\nFABS <Dd>, <Dn>"
  ],
  [
    "C7.2.47",
    "FACGE",
    "facge",
    "Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FACGE <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.48",
    "FACGT",
    "facgt",
    "Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the second source SIMD&FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FACGT <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.49",
    "FADD (vector)",
    "fadd",
    "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.50",
    "FADD (scalar)",
    "fadd",
    "Floating-point Add (scalar). This instruction adds the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FADD <Hd>, <Hn>, <Hm>\nFADD <Sd>, <Sn>, <Sm>\nFADD <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.51",
    "FADDP (scalar)",
    "faddp",
    "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&FP register and writes the scalar result into the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FADDP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.52",
    "FADDP (vector)",
    "faddp",
    "Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.53",
    "FCADD",
    "fcadd",
    "Floating-point Complex Add. This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers: \n  -  Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 90 or 270 degrees.  \n  -  The rotated complex number is added to the complex number from the first source register.  This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.3",
    "FCADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
  ],
  [
    "C7.2.54",
    "FCCMP",
    "fccmp",
    "Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier. It raises an Invalid Operation exception only if either operand is a signaling NaN. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCCMP <Hn>, <Hm>, #<nzcv>, <cond>\nFCCMP <Sn>, <Sm>, #<nzcv>, <cond>\nFCCMP <Dn>, <Dm>, #<nzcv>, <cond>"
  ],
  [
    "C7.2.55",
    "FCCMPE",
    "fccmpe",
    "Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier. If either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCCMPE <Hn>, <Hm>, #<nzcv>, <cond>\nFCCMPE <Sn>, <Sm>, #<nzcv>, <cond>\nFCCMPE <Dn>, <Dm>, #<nzcv>, <cond>"
  ],
  [
    "C7.2.56",
    "FCMEQ (register)",
    "fcmeq",
    "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMEQ <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.57",
    "FCMEQ (zero)",
    "fcmeq",
    "Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMEQ <Hd>, <Hn>, #0.0"
  ],
  [
    "C7.2.58",
    "FCMGE (register)",
    "fcmge",
    "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMGE <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.59",
    "FCMGE (zero)",
    "fcmge",
    "Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMGE <Hd>, <Hn>, #0.0"
  ],
  [
    "C7.2.60",
    "FCMGT (register)",
    "fcmgt",
    "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMGT <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.61",
    "FCMGT (zero)",
    "fcmgt",
    "Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMGT <Hd>, <Hn>, #0.0"
  ],
  [
    "C7.2.62",
    "FCMLA (by element)",
    "fcmla",
    "Floating-point Complex Multiply Accumulate (by element). This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on complex numbers from the first source register and the destination register with the specified complex number from the second source register: \n  -  Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.  \n  -  The two elements of the transformed complex number are multiplied by:  \n  -  \u2014  The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.  \u2014  The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.  The complex number resulting from that multiplication is added to the complex number from the destination register.  The multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.3",
    "FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>\nFCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
  ],
  [
    "C7.2.63",
    "FCMLA",
    "fcmla",
    "Floating-point Complex Multiply Accumulate. This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers and the destination register: \n  -  Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.  \n  -  The two elements of the transformed complex number are multiplied by:  \n  -  \u2014  The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.  \u2014  The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.  The complex number resulting from that multiplication is added to the complex number from the destination register.  The multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.3",
    "FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
  ],
  [
    "C7.2.64",
    "FCMLE (zero)",
    "fcmle",
    "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMLE <Hd>, <Hn>, #0.0"
  ],
  [
    "C7.2.65",
    "FCMLT (zero)",
    "fcmlt",
    "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCMLT <Hd>, <Hn>, #0.0"
  ],
  [
    "C7.2.66",
    "FCMP",
    "fcmp",
    "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags. It raises an Invalid Operation exception only if either operand is a signaling NaN. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCMP <Hn>, <Hm>\nFCMP <Hn>, #0.0\nFCMP <Sn>, <Sm>\nFCMP <Sn>, #0.0\nFCMP <Dn>, <Dm>\nFCMP <Dn>, #0.0"
  ],
  [
    "C7.2.67",
    "FCMPE",
    "fcmpe",
    "Floating-point signaling Compare (scalar). This instruction compares the two SIMD&FP source register values, or the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags. If either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCMPE <Hn>, <Hm>\nFCMPE <Hn>, #0.0\nFCMPE <Sn>, <Sm>\nFCMPE <Sn>, #0.0\nFCMPE <Dn>, <Dm>\nFCMPE <Dn>, #0.0"
  ],
  [
    "C7.2.68",
    "FCSEL",
    "fcsel",
    "Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP destination register to take the value from either one or the other of two SIMD&FP source registers. If the condition passes, the first SIMD&FP source register value is taken, otherwise the second SIMD&FP source register value is taken. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCSEL <Hd>, <Hn>, <Hm>, <cond>\nFCSEL <Sd>, <Sn>, <Sm>, <cond>\nFCSEL <Dd>, <Dn>, <Dm>, <cond>"
  ],
  [
    "C7.2.69",
    "FCVT",
    "fcvt",
    "Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&FP source register to the precision for the destination register data type using the rounding mode that is determined by the FPCR and writes the result to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVT <Sd>, <Hn>\nFCVT <Dd>, <Hn>\nFCVT <Hd>, <Sn>\nFCVT <Dd>, <Sn>\nFCVT <Hd>, <Dn>\nFCVT <Sd>, <Dn>"
  ],
  [
    "C7.2.70",
    "FCVTAS (vector)",
    "fcvtas",
    "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTAS <Hd>, <Hn>"
  ],
  [
    "C7.2.71",
    "FCVTAS (scalar)",
    "fcvtas",
    "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTAS <Wd>, <Hn>\nFCVTAS <Xd>, <Hn>\nFCVTAS <Wd>, <Sn>\nFCVTAS <Xd>, <Sn>\nFCVTAS <Wd>, <Dn>\nFCVTAS <Xd>, <Dn>"
  ],
  [
    "C7.2.72",
    "FCVTAU (vector)",
    "fcvtau",
    "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTAU <Hd>, <Hn>"
  ],
  [
    "C7.2.73",
    "FCVTAU (scalar)",
    "fcvtau",
    "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTAU <Wd>, <Hn>\nFCVTAU <Xd>, <Hn>\nFCVTAU <Wd>, <Sn>\nFCVTAU <Xd>, <Sn>\nFCVTAU <Wd>, <Dn>\nFCVTAU <Xd>, <Dn>"
  ],
  [
    "C7.2.74",
    "FCVTL, FCVTL2",
    "fcvtl,",
    "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&FP destination register. Where the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 variant operates on the elements in the top 64 bits of the source register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.75",
    "FCVTMS (vector)",
    "fcvtms",
    "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTMS <Hd>, <Hn>"
  ],
  [
    "C7.2.76",
    "FCVTMS (scalar)",
    "fcvtms",
    "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTMS <Wd>, <Hn>\nFCVTMS <Xd>, <Hn>\nFCVTMS <Wd>, <Sn>\nFCVTMS <Xd>, <Sn>\nFCVTMS <Wd>, <Dn>\nFCVTMS <Xd>, <Dn>"
  ],
  [
    "C7.2.77",
    "FCVTMU (vector)",
    "fcvtmu",
    "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTMU <Hd>, <Hn>"
  ],
  [
    "C7.2.78",
    "FCVTMU (scalar)",
    "fcvtmu",
    "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Minus Infinity rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTMU <Wd>, <Hn>\nFCVTMU <Xd>, <Hn>\nFCVTMU <Wd>, <Sn>\nFCVTMU <Xd>, <Sn>\nFCVTMU <Wd>, <Dn>\nFCVTMU <Xd>, <Dn>"
  ],
  [
    "C7.2.79",
    "FCVTN, FCVTN2",
    "fcvtn,",
    "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR. The FCVTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.80",
    "FCVTNS (vector)",
    "fcvtns",
    "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTNS <Hd>, <Hn>"
  ],
  [
    "C7.2.81",
    "FCVTNS (scalar)",
    "fcvtns",
    "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTNS <Wd>, <Hn>\nFCVTNS <Xd>, <Hn>\nFCVTNS <Wd>, <Sn>\nFCVTNS <Xd>, <Sn>\nFCVTNS <Wd>, <Dn>\nFCVTNS <Xd>, <Dn>"
  ],
  [
    "C7.2.82",
    "FCVTNU (vector)",
    "fcvtnu",
    "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTNU <Hd>, <Hn>"
  ],
  [
    "C7.2.83",
    "FCVTNU (scalar)",
    "fcvtnu",
    "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to Nearest rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTNU <Wd>, <Hn>\nFCVTNU <Xd>, <Hn>\nFCVTNU <Wd>, <Sn>\nFCVTNU <Xd>, <Sn>\nFCVTNU <Wd>, <Dn>\nFCVTNU <Xd>, <Dn>"
  ],
  [
    "C7.2.84",
    "FCVTPS (vector)",
    "fcvtps",
    "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTPS <Hd>, <Hn>"
  ],
  [
    "C7.2.85",
    "FCVTPS (scalar)",
    "fcvtps",
    "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTPS <Wd>, <Hn>\nFCVTPS <Xd>, <Hn>\nFCVTPS <Wd>, <Sn>\nFCVTPS <Xd>, <Sn>\nFCVTPS <Wd>, <Dn>\nFCVTPS <Xd>, <Dn>"
  ],
  [
    "C7.2.86",
    "FCVTPU (vector)",
    "fcvtpu",
    "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTPU <Hd>, <Hn>"
  ],
  [
    "C7.2.87",
    "FCVTPU (scalar)",
    "fcvtpu",
    "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Plus Infinity rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTPU <Wd>, <Hn>\nFCVTPU <Xd>, <Hn>\nFCVTPU <Wd>, <Sn>\nFCVTPU <Xd>, <Sn>\nFCVTPU <Wd>, <Dn>\nFCVTPU <Xd>, <Dn>"
  ],
  [
    "C7.2.88",
    "FCVTXN, FCVTXN2",
    "fcvtxn,",
    "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP register.  Note This instruction uses the Round to Odd rounding mode which is not defined by the IEEE 754-2008 standard. This rounding mode ensures that if the result of the conversion is inexact the least significant bit of the mantissa is forced to 1. This rounding mode enables a floating-point value to be converted to a lower precision format via an intermediate precision format while avoiding double rounding errors. For example, a 64-bit floating-point value can be converted to a correctly rounded 16-bit floating-point value by first using this instruction to produce a 32-bit value and then using another instruction with the wanted rounding mode to convert the 32-bit value to the final 16-bit floating-point value. The FCVTXN instruction writes the vector to the lower half of the destination register and clears the upper half, while the FCVTXN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.89",
    "FCVTZS (vector, fixed-point)",
    "fcvtzs",
    "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar",
    "FCVTZS <V><d>, <V><n>, #<fbits>"
  ],
  [
    "C7.2.90",
    "FCVTZS (vector, integer)",
    "fcvtzs",
    "Floating-point Convert to Signed integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTZS <Hd>, <Hn>"
  ],
  [
    "C7.2.91",
    "FCVTZS (scalar, fixed-point)",
    "fcvtzs",
    "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped. ",
    "FCVTZS <Wd>, <Hn>, #<fbits>\nFCVTZS <Xd>, <Hn>, #<fbits>\nFCVTZS <Wd>, <Sn>, #<fbits>\nFCVTZS <Xd>, <Sn>, #<fbits>\nFCVTZS <Wd>, <Dn>, #<fbits>\nFCVTZS <Xd>, <Dn>, #<fbits>"
  ],
  [
    "C7.2.92",
    "FCVTZS (scalar, integer)",
    "fcvtzs",
    "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTZS <Wd>, <Hn>\nFCVTZS <Xd>, <Hn>\nFCVTZS <Wd>, <Sn>\nFCVTZS <Xd>, <Sn>\nFCVTZS <Wd>, <Dn>\nFCVTZS <Xd>, <Dn>"
  ],
  [
    "C7.2.93",
    "FCVTZU (vector, fixed-point)",
    "fcvtzu",
    "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar",
    "FCVTZU <V><d>, <V><n>, #<fbits>"
  ],
  [
    "C7.2.94",
    "FCVTZU (vector, integer)",
    "fcvtzu",
    "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FCVTZU <Hd>, <Hn>"
  ],
  [
    "C7.2.95",
    "FCVTZU (scalar, fixed-point)",
    "fcvtzu",
    "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped. ",
    "FCVTZU <Wd>, <Hn>, #<fbits>\nFCVTZU <Xd>, <Hn>, #<fbits>\nFCVTZU <Wd>, <Sn>, #<fbits>\nFCVTZU <Xd>, <Sn>, #<fbits>\nFCVTZU <Wd>, <Dn>, #<fbits>\nFCVTZU <Xd>, <Dn>, #<fbits>"
  ],
  [
    "C7.2.96",
    "FCVTZU (scalar, integer)",
    "fcvtzu",
    "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This instruction converts the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FCVTZU <Wd>, <Hn>\nFCVTZU <Xd>, <Hn>\nFCVTZU <Wd>, <Sn>\nFCVTZU <Xd>, <Sn>\nFCVTZU <Wd>, <Dn>\nFCVTZU <Xd>, <Dn>"
  ],
  [
    "C7.2.97",
    "FDIV (vector)",
    "fdiv",
    "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.98",
    "FDIV (scalar)",
    "fdiv",
    "Floating-point Divide (scalar). This instruction divides the floating-point value of the first source SIMD&FP register by the floating-point value of the second source SIMD&FP register, and writes the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FDIV <Hd>, <Hn>, <Hm>\nFDIV <Sd>, <Sn>, <Sm>\nFDIV <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.99",
    "FJCVTZS",
    "fjcvtzs",
    "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. This instruction converts the double-precision floating-point value in the SIMD&FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too large to be accommodated as a signed 32-bit integer, then the result is the integer modulo 232, as held in a 32-bit signed integer. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.3",
    "FJCVTZS <Wd>, <Dn>"
  ],
  [
    "C7.2.100",
    "FMADD",
    "fmadd",
    "Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMADD <Hd>, <Hn>, <Hm>, <Ha>\nFMADD <Sd>, <Sn>, <Sm>, <Sa>\nFMADD <Dd>, <Dn>, <Dm>, <Da>"
  ],
  [
    "C7.2.101",
    "FMAX (vector)",
    "fmax",
    "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.102",
    "FMAX (scalar)",
    "fmax",
    "Floating-point Maximum (scalar). This instruction compares the two source SIMD&FP registers, and writes the larger of the two floating-point values to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMAX <Hd>, <Hn>, <Hm>\nFMAX <Sd>, <Sn>, <Sm>\nFMAX <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.103",
    "FMAXNM (vector)",
    "fmaxnm",
    "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.104",
    "FMAXNM (scalar)",
    "fmaxnm",
    "Floating-point Maximum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the larger of the two floating-point values to the destination SIMD&FP register. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMAXNM <Hd>, <Hn>, <Hm>\nFMAXNM <Sd>, <Sn>, <Sm>\nFMAXNM <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.105",
    "FMAXNMP (scalar)",
    "fmaxnmp",
    "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXNMP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.106",
    "FMAXNMP (vector)",
    "fmaxnmp",
    "Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMAX (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.107",
    "FMAXNMV",
    "fmaxnmv",
    "Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMAX (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXNMV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.108",
    "FMAXP (scalar)",
    "fmaxp",
    "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.109",
    "FMAXP (vector)",
    "fmaxp",
    "Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.110",
    "FMAXV",
    "fmaxv",
    "Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMAXV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.111",
    "FMIN (vector)",
    "fmin",
    "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.112",
    "FMIN (scalar)",
    "fmin",
    "Floating-point Minimum (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMIN <Hd>, <Hn>, <Hm>\nFMIN <Sd>, <Sn>, <Sm>\nFMIN <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.113",
    "FMINNM (vector)",
    "fminnm",
    "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&FP register. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.114",
    "FMINNM (scalar)",
    "fminnm",
    "Floating-point Minimum Number (scalar). This instruction compares the first and second source SIMD&FP register values, and writes the smaller of the two floating-point values to the destination SIMD&FP register. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMINNM <Hd>, <Hn>, <Hm>\nFMINNM <Sd>, <Sn>, <Sm>\nFMINNM <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.115",
    "FMINNMP (scalar)",
    "fminnmp",
    "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINNMP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.116",
    "FMINNMP (vector)",
    "fminnmp",
    "Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result is the numerical value, otherwise the result is identical to FMIN (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.117",
    "FMINNMV",
    "fminnmv",
    "Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values. NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMIN (scalar). This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINNMV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.118",
    "FMINP (scalar)",
    "fminp",
    "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINP <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.119",
    "FMINP (vector)",
    "fminp",
    "Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.120",
    "FMINV",
    "fminv",
    "Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMINV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.121",
    "FMLA (by element)",
    "fmla",
    "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results in the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar, half-precision ARMv8.2",
    "FMLA <Hd>, <Hn>, <Vm>.H[<index>]"
  ],
  [
    "C7.2.122",
    "FMLA (vector)",
    "fmla",
    "Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.123",
    "FMLAL, FMLAL2 (by element)",
    "fmlal,",
    "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.  FMLAL ARMv8.2",
    ""
  ],
  [
    "C7.2.124",
    "FMLAL, FMLAL2 (vector)",
    "fmlal,",
    "Floating-point fused Multiply-Add Long to accumulator (vector). This instruction multiplies corresponding half-precision floating-point values in the vectors in the two source SIMD&FP registers, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.  FMLAL ARMv8.2",
    ""
  ],
  [
    "C7.2.125",
    "FMLS (by element)",
    "fmls",
    "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar, half-precision ARMv8.2",
    "FMLS <Hd>, <Hn>, <Vm>.H[<index>]"
  ],
  [
    "C7.2.126",
    "FMLS (vector)",
    "fmls",
    "Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the corresponding vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.127",
    "FMLSL, FMLSL2 (by element)",
    "fmlsl,",
    "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.  FMLSL ARMv8.2",
    ""
  ],
  [
    "C7.2.128",
    "FMLSL, FMLSL2 (vector)",
    "fmlsl,",
    "Floating-point fused Multiply-Subtract Long from accumulator (vector). This instruction negates the values in the vector of one SIMD&FP register, multiplies these with the corresponding values in another vector, and accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round the result of the multiply before the accumulation. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.  FMLSL ARMv8.2",
    ""
  ],
  [
    "C7.2.129",
    "FMOV (vector, immediate)",
    "fmov",
    "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMOV <Vd>.<T>, #<imm>"
  ],
  [
    "C7.2.130",
    "FMOV (register)",
    "fmov",
    "Floating-point Move register without conversion. This instruction copies the floating-point value in the SIMD&FP source register to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMOV <Hd>, <Hn>\nFMOV <Sd>, <Sn>\nFMOV <Dd>, <Dn>"
  ],
  [
    "C7.2.131",
    "FMOV (general)",
    "fmov",
    "Floating-point Move to or from general-purpose register without conversion. This instruction transfers the contents of a SIMD&FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMOV <Wd>, <Hn>\nFMOV <Xd>, <Hn>\nFMOV <Hd>, <Wn>\nFMOV <Sd>, <Wn>\nFMOV <Wd>, <Sn>\nFMOV <Hd>, <Xn>\nFMOV <Dd>, <Xn>\nFMOV <Vd>.D[1], <Xn>"
  ],
  [
    "C7.2.132",
    "FMOV (scalar, immediate)",
    "fmov",
    "Floating-point move immediate (scalar). This instruction copies a floating-point immediate constant into the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMOV <Hd>, #<imm>\nFMOV <Sd>, #<imm>\nFMOV <Dd>, #<imm>"
  ],
  [
    "C7.2.133",
    "FMSUB",
    "fmsub",
    "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMSUB <Hd>, <Hn>, <Hm>, <Ha>\nFMSUB <Sd>, <Sn>, <Sm>, <Sa>\nFMSUB <Dd>, <Dn>, <Dm>, <Da>"
  ],
  [
    "C7.2.134",
    "FMUL (by element)",
    "fmul",
    "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point values. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar, half-precision ARMv8.2",
    "FMUL <Hd>, <Hn>, <Vm>.H[<index>]"
  ],
  [
    "C7.2.135",
    "FMUL (vector)",
    "fmul",
    "Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.136",
    "FMUL (scalar)",
    "fmul",
    "Floating-point Multiply (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FMUL <Hd>, <Hn>, <Hm>\nFMUL <Sd>, <Sn>, <Sm>\nFMUL <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.137",
    "FMULX (by element)",
    "fmulx",
    "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&FP register by the specified floating-point value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar, half-precision ARMv8.2",
    "FMULX <Hd>, <Hn>, <Vm>.H[<index>]"
  ],
  [
    "C7.2.138",
    "FMULX",
    "fmulx",
    "Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register. If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of the values is negative, otherwise the result is positive. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FMULX <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.139",
    "FNEG (vector)",
    "fneg",
    "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FNEG <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.140",
    "FNEG (scalar)",
    "fneg",
    "Floating-point Negate (scalar). This instruction negates the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FNEG <Hd>, <Hn>\nFNEG <Sd>, <Sn>\nFNEG <Dd>, <Dn>"
  ],
  [
    "C7.2.141",
    "FNMADD",
    "fnmadd",
    "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, negates the product, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FNMADD <Hd>, <Hn>, <Hm>, <Ha>\nFNMADD <Sd>, <Sn>, <Sm>, <Sa>\nFNMADD <Dd>, <Dn>, <Dm>, <Da>"
  ],
  [
    "C7.2.142",
    "FNMSUB",
    "fnmsub",
    "Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP source registers, subtracts the value of the third SIMD&FP source register, and writes the result to the destination SIMD&FP register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FNMSUB <Hd>, <Hn>, <Hm>, <Ha>\nFNMSUB <Sd>, <Sn>, <Sm>, <Sa>\nFNMSUB <Dd>, <Dn>, <Dm>, <Da>"
  ],
  [
    "C7.2.143",
    "FNMUL (scalar)",
    "fnmul",
    "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP registers, and writes the negation of the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FNMUL <Hd>, <Hn>, <Hm>\nFNMUL <Sd>, <Sn>, <Sm>\nFNMUL <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.144",
    "FRECPE",
    "frecpe",
    "Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FRECPE <Hd>, <Hn>"
  ],
  [
    "C7.2.145",
    "FRECPS",
    "frecps",
    "Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FRECPS <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.146",
    "FRECPX",
    "frecpx",
    "Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRECPX <Hd>, <Hn>"
  ],
  [
    "C7.2.147",
    "FRINT32X (vector)",
    "frint32x",
    "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT32X <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.148",
    "FRINT32X (scalar)",
    "frint32x",
    "Floating-point Round to 32-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT32X <Sd>, <Sn>\nFRINT32X <Dd>, <Dn>"
  ],
  [
    "C7.2.149",
    "FRINT32Z (vector)",
    "frint32z",
    "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT32Z <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.150",
    "FRINT32Z (scalar)",
    "frint32z",
    "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When the result value is not numerically equal to the {corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT32Z <Sd>, <Sn>\nFRINT32Z <Dd>, <Dn>"
  ],
  [
    "C7.2.151",
    "FRINT64X (vector)",
    "frint64x",
    "Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT64X <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.152",
    "FRINT64X (scalar)",
    "frint64x",
    "Floating-point Round to 64-bit Integer, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When the result value is not numerically equal to the input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT64X <Sd>, <Sn>\nFRINT64X <Dd>, <Dn>"
  ],
  [
    "C7.2.153",
    "FRINT64Z (vector)",
    "frint64z",
    "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the instruction returns for the corresponding result value the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT64Z <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.154",
    "FRINT64Z (scalar)",
    "frint64z",
    "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input returns a zero result with the same sign. When the result value is not numerically equal to the {corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for the corresponding result value} the most negative integer representable in the destination size, and an Invalid Operation floating-point exception is raised. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  ARMv8.5",
    "FRINT64Z <Sd>, <Sn>\nFRINT64Z <Dd>, <Dn>"
  ],
  [
    "C7.2.155",
    "FRINTA (vector)",
    "frinta",
    "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTA <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.156",
    "FRINTA (scalar)",
    "frinta",
    "Floating-point Round to Integral, to nearest with ties to Away (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTA <Hd>, <Hn>\nFRINTA <Sd>, <Sn>\nFRINTA <Dd>, <Dn>"
  ],
  [
    "C7.2.157",
    "FRINTI (vector)",
    "frinti",
    "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTI <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.158",
    "FRINTI (scalar)",
    "frinti",
    "Floating-point Round to Integral, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTI <Hd>, <Hn>\nFRINTI <Sd>, <Sn>\nFRINTI <Dd>, <Dn>"
  ],
  [
    "C7.2.159",
    "FRINTM (vector)",
    "frintm",
    "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTM <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.160",
    "FRINTM (scalar)",
    "frintm",
    "Floating-point Round to Integral, toward Minus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTM <Hd>, <Hn>\nFRINTM <Sd>, <Sn>\nFRINTM <Dd>, <Dn>"
  ],
  [
    "C7.2.161",
    "FRINTN (vector)",
    "frintn",
    "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTN <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.162",
    "FRINTN (scalar)",
    "frintn",
    "Floating-point Round to Integral, to nearest with ties to even (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTN <Hd>, <Hn>\nFRINTN <Sd>, <Sn>\nFRINTN <Dd>, <Dn>"
  ],
  [
    "C7.2.163",
    "FRINTP (vector)",
    "frintp",
    "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTP <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.164",
    "FRINTP (scalar)",
    "frintp",
    "Floating-point Round to Integral, toward Plus infinity (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTP <Hd>, <Hn>\nFRINTP <Sd>, <Sn>\nFRINTP <Dd>, <Dn>"
  ],
  [
    "C7.2.165",
    "FRINTX (vector)",
    "frintx",
    "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. When a result value is not numerically equal to the corresponding input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTX <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.166",
    "FRINTX (scalar)",
    "frintx",
    "Floating-point Round to Integral exact, using current rounding mode (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register. When the result value is not numerically equal to the input value, an Inexact exception is raised. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTX <Hd>, <Hn>\nFRINTX <Sd>, <Sn>\nFRINTX <Dd>, <Dn>"
  ],
  [
    "C7.2.167",
    "FRINTZ (vector)",
    "frintz",
    "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FRINTZ <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.168",
    "FRINTZ (scalar)",
    "frintz",
    "Floating-point Round to Integral, toward Zero (scalar). This instruction rounds a floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register. A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated as for normal arithmetic. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FRINTZ <Hd>, <Hn>\nFRINTZ <Sd>, <Sn>\nFRINTZ <Dd>, <Dn>"
  ],
  [
    "C7.2.169",
    "FRSQRTE",
    "frsqrte",
    "Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FRSQRTE <Hd>, <Hn>"
  ],
  [
    "C7.2.170",
    "FRSQRTS",
    "frsqrts",
    "Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "FRSQRTS <Hd>, <Hn>, <Hm>"
  ],
  [
    "C7.2.171",
    "FSQRT (vector)",
    "fsqrt",
    "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FSQRT <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.172",
    "FSQRT (scalar)",
    "fsqrt",
    "Floating-point Square Root (scalar). This instruction calculates the square root of the value in the SIMD&FP source register and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FSQRT <Hd>, <Hn>\nFSQRT <Sd>, <Sn>\nFSQRT <Dd>, <Dn>"
  ],
  [
    "C7.2.173",
    "FSUB (vector)",
    "fsub",
    "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Half-precision ARMv8.2",
    "FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.174",
    "FSUB (scalar)",
    "fsub",
    "Floating-point Subtract (scalar). This instruction subtracts the floating-point value of the second source SIMD&FP register from the floating-point value of the first source SIMD&FP register, and writes the result to the destination SIMD&FP register. This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "FSUB <Hd>, <Hn>, <Hm>\nFSUB <Sd>, <Sn>, <Sm>\nFSUB <Dd>, <Dn>, <Dm>"
  ],
  [
    "C7.2.175",
    "INS (element)",
    "ins",
    "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register. This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MOV (element). The alias is always the preferred disassembly. ",
    "INS <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
  ],
  [
    "C7.2.176",
    "INS (general)",
    "ins",
    "Insert vector element from general-purpose register. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register. This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MOV (from general). The alias is always the preferred disassembly. ",
    "INS <Vd>.<Ts>[<index>], <R><n>"
  ],
  [
    "C7.2.177",
    "LD1 (multiple structures)",
    "ld1",
    "Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD1 { <Vt>.<T> }, [<Xn|SP>]\nLD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\nLD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\nLD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.178",
    "LD1 (single structure)",
    "ld1",
    "Load one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&FP register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD1 { <Vt>.B }[<index>], [<Xn|SP>]\nLD1 { <Vt>.H }[<index>], [<Xn|SP>]\nLD1 { <Vt>.S }[<index>], [<Xn|SP>]\nLD1 { <Vt>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.179",
    "LD1R",
    "ld1r",
    "Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD1R { <Vt>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.180",
    "LD2 (multiple structures)",
    "ld2",
    "Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&FP registers, with de-interleaving. For an example of de-interleaving, see LD3 (multiple structures). Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.181",
    "LD2 (single structure)",
    "ld2",
    "Load single 2-element structure to one lane of two registers. This instruction loads a 2-element structure from memory and writes the result to the corresponding elements of the two SIMD&FP registers without affecting the other bits of the registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\nLD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\nLD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\nLD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.182",
    "LD2R",
    "ld2r",
    "Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.183",
    "LD3 (multiple structures)",
    "ld3",
    "Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&FP registers, with de-interleaving. The following figure shows the operation of de-interleaving of a LD3.16 (multiple 3-element structures) instruction:. Memory  A is a packed array of 3-element structures. Each element is a 16-bit halfword.  A[0].x A[0].y A[0].z A[1].x A[1].y A[1].z A[2].x A[2].y A[2].z A[3].x A[3].y A[3].z  X3 X2 X1 X0 D0 Registers  Y3 Y2 Y1 Y0 D1 Z3 Z2 Z1 Z0 D2  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.184",
    "LD3 (single structure)",
    "ld3",
    "Load single 3-element structure to one lane of three registers). This instruction loads a 3-element structure from memory and writes the result to the corresponding elements of the three SIMD&FP registers without affecting the other bits of the registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\nLD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\nLD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\nLD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.185",
    "LD3R",
    "ld3r",
    "Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.186",
    "LD4 (multiple structures)",
    "ld4",
    "Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&FP registers, with de-interleaving. For an example of de-interleaving, see LD3 (multiple structures). Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.187",
    "LD4 (single structure)",
    "ld4",
    "Load single 4-element structure to one lane of four registers. This instruction loads a 4-element structure from memory and writes the result to the corresponding elements of the four SIMD&FP registers without affecting the other bits of the registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\nLD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\nLD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\nLD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.188",
    "LD4R",
    "ld4r",
    "Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.189",
    "LDNP (SIMD&FP)",
    "ldnp",
    "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair on page C3-216. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "LDNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]\nLDNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\nLDNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
  ],
  [
    "C7.2.190",
    "LDP (SIMD&FP)",
    "ldp",
    "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Post-index",
    "LDP <St1>, <St2>, [<Xn|SP>], #<imm>\nLDP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\nLDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C7.2.191",
    "LDR (immediate, SIMD&FP)",
    "ldr",
    "Load SIMD&FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Post-index",
    "LDR <Bt>, [<Xn|SP>], #<simm>\nLDR <Ht>, [<Xn|SP>], #<simm>\nLDR <St>, [<Xn|SP>], #<simm>\nLDR <Dt>, [<Xn|SP>], #<simm>\nLDR <Qt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C7.2.192",
    "LDR (literal, SIMD&FP)",
    "ldr",
    "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from the PC value and an immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "LDR <St>, <label>\nLDR <Dt>, <label>\nLDR <Qt>, <label>"
  ],
  [
    "C7.2.193",
    "LDR (register, SIMD&FP)",
    "ldr",
    "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "LDR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nLDR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\nLDR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nLDR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nLDR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nLDR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C7.2.194",
    "LDUR (SIMD&FP)",
    "ldur",
    "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "LDUR <Bt>, [<Xn|SP>{, #<simm>}]\nLDUR <Ht>, [<Xn|SP>{, #<simm>}]\nLDUR <St>, [<Xn|SP>{, #<simm>}]\nLDUR <Dt>, [<Xn|SP>{, #<simm>}]\nLDUR <Qt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C7.2.195",
    "MLA (by element)",
    "mla",
    "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.196",
    "MLA (vector)",
    "mla",
    "Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.197",
    "MLS (by element)",
    "mls",
    "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.198",
    "MLS (vector)",
    "mls",
    "Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.199",
    "MOV (scalar)",
    "mov",
    "Move vector element to scalar. This instruction duplicates the specified vector element in the SIMD&FP source register into a scalar, and writes the result to the SIMD&FP destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the DUP (element) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of DUP (element).  \n  -  The description of DUP (element) gives the operational pseudocode for this instruction. ",
    "MOV <V><d>, <Vn>.<T>[<index>]"
  ],
  [
    "C7.2.200",
    "MOV (element)",
    "mov",
    "Move vector element to another vector element. This instruction copies the vector element of the source SIMD&FP register to the specified vector element of the destination SIMD&FP register. This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the INS (element) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of INS (element).  \n  -  The description of INS (element) gives the operational pseudocode for this instruction. ",
    "MOV <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
  ],
  [
    "C7.2.201",
    "MOV (from general)",
    "mov",
    "Move general-purpose register to a vector element. This instruction copies the contents of the source general-purpose register to the specified vector element in the destination SIMD&FP register. This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining bits to zero. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the INS (general) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of INS (general).  \n  -  The description of INS (general) gives the operational pseudocode for this instruction. ",
    "MOV <Vd>.<Ts>[<index>], <R><n>"
  ],
  [
    "C7.2.202",
    "MOV (vector)",
    "mov",
    "Move vector. This instruction copies the vector in the source SIMD&FP register into the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the ORR (vector, register) instruction. This means that: \n  -  The encodings in this description are named to match the encodings of ORR (vector, register).  \n  -  The description of ORR (vector, register) gives the operational pseudocode for this instruction. ",
    "MOV <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.203",
    "MOV (to general)",
    "mov",
    "Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the UMOV instruction. This means that: \n  -  The encodings in this description are named to match the encodings of UMOV.  \n  -  The description of UMOV gives the operational pseudocode for this instruction. ",
    "MOV <Wd>, <Vn>.S[<index>]\nMOV <Xd>, <Vn>.D[<index>]"
  ],
  [
    "C7.2.204",
    "MOVI",
    "movi",
    "Move Immediate (vector). This instruction places an immediate constant into every vector element of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MOVI <Vd>.<T>, #<imm8>{, LSL #0}\nMOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}\nMOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}\nMOVI <Vd>.<T>, #<imm8>, MSL #<amount>\nMOVI <Dd>, #<imm>\nMOVI <Vd>.2D, #<imm>"
  ],
  [
    "C7.2.205",
    "MUL (by element)",
    "mul",
    "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.206",
    "MUL (vector)",
    "mul",
    "Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.207",
    "MVN",
    "mvn",
    "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the NOT instruction. This means that: \n  -  The encodings in this description are named to match the encodings of NOT.  \n  -  The description of NOT gives the operational pseudocode for this instruction. ",
    "MVN <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.208",
    "MVNI",
    "mvni",
    "Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}\nMVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}\nMVNI <Vd>.<T>, #<imm8>, MSL #<amount>"
  ],
  [
    "C7.2.209",
    "NEG (vector)",
    "neg",
    "Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "NEG <V><d>, <V><n>"
  ],
  [
    "C7.2.210",
    "NOT",
    "not",
    "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MVN. The alias is always the preferred disassembly. ",
    "NOT <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.211",
    "ORN (vector)",
    "orn",
    "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ORN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.212",
    "ORR (vector, immediate)",
    "orr",
    "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}\nORR <Vd>.<T>, #<imm8>{, LSL #<amount>}"
  ],
  [
    "C7.2.213",
    "ORR (vector, register)",
    "orr",
    "Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP registers, and writes the result to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MOV (vector). See Alias conditions for details of when each alias is preferred. ",
    "ORR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.214",
    "PMUL",
    "pmul",
    "Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. For information about multiplying polynomials see Polynomial arithmetic over {0, 1} on page A1-50. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "PMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.215",
    "PMULL, PMULL2",
    "pmull,",
    "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. For information about multiplying polynomials see Polynomial arithmetic over {0, 1} on page A1-50. The PMULL instruction extracts each source vector from the lower half of each source register, while the PMULL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.216",
    "RADDHN, RADDHN2",
    "raddhn,",
    "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the corresponding vector element in the second source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The results are rounded. For truncated results, see ADDHN, ADDHN2. The RADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.217",
    "RAX1",
    "rax1",
    "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a source SIMD&FP register left by 1, performs a bitwise exclusive OR of the resulting 128-bit vector and the vector in another source SIMD&FP register, and writes the result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA3 is implemented.  ARMv8.2",
    "RAX1 <Vd>.2D, <Vn>.2D, <Vm>.2D"
  ],
  [
    "C7.2.218",
    "RBIT (vector)",
    "rbit",
    "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "RBIT <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.219",
    "REV16 (vector)",
    "rev16",
    "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "REV16 <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.220",
    "REV32 (vector)",
    "rev32",
    "Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "REV32 <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.221",
    "REV64",
    "rev64",
    "Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "REV64 <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.222",
    "RSHRN, RSHRN2",
    "rshrn,",
    "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN, SHRN2. The RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.223",
    "RSUBHN, RSUBHN2",
    "rsubhn,",
    "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The results are rounded. For truncated results, see SUBHN, SUBHN2. The RSUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.224",
    "SABA",
    "saba",
    "Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.225",
    "SABAL, SABAL2",
    "sabal,",
    "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. The SABAL instruction extracts each source vector from the lower half of each source register, while the SABAL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.226",
    "SABD",
    "sabd",
    "Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.227",
    "SABDL, SABDL2",
    "sabdl,",
    "Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. The SABDL instruction writes the vector to the lower half of the destination register and clears the upper half, while the SABDL2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.228",
    "SADALP",
    "sadalp",
    "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SADALP <Vd>.<Ta>, <Vn>.<Tb>"
  ],
  [
    "C7.2.229",
    "SADDL, SADDL2",
    "saddl,",
    "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values. The SADDL instruction extracts each source vector from the lower half of each source register, while the SADDL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.230",
    "SADDLP",
    "saddlp",
    "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SADDLP <Vd>.<Ta>, <Vn>.<Tb>"
  ],
  [
    "C7.2.231",
    "SADDLV",
    "saddlv",
    "Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SADDLV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.232",
    "SADDW, SADDW2",
    "saddw,",
    "Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector, and writes the vector to the SIMD&FP destination register. The SADDW instruction extracts the second source vector from the lower half of the second source register, while the SADDW2 instruction extracts the second source vector from the upper half of the second source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.233",
    "SCVTF (vector, fixed-point)",
    "scvtf",
    "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar",
    "SCVTF <V><d>, <V><n>, #<fbits>"
  ],
  [
    "C7.2.234",
    "SCVTF (vector, integer)",
    "scvtf",
    "Signed integer Convert to Floating-point (vector). This instruction converts each element in a vector from signed integer to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "SCVTF <Hd>, <Hn>"
  ],
  [
    "C7.2.235",
    "SCVTF (scalar, fixed-point)",
    "scvtf",
    "Signed fixed-point Convert to Floating-point (scalar). This instruction converts the signed value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped. ",
    "SCVTF <Hd>, <Wn>, #<fbits>\nSCVTF <Sd>, <Wn>, #<fbits>\nSCVTF <Dd>, <Wn>, #<fbits>\nSCVTF <Hd>, <Xn>, #<fbits>\nSCVTF <Sd>, <Xn>, #<fbits>\nSCVTF <Dd>, <Xn>, #<fbits>"
  ],
  [
    "C7.2.236",
    "SCVTF (scalar, integer)",
    "scvtf",
    "Signed integer Convert to Floating-point (scalar). This instruction converts the signed integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SCVTF <Hd>, <Wn>\nSCVTF <Sd>, <Wn>\nSCVTF <Dd>, <Wn>\nSCVTF <Hd>, <Xn>\nSCVTF <Sd>, <Xn>\nSCVTF <Dd>, <Xn>"
  ],
  [
    "C7.2.237",
    "SDOT (by element)",
    "sdot",
    "Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.  ARMv8.2",
    "SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
  ],
  [
    "C7.2.238",
    "SDOT (vector)",
    "sdot",
    "Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.  ARMv8.2",
    "SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
  ],
  [
    "C7.2.239",
    "SHA1C",
    "sha1c",
    "SHA1 hash update (choose). ",
    "SHA1C <Qd>, <Sn>, <Vm>.4S"
  ],
  [
    "C7.2.240",
    "SHA1H",
    "sha1h",
    "SHA1 fixed rotate. ",
    "SHA1H <Sd>, <Sn>"
  ],
  [
    "C7.2.241",
    "SHA1M",
    "sha1m",
    "SHA1 hash update (majority). ",
    "SHA1M <Qd>, <Sn>, <Vm>.4S"
  ],
  [
    "C7.2.242",
    "SHA1P",
    "sha1p",
    "SHA1 hash update (parity). ",
    "SHA1P <Qd>, <Sn>, <Vm>.4S"
  ],
  [
    "C7.2.243",
    "SHA1SU0",
    "sha1su0",
    "SHA1 schedule update 0. ",
    "SHA1SU0 <Vd>.4S, <Vn>.4S, <Vm>.4S"
  ],
  [
    "C7.2.244",
    "SHA1SU1",
    "sha1su1",
    "SHA1 schedule update 1. ",
    "SHA1SU1 <Vd>.4S, <Vn>.4S"
  ],
  [
    "C7.2.245",
    "SHA256H2",
    "sha256h2",
    "SHA256 hash update (part 2). ",
    "SHA256H2 <Qd>, <Qn>, <Vm>.4S"
  ],
  [
    "C7.2.246",
    "SHA256H",
    "sha256h",
    "SHA256 hash update (part 1). ",
    "SHA256H <Qd>, <Qn>, <Vm>.4S"
  ],
  [
    "C7.2.247",
    "SHA256SU0",
    "sha256su0",
    "SHA256 schedule update 0. ",
    "SHA256SU0 <Vd>.4S, <Vn>.4S"
  ],
  [
    "C7.2.248",
    "SHA256SU1",
    "sha256su1",
    "SHA256 schedule update 1. ",
    "SHA256SU1 <Vd>.4S, <Vn>.4S, <Vm>.4S"
  ],
  [
    "C7.2.249",
    "SHA512H",
    "sha512h",
    "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA512 is implemented.  ARMv8.2",
    "SHA512H <Qd>, <Qn>, <Vm>.2D"
  ],
  [
    "C7.2.250",
    "SHA512H2",
    "sha512h2",
    "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA512 is implemented.  ARMv8.2",
    "SHA512H2 <Qd>, <Qn>, <Vm>.2D"
  ],
  [
    "C7.2.251",
    "SHA512SU0",
    "sha512su0",
    "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA512 is implemented.  ARMv8.2",
    "SHA512SU0 <Vd>.2D, <Vn>.2D"
  ],
  [
    "C7.2.252",
    "SHA512SU1",
    "sha512su1",
    "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA512 is implemented.  ARMv8.2",
    "SHA512SU1 <Vd>.2D, <Vn>.2D, <Vm>.2D"
  ],
  [
    "C7.2.253",
    "SHADD",
    "shadd",
    "Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SRHADD. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.254",
    "SHL",
    "shl",
    "Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SHL <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.255",
    "SHLL, SHLL2",
    "shll,",
    "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. The SHLL instruction extracts vector elements from the lower half of the source register, while the SHLL2 instruction extracts vector elements from the upper half of the source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.256",
    "SHRN, SHRN2",
    "shrn,",
    "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN, RSHRN2. The RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.257",
    "SHSUB",
    "shsub",
    "Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.258",
    "SLI",
    "sli",
    "Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost. The following figure shows the operation of shift left by 3 for an 8-bit vector element. 63  56 55  0  63  56 55  0  63  56 55  0  Vn.B[7]  Vd.B[7] after operation  Vd.B[7] before operation Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SLI <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.259",
    "SM3PARTW1",
    "sm3partw1",
    "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3PARTW1 <Vd>.4S, <Vn>.4S, <Vm>.4S"
  ],
  [
    "C7.2.260",
    "SM3PARTW2",
    "sm3partw2",
    "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and returns a 128-bit result in the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3PARTW2 <Vd>.4S, <Vn>.4S, <Vm>.4S"
  ],
  [
    "C7.2.261",
    "SM3SS1",
    "sm3ss1",
    "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&FP register, with the bottom 96 bits of the vector being written to 0. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3SS1 <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"
  ],
  [
    "C7.2.262",
    "SM3TT1A",
    "sm3tt1a",
    "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values: \n  -  The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive OR.  \n  -  The result of the exclusive OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.  \n  -  A 32-bit element indexed out of the third source vector, Vm.  The result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3TT1A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
  ],
  [
    "C7.2.263",
    "SM3TT1B",
    "sm3tt1b",
    "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values: \n  -  The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.  \n  -  The result of the exclusive OR of the top 32-bit element of the second source vector, Vn, with a rotation left by 12 of the top 32-bit element of the first source vector.  \n  -  A 32-bit element indexed out of the third source vector, Vm.  The result of this addition is returned as the top element of the result. The other elements of the result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3TT1B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
  ],
  [
    "C7.2.264",
    "SM3TT2A",
    "sm3tt2a",
    "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values: \n  -  The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive OR.  \n  -  The 32-bit element held in the top 32 bits of the second source vector, Vn.  \n  -  A 32-bit element indexed out of the third source vector, Vm.  A three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 19. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3TT2A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
  ],
  [
    "C7.2.265",
    "SM3TT2B",
    "sm3tt2b",
    "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values: \n  -  The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.  \n  -  The 32-bit element held in the top 32 bits of the second source vector, Vn.  \n  -  A 32-bit element indexed out of the third source vector, Vm.  A three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the returned result. The other elements of this result are taken from elements of the first source vector, with the element returned in bits<63:32> being rotated left by 19. This instruction is implemented only when FEAT_SM3 is implemented.  ARMv8.2",
    "SM3TT2B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
  ],
  [
    "C7.2.266",
    "SM4E",
    "sm4e",
    "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SM4 is implemented.  ARMv8.2",
    "SM4E <Vd>.4S, <Vn>.4S"
  ],
  [
    "C7.2.267",
    "SM4EKEY",
    "sm4ekey",
    "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP register and a 128-bit constant from the second SIMD&FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SM4 is implemented.  ARMv8.2",
    "SM4EKEY <Vd>.4S, <Vn>.4S, <Vm>.4S"
  ],
  [
    "C7.2.268",
    "SMAX",
    "smax",
    "Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.269",
    "SMAXP",
    "smaxp",
    "Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.270",
    "SMAXV",
    "smaxv",
    "Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMAXV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.271",
    "SMIN",
    "smin",
    "Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.272",
    "SMINP",
    "sminp",
    "Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.273",
    "SMINV",
    "sminv",
    "Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are signed integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMINV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.274",
    "SMLAL, SMLAL2 (by element)",
    "smlal,",
    "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element in the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values. The SMLAL instruction extracts vector elements from the lower half of the first source register, while the SMLAL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.275",
    "SMLAL, SMLAL2 (vector)",
    "smlal,",
    "Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The SMLAL instruction extracts each source vector from the lower half of each source register, while the SMLAL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.276",
    "SMLSL, SMLSL2 (by element)",
    "smlsl,",
    "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The SMLSL instruction extracts vector elements from the lower half of the first source register, while the SMLSL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.277",
    "SMLSL, SMLSL2 (vector)",
    "smlsl,",
    "Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The SMLSL instruction extracts each source vector from the lower half of each source register, while the SMLSL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.278",
    "SMMLA (vector)",
    "smmla",
    "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "SMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B"
  ],
  [
    "C7.2.279",
    "SMOV",
    "smov",
    "Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source SIMD&FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SMOV <Wd>, <Vn>.<Ts>[<index>]\nSMOV <Xd>, <Vn>.<Ts>[<index>]"
  ],
  [
    "C7.2.280",
    "SMULL, SMULL2 (by element)",
    "smull,",
    "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The SMULL instruction extracts vector elements from the lower half of the first source register, while the SMULL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.281",
    "SMULL, SMULL2 (vector)",
    "smull,",
    "Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The SMULL instruction extracts each source vector from the lower half of each source register, while the SMULL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.282",
    "SQABS",
    "sqabs",
    "Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQABS <V><d>, <V><n>"
  ],
  [
    "C7.2.283",
    "SQADD",
    "sqadd",
    "Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQADD <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.284",
    "SQDMLAL, SQDMLAL2 (by element)",
    "sqdmlal,",
    "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMLAL instruction extracts vector elements from the lower half of the first source register, while the SQDMLAL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.285",
    "SQDMLAL, SQDMLAL2 (vector)",
    "sqdmlal,",
    "Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMLAL instruction extracts each source vector from the lower half of each source register, while the SQDMLAL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.286",
    "SQDMLSL, SQDMLSL2 (by element)",
    "sqdmlsl,",
    "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMLSL instruction extracts vector elements from the lower half of the first source register, while the SQDMLSL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.287",
    "SQDMLSL, SQDMLSL2 (vector)",
    "sqdmlsl,",
    "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMLSL instruction extracts each source vector from the lower half of each source register, while the SQDMLSL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.288",
    "SQDMULH (by element)",
    "sqdmulh",
    "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SQRDMULH (by element). Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.289",
    "SQDMULH (vector)",
    "sqdmulh",
    "Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SQRDMULH (vector). If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQDMULH <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.290",
    "SQDMULL, SQDMULL2 (by element)",
    "sqdmull,",
    "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMULL instruction extracts the first source vector from the lower half of the first source register, while the SQDMULL2 instruction extracts the first source vector from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.291",
    "SQDMULL, SQDMULL2 (vector)",
    "sqdmull,",
    "Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQDMULL instruction extracts each source vector from the lower half of each source register, while the SQDMULL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.292",
    "SQNEG",
    "sqneg",
    "Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQNEG <V><d>, <V><n>"
  ],
  [
    "C7.2.293",
    "SQRDMLAH (by element)",
    "sqrdmlah",
    "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded. If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar ARMv8.1",
    "SQRDMLAH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.294",
    "SQRDMLAH (vector)",
    "sqrdmlah",
    "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&FP register. The results are rounded. If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar ARMv8.1",
    "SQRDMLAH <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.295",
    "SQRDMLSH (by element)",
    "sqrdmlsh",
    "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded. If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar ARMv8.1",
    "SQRDMLSH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.296",
    "SQRDMLSH (vector)",
    "sqrdmlsh",
    "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&FP register. The results are rounded. If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar ARMv8.1",
    "SQRDMLSH <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.297",
    "SQRDMULH (by element)",
    "sqrdmulh",
    "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQDMULH (by element). If any of the results overflows, they are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQRDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
  ],
  [
    "C7.2.298",
    "SQRDMULH (vector)",
    "sqrdmulh",
    "Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQDMULH (vector). If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQRDMULH <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.299",
    "SQRSHL",
    "sqrshl",
    "Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see SQSHL (register). If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQRSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.300",
    "SQRSHRN, SQRSHRN2",
    "sqrshrn,",
    "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN, SQSHRN2. The SQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.301",
    "SQRSHRUN, SQRSHRUN2",
    "sqrshrun,",
    "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN, SQSHRUN2. The SQRSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQRSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.302",
    "SQSHL (immediate)",
    "sqshl",
    "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQSHL <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.303",
    "SQSHL (register)",
    "sqshl",
    "Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see SQRSHL. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.304",
    "SQSHLU",
    "sqshlu",
    "Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQSHLU <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.305",
    "SQSHRN, SQSHRN2",
    "sqshrn,",
    "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN, SQRSHRN2. The SQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.306",
    "SQSHRUN, SQSHRUN2",
    "sqshrun,",
    "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see SQRSHRUN, SQRSHRUN2. The SQSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.307",
    "SQSUB",
    "sqsub",
    "Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SQSUB <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.308",
    "SQXTN, SQXTN2",
    "sqxtn,",
    "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.309",
    "SQXTUN, SQXTUN2",
    "sqxtun,",
    "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The SQXTUN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SQXTUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.310",
    "SRHADD",
    "srhadd",
    "Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SHADD. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "SRHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.311",
    "SRI",
    "sri",
    "Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost. The following figure shows the operation of shift right by 3 for an 8-bit vector element. 63  56 55  0  63  56 55  0  63  56 55  0  Vn.B[7]  Vd.B[7] after operation  Vd.B[7] before operation Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SRI <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.312",
    "SRSHL",
    "srshl",
    "Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For a truncating shift, see SSHL. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SRSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.313",
    "SRSHR",
    "srshr",
    "Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSHR. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SRSHR <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.314",
    "SRSRA",
    "srsra",
    "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSRA. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SRSRA <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.315",
    "SSHL",
    "sshl",
    "Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see SRSHL. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.316",
    "SSHLL, SSHLL2",
    "sshll,",
    "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values. The SSHLL instruction extracts vector elements from the lower half of the source register, while the SSHLL2 instruction extracts vector elements from the upper half of the source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias SXTL, SXTL2. See Alias conditions for details of when each alias is preferred. ",
    ""
  ],
  [
    "C7.2.317",
    "SSHR",
    "sshr",
    "Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSHR. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SSHR <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.318",
    "SSRA",
    "ssra",
    "Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSRA. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SSRA <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.319",
    "SSUBL, SSUBL2",
    "ssubl,",
    "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements. The SSUBL instruction extracts each source vector from the lower half of each source register, while the SSUBL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.320",
    "SSUBW, SSUBW2",
    "ssubw,",
    "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values. The SSUBW instruction extracts the second source vector from the lower half of the second source register, while the SSUBW2 instruction extracts the second source vector from the upper half of the second source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.321",
    "ST1 (multiple structures)",
    "st1",
    "Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to memory from one, two, three, or four SIMD&FP registers, without interleaving. Every element of each register is stored. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST1 { <Vt>.<T> }, [<Xn|SP>]\nST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]\nST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]\nST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.322",
    "ST1 (single structure)",
    "st1",
    "Store a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&FP register to memory. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST1 { <Vt>.B }[<index>], [<Xn|SP>]\nST1 { <Vt>.H }[<index>], [<Xn|SP>]\nST1 { <Vt>.S }[<index>], [<Xn|SP>]\nST1 { <Vt>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.323",
    "ST2 (multiple structures)",
    "st2",
    "Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from two SIMD&FP registers to memory, with interleaving. Every element of each register is stored. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.324",
    "ST2 (single structure)",
    "st2",
    "Store single 2-element structure from one lane of two registers. This instruction stores a 2-element structure to memory from corresponding elements of two SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]\nST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]\nST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]\nST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.325",
    "ST3 (multiple structures)",
    "st3",
    "Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to memory from three SIMD&FP registers, with interleaving. Every element of each register is stored. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.326",
    "ST3 (single structure)",
    "st3",
    "Store single 3-element structure from one lane of three registers. This instruction stores a 3-element structure to memory from corresponding elements of three SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]\nST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]\nST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]\nST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.327",
    "ST4 (multiple structures)",
    "st4",
    "Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to memory from four SIMD&FP registers, with interleaving. Every element of each register is stored. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
  ],
  [
    "C7.2.328",
    "ST4 (single structure)",
    "st4",
    "Store single 4-element structure from one lane of four registers. This instruction stores a 4-element structure to memory from corresponding elements of four SIMD&FP registers. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  No offset",
    "ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]\nST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]\nST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]\nST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
  ],
  [
    "C7.2.329",
    "STNP (SIMD&FP)",
    "stnp",
    "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair on page C3-216. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "STNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]\nSTNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]\nSTNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
  ],
  [
    "C7.2.330",
    "STP (SIMD&FP)",
    "stp",
    "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Post-index",
    "STP <St1>, <St2>, [<Xn|SP>], #<imm>\nSTP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>\nSTP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
  ],
  [
    "C7.2.331",
    "STR (immediate, SIMD&FP)",
    "str",
    "Store SIMD&FP register (immediate offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Post-index",
    "STR <Bt>, [<Xn|SP>], #<simm>\nSTR <Ht>, [<Xn|SP>], #<simm>\nSTR <St>, [<Xn|SP>], #<simm>\nSTR <Dt>, [<Xn|SP>], #<simm>\nSTR <Qt>, [<Xn|SP>], #<simm>"
  ],
  [
    "C7.2.332",
    "STR (register, SIMD&FP)",
    "str",
    "Store SIMD&FP register (register offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an offset register value. The offset can be optionally shifted and extended. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "STR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]\nSTR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]\nSTR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nSTR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nSTR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]\nSTR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
  ],
  [
    "C7.2.333",
    "STUR (SIMD&FP)",
    "stur",
    "Store SIMD&FP register (unscaled offset). This instruction stores a single SIMD&FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "STUR <Bt>, [<Xn|SP>{, #<simm>}]\nSTUR <Ht>, [<Xn|SP>{, #<simm>}]\nSTUR <St>, [<Xn|SP>{, #<simm>}]\nSTUR <Dt>, [<Xn|SP>{, #<simm>}]\nSTUR <Qt>, [<Xn|SP>{, #<simm>}]"
  ],
  [
    "C7.2.334",
    "SUB (vector)",
    "sub",
    "Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SUB <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.335",
    "SUBHN, SUBHN2",
    "subhn,",
    "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see RSUBHN, RSUBHN2. The SUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while the SUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.336",
    "SUDOT (by element)",
    "sudot",
    "Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "SUDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
  ],
  [
    "C7.2.337",
    "SUQADD",
    "suqadd",
    "Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "SUQADD <V><d>, <V><n>"
  ],
  [
    "C7.2.338",
    "SXTL, SXTL2",
    "sxtl,",
    "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values. The SXTL instruction extracts the source vector from the lower half of the source register, while the SXTL2 instruction extracts the source vector from the upper half of the source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the SSHLL, SSHLL2 instruction. This means that: \n  -  The encodings in this description are named to match the encodings of SSHLL, SSHLL2.  \n  -  The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction. ",
    ""
  ],
  [
    "C7.2.339",
    "TBL",
    "tbl",
    "Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\nTBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\nTBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\nTBL <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
  ],
  [
    "C7.2.340",
    "TBX",
    "tbx",
    "Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>\nTBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>\nTBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>\nTBX <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
  ],
  [
    "C7.2.341",
    "TRN1",
    "trn1",
    "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.  Note By using this instruction with TRN2, a 2 x 2 matrix can be transposed. The following figure shows the operation of TRN1 and TRN2 halfword operations where Q = 0. TRN1.16  TRN2.16  Vn  Vn  3  2  1  0  3  Vd  Vd  Vm  Vm  2  1  0  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "TRN1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.342",
    "TRN2",
    "trn2",
    "Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector.  Note By using this instruction with TRN1, a 2 x 2 matrix can be transposed. The following figure shows the operation of TRN1 and TRN2 halfword operations where Q = 0. TRN1.16  TRN2.16  Vn  Vn  3  2  1  0  3  Vd  Vd  Vm  Vm  2  1  0  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "TRN2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.343",
    "UABA",
    "uaba",
    "Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.344",
    "UABAL, UABAL2",
    "uabal,",
    "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values. The UABAL instruction extracts each source vector from the lower half of each source register, while the UABAL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.345",
    "UABD",
    "uabd",
    "Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the results into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.346",
    "UABDL, UABDL2",
    "uabdl,",
    "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values. The UABDL instruction extracts each source vector from the lower half of each source register, while the UABDL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.347",
    "UADALP",
    "uadalp",
    "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UADALP <Vd>.<Ta>, <Vn>.<Tb>"
  ],
  [
    "C7.2.348",
    "UADDL, UADDL2",
    "uaddl,",
    "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values. The UADDL instruction extracts each source vector from the lower half of each source register, while the UADDL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.349",
    "UADDLP",
    "uaddlp",
    "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UADDLP <Vd>.<Ta>, <Vn>.<Tb>"
  ],
  [
    "C7.2.350",
    "UADDLV",
    "uaddlv",
    "Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UADDLV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.351",
    "UADDW, UADDW2",
    "uaddw,",
    "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values. The UADDW instruction extracts vector elements from the lower half of the second source register, while the UADDW2 instruction extracts vector elements from the upper half of the second source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.352",
    "UCVTF (vector, fixed-point)",
    "ucvtf",
    "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar",
    "UCVTF <V><d>, <V><n>, #<fbits>"
  ],
  [
    "C7.2.353",
    "UCVTF (vector, integer)",
    "ucvtf",
    "Unsigned integer Convert to Floating-point (vector). This instruction converts each element in a vector from an unsigned integer value to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.  Scalar half precision ARMv8.2",
    "UCVTF <Hd>, <Hn>"
  ],
  [
    "C7.2.354",
    "UCVTF (scalar, fixed-point)",
    "ucvtf",
    "Unsigned fixed-point Convert to Floating-point (scalar). This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped. ",
    "UCVTF <Hd>, <Wn>, #<fbits>\nUCVTF <Sd>, <Wn>, #<fbits>\nUCVTF <Dd>, <Wn>, #<fbits>\nUCVTF <Hd>, <Xn>, #<fbits>\nUCVTF <Sd>, <Xn>, #<fbits>\nUCVTF <Dd>, <Xn>, #<fbits>"
  ],
  [
    "C7.2.355",
    "UCVTF (scalar, integer)",
    "ucvtf",
    "Unsigned integer Convert to Floating-point (scalar). This instruction converts the unsigned integer value in the general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&FP destination register. A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see Floating-point exceptions and exception traps on page D1-2354. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UCVTF <Hd>, <Wn>\nUCVTF <Sd>, <Wn>\nUCVTF <Dd>, <Wn>\nUCVTF <Hd>, <Xn>\nUCVTF <Sd>, <Xn>\nUCVTF <Dd>, <Xn>"
  ],
  [
    "C7.2.356",
    "UDOT (by element)",
    "udot",
    "Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.  ARMv8.2",
    "UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
  ],
  [
    "C7.2.357",
    "UDOT (vector)",
    "udot",
    "Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations to support it.  Note ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.  ARMv8.2",
    "UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
  ],
  [
    "C7.2.358",
    "UHADD",
    "uhadd",
    "Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see URHADD. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.359",
    "UHSUB",
    "uhsub",
    "Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.360",
    "UMAX",
    "umax",
    "Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.361",
    "UMAXP",
    "umaxp",
    "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.362",
    "UMAXV",
    "umaxv",
    "Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMAXV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.363",
    "UMIN",
    "umin",
    "Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.364",
    "UMINP",
    "uminp",
    "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.365",
    "UMINV",
    "uminv",
    "Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UMINV <V><d>, <Vn>.<T>"
  ],
  [
    "C7.2.366",
    "UMLAL, UMLAL2 (by element)",
    "umlal,",
    "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.367",
    "UMLAL, UMLAL2 (vector)",
    "umlal,",
    "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.368",
    "UMLSL, UMLSL2 (by element)",
    "umlsl,",
    "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The UMLSL instruction extracts vector elements from the lower half of the first source register, while the UMLSL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.369",
    "UMLSL, UMLSL2 (vector)",
    "umlsl,",
    "Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values. The UMLSL instruction extracts each source vector from the lower half of each source register, while the UMLSL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.370",
    "UMMLA (vector)",
    "ummla",
    "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "UMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B"
  ],
  [
    "C7.2.371",
    "UMOV",
    "umov",
    "Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias MOV (to general). See Alias conditions for details of when each alias is preferred. ",
    "UMOV <Wd>, <Vn>.<Ts>[<index>]\nUMOV <Xd>, <Vn>.<Ts>[<index>]"
  ],
  [
    "C7.2.372",
    "UMULL, UMULL2 (by element)",
    "umull,",
    "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. The UMULL instruction extracts vector elements from the lower half of the first source register, while the UMULL2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.373",
    "UMULL, UMULL2 (vector)",
    "umull,",
    "Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are unsigned integer values. The UMULL instruction extracts each source vector from the lower half of each source register, while the UMULL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.374",
    "UQADD",
    "uqadd",
    "Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP registers, places the results into a vector, and writes the vector to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "UQADD <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.375",
    "UQRSHL",
    "uqrshl",
    "Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For truncated results, see UQSHL (immediate). If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "UQRSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.376",
    "UQRSHRN, UQRSHRN2",
    "uqrshrn,",
    "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN, UQSHRN2. The UQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.377",
    "UQSHL (immediate)",
    "uqshl",
    "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "UQSHL <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.378",
    "UQSHL (register)",
    "uqshl",
    "Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For rounded results, see UQRSHL. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "UQSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.379",
    "UQSHRN, UQSHRN2",
    "uqshrn,",
    "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN, UQRSHRN2. The UQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.380",
    "UQSUB",
    "uqsub",
    "Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "UQSUB <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.381",
    "UQXTN, UQXTN2",
    "uqxtn,",
    "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. If saturation occurs, the cumulative saturation bit FPSR.QC is set. The UQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the UQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    ""
  ],
  [
    "C7.2.382",
    "URECPE",
    "urecpe",
    "Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&FP register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "URECPE <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.383",
    "URHADD",
    "urhadd",
    "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&FP register. The results are rounded. For truncated results, see UHADD. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "URHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.384",
    "URSHL",
    "urshl",
    "Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "URSHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.385",
    "URSHR",
    "urshr",
    "Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USHR. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "URSHR <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.386",
    "URSQRTE",
    "ursqrte",
    "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "URSQRTE <Vd>.<T>, <Vn>.<T>"
  ],
  [
    "C7.2.387",
    "URSRA",
    "ursra",
    "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USRA. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "URSRA <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.388",
    "USDOT (vector)",
    "usdot",
    "Dot Product vector form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in the corresponding 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
  ],
  [
    "C7.2.389",
    "USDOT (by element)",
    "usdot",
    "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
  ],
  [
    "C7.2.390",
    "USHL",
    "ushl",
    "Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register. If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For a rounding shift, see URSHL. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "USHL <V><d>, <V><n>, <V><m>"
  ],
  [
    "C7.2.391",
    "USHLL, USHLL2",
    "ushll,",
    "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. The USHLL instruction extracts vector elements from the lower half of the source register, while the USHLL2 instruction extracts vector elements from the upper half of the source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is used by the alias UXTL, UXTL2. See Alias conditions for details of when each alias is preferred. ",
    ""
  ],
  [
    "C7.2.392",
    "USHR",
    "ushr",
    "Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSHR. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "USHR <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.393",
    "USMMLA (vector)",
    "usmmla",
    "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element. From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.  ARMv8.6",
    "USMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B"
  ],
  [
    "C7.2.394",
    "USQADD",
    "usqadd",
    "Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&FP register. If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "USQADD <V><d>, <V><n>"
  ],
  [
    "C7.2.395",
    "USRA",
    "usra",
    "Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSRA. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.  Scalar",
    "USRA <V><d>, <V><n>, #<shift>"
  ],
  [
    "C7.2.396",
    "USUBL, USUBL2",
    "usubl,",
    "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements. The USUBL instruction extracts each source vector from the lower half of each source register, while the USUBL2 instruction extracts each source vector from the upper half of each source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.397",
    "USUBW, USUBW2",
    "usubw,",
    "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed integer values. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. The USUBW instruction extracts vector elements from the lower half of the first source register, while the USUBW2 instruction extracts vector elements from the upper half of the first source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.398",
    "UXTL, UXTL2",
    "uxtl,",
    "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements. The UXTL instruction extracts vector elements from the lower half of the source register, while the UXTL2 instruction extracts vector elements from the upper half of the source register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. This instruction is an alias of the USHLL, USHLL2 instruction. This means that: \n  -  The encodings in this description are named to match the encodings of USHLL, USHLL2.  \n  -  The description of USHLL, USHLL2 gives the operational pseudocode for this instruction. ",
    ""
  ],
  [
    "C7.2.399",
    "UZP1",
    "uzp1",
    "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.  Note This instruction can be used with UZP2 to de-interleave two vectors. The following figure shows the operation of UZP1 and UZP2 with the arrangement specifier 8B. Vn Vm  A7 B7  A6 B6  A5 B5  A4 B4  A3 B3  A2 B2  UZP1.8, doubleword Vd  B6  B4  B2  B0  A6  A4  A1 B1  A0 B0  UZP2.8, doubleword A2  A0  Vd  B7  B5  B3  B1  A7  A5  A3  A1  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UZP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.400",
    "UZP2",
    "uzp2",
    "Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&FP register.  Note This instruction can be used with UZP1 to de-interleave two vectors. The following figure shows the operation of UZP1 and UZP2 with the arrangement specifier 8B. Vn Vm  A7 B7  A6 B6  A5 B5  A4 B4  A3 B3  A2 B2  UZP1.8, doubleword Vd  B6  B4  B2  B0  A6  A4  A1 B1  A0 B0  UZP2.8, doubleword A2  A0  Vd  B7  B5  B3  B1  A7  A5  A3  A1  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "UZP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.401",
    "XAR",
    "xar",
    "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors in the two source SIMD&FP registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate value, and writes the result to the destination SIMD&FP register. This instruction is implemented only when FEAT_SHA3 is implemented.  ARMv8.2",
    "XAR <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"
  ],
  [
    "C7.2.402",
    "XTN, XTN2",
    "xtn,",
    "Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source vector elements. The XTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the XTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the register. Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    ""
  ],
  [
    "C7.2.403",
    "ZIP1",
    "zip1",
    "Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.  Note This instruction can be used with ZIP2 to interleave two vectors. The following figure shows the operation of ZIP1 and ZIP2 with the arrangement specifier 8B. Vn Vm  A7 B7  A6 B6  A5 B5  A4 B4  A3 B3  A2 B2  ZIP1.8, doubleword Vd  B3  A3  B2  A2  B1  A1 B1  A0 B0  ZIP2.8, doubleword A1  B0  Vd  A0  B7  A7  B6  A6  B5  A5  B4  A4  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ZIP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "C7.2.404",
    "ZIP2",
    "zip2",
    "Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register.  Note This instruction can be used with ZIP1 to interleave two vectors. The following figure shows the operation of ZIP1 and ZIP2 with the arrangement specifier 8B. Vn Vm  A7 B7  A6 B6  A5 B5  A4 B4  A3 B3  A2 B2  ZIP1.8, doubleword Vd  B3  A3  B2  A2  B1  A1 B1  A0 B0  ZIP2.8, doubleword A1  B0  Vd  A0  B7  A7  B6  A6  B5  A5  B4  A4  Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped. ",
    "ZIP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
  ],
  [
    "",
    "Reference",
    "reference",
    "Arm Architecture Reference Manual Armv8, for Armv8-A architecture profile\nhttps://developer.arm.com/documentation/ddi0487/latest/\n2021-01-01",
    ""
  ]
]