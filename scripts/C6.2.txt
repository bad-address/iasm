A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.1

ADC
Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADC <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
ADC <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
(result, -) = AddWithCarry(operand1, operand2, PSTATE.C);
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C6-772

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-773

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.2

ADCS
Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the
destination register. It updates the condition flags based on the result.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADCS <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
ADCS <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(4) nzcv;
(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

C6-774

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-775

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.3

ADD (extended register)
Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left
shift amount, and writes the result to the destination register. The argument that is extended from the <Rm> register
can be a byte, halfword, word, or doubleword.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADD <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

64-bit variant
Applies when sf == 1.
ADD <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ExtendType extend_type = DecodeRegExtend(option);
integer shift = UInt(imm3);
if shift > 4 then UNDEFINED;

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

Is a width specifier, encoded in the "option" field. It can have the following values:

<m>

C6-776

W

when option = 00x

W

when option = 010

X

when option = x11

W

when option = 10x

W

when option = 110

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:

<extend>

UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rd" or "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted
when "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is
'010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rd" or "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
(result, -) = AddWithCarry(operand1, operand2, '0');
if d == 31 then
SP[] = result;
else
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

ARM DDI 0487F.c
ID072120

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-777

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

—

C6-778

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.4

ADD (immediate)
Add (immediate) adds a register value and an optionally-shifted immediate value, and writes the result to the
destination register.
This instruction is used by the alias MOV (to/from SP). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADD <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}

64-bit variant
Applies when sf == 1.
ADD <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
case sh of
when '0' imm = ZeroExtend(imm12, datasize);
when '1' imm = ZeroExtend(imm12:Zeros(12), datasize);

Alias conditions
Alias

is preferred when

MOV (to/from SP)

sh == '0' && imm12 == '000000000000' && (Rd == '11111' || Rn == '11111')

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

ARM DDI 0487F.c
ID072120

when sh = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-779

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

LSL #12

when sh = 1

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
(result, -) = AddWithCarry(operand1, imm, '0');
if d == 31 then
SP[] = result;
else
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-780

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.5

ADD (shifted register)
Add (shifted register) adds a register value and an optionally-shifted register value, and writes the result to the
destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADD <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
ADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if shift == '11' then UNDEFINED;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
<amount>

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-781

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
(result, -) = AddWithCarry(operand1, operand2, '0');
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-782

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.6

ADDG
Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the
Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags
specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21
1 0 0 1 0 0 0 1 1 0

16 15 14 13
uimm6

(0) (0)
op3

10 9
uimm4

5 4
Xn

0
Xd

Encoding
ADDG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer d = UInt(Xd);
integer n = UInt(Xn);
bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);

Assembler symbols
<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Xd"
field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Xn" field.

<uimm6>

Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the "uimm6" field.

<uimm4>

Is an unsigned immediate, in the range 0 to 15, encoded in the "uimm4" field.

Operation
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);
bits(16) exclude = GCR_EL1.Exclude;
bits(64) result;
bits(4) rtag;
if AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then
rtag = AArch64.ChooseNonExcludedTag(start_tag, uimm4, exclude);
else
rtag = '0000';
(result, -) = AddWithCarry(operand1, offset, '0');
result = AArch64.AddressWithAllocationTag(result, AccType_NORMAL, rtag);
if d == 31 then
SP[] = result;
else
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-783

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.7

ADDS (extended register)
Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by
an optional left shift amount, and writes the result to the destination register. The argument that is extended from
the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result.
This instruction is used by the alias CMN (extended register). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADDS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

64-bit variant
Applies when sf == 1.
ADDS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ExtendType extend_type = DecodeRegExtend(option);
integer shift = UInt(imm3);
if shift > 4 then UNDEFINED;

Alias conditions
Alias

is preferred when

CMN (extended register)

Rd == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

C6-784

Is a width specifier, encoded in the "option" field. It can have the following values:
W

when option = 00x

W

when option = 010

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

X

when option = x11

W

when option = 10x

W

when option = 110

<m>

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

<extend>

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
bits(4) nzcv;
(result, nzcv) = AddWithCarry(operand1, operand2, '0');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-785

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-786

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.8

ADDS (immediate)
Add (immediate), setting flags, adds a register value and an optionally-shifted immediate value, and writes the result
to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias CMN (immediate). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADDS <Wd>, <Wn|WSP>, #<imm>{, <shift>}

64-bit variant
Applies when sf == 1.
ADDS <Xd>, <Xn|SP>, #<imm>{, <shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
case sh of
when '0' imm = ZeroExtend(imm12, datasize);
when '1' imm = ZeroExtend(imm12:Zeros(12), datasize);

Alias conditions
Alias

is preferred when

CMN (immediate)

Rd == '11111'

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

when sh = 0

LSL #12

when sh = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-787

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(4) nzcv;
(result, nzcv) = AddWithCarry(operand1, imm, '0');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-788

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.9

ADDS (shifted register)
Add (shifted register), setting flags, adds a register value and an optionally-shifted register value, and writes the
result to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias CMN (shifted register). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ADDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
ADDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if shift == '11' then UNDEFINED;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

CMN (shifted register)

Rd == '11111'

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-789

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:

<shift>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
bits(4) nzcv;
(result, nzcv) = AddWithCarry(operand1, operand2, '0');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-790

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.10

ADR
Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the
result to the destination register.

31 30 29 28 27 26 25 24 23
0 immlo 1 0 0 0 0
op

5 4
immhi

0
Rd

Encoding
ADR <Xd>, <label>

Decode for this encoding
integer d = UInt(Rd);
bits(64) imm;
imm = SignExtend(immhi:immlo, 64);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<label>

Is the program label whose address is to be calculated. Its offset from the address of this instruction,
in the range +/-1MB, is encoded in "immhi:immlo".

Operation
bits(64) base = PC[];
X[d] = base + imm;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-791

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.11

ADRP
Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to
form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23
1 immlo 1 0 0 0 0
op

5 4
immhi

0
Rd

Encoding
ADRP <Xd>, <label>

Decode for this encoding
integer d = UInt(Rd);
bits(64) imm;
imm = SignExtend(immhi:immlo:Zeros(12), 64);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<label>

Is the program label whose 4KB page address is to be calculated. Its offset from the page address of
this instruction, in the range +/-4GB, is encoded as "immhi:immlo" times 4096.

Operation
bits(64) base = PC[];
base<11:0> = Zeros(12);
X[d] = base + imm;

C6-792

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.12

AND (immediate)
Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result
to the destination register.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
AND <Wd|WSP>, <Wn>, #<imm>

64-bit variant
Applies when sf == 1.
AND <Xd|SP>, <Xn>, #<imm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
if sf == '0' && N != '0' then UNDEFINED;
(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr".
For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr".

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
result = operand1 AND imm;
if d == 31 then
SP[] = result;
else
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-793

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-794

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.13

AND (shifted register)
Bitwise AND (shifted register) performs a bitwise AND of a register value and an optionally-shifted register value,
and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 0 1 0 1 0 shift 0
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
AND <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
AND <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-795

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
result = operand1 AND operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-796

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.14

ANDS (immediate)
Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and
writes the result to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias TST (immediate). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 1 1 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4

0

Rn

Rd

32-bit variant
Applies when sf == 0 && N == 0.
ANDS <Wd>, <Wn>, #<imm>

64-bit variant
Applies when sf == 1.
ANDS <Xd>, <Xn>, #<imm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
if sf == '0' && N != '0' then UNDEFINED;
(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

Alias conditions
Alias

is preferred when

TST (immediate)

Rd == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.
For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr".

<imm>

For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr".

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-797

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

result = operand1 AND imm;
PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-798

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.15

ANDS (shifted register)
Bitwise AND (shifted register), setting flags, performs a bitwise AND of a register value and an optionally-shifted
register value, and writes the result to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias TST (shifted register). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 0 shift 0
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ANDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
ANDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

TST (shifted register)

Rd == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:
LSL

ARM DDI 0487F.c
ID072120

when shift = 00

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-799

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
result = operand1 AND operand2;
PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-800

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.16

ASR (register)
Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its
sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source
register by the data size defines the number of bits by which the first source register is right-shifted.
This instruction is an alias of the ASRV instruction. This means that:
•

The encodings in this description are named to match the encodings of ASRV.

•

The description of ASRV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 0
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ASR <Wd>, <Wn>, <Wm>

is equivalent to
ASRV <Wd>, <Wn>, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
ASR <Xd>, <Xn>, <Xm>

is equivalent to
ASRV <Xd>, <Xn>, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
The description of ASRV gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-801

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-802

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.17

ASR (immediate)
Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies
of the sign bit in the upper bits and zeros in the lower bits, and writes the result to the destination register.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9

x 1 1 1 1 1
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0 && imms == 011111.
ASR <Wd>, <Wn>, #<shift>

is equivalent to
SBFM <Wd>, <Wn>, #<shift>, #31

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1 && N == 1 && imms == 111111.
ASR <Xd>, <Xn>, #<shift>

is equivalent to
SBFM <Xd>, <Xn>, #<shift>, #63

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<shift>

For the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the "immr" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the "immr" field.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-803

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-804

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.18

ASRV
Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign
bit, and writes the result to the destination register. The remainder obtained by dividing the second source register
by the data size defines the number of bits by which the first source register is right-shifted.
This instruction is used by the alias ASR (register). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 0
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ASRV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
ASRV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ShiftType shift_type = DecodeShift(op2);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand2 = X[m];
result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-805

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-806

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.19

AT
Address Translate. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address
translation instructions on page C5-377.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 1
L

16 15
op1

12 11

8 7

0 1 1 1 1 0 0 x
CRn
CRm

5 4
op2

0
Rt

Encoding
AT <at_op>, <Xt>

is equivalent to
SYS #<op1>, C7, <Cm>, #<op2>, <Xt>

and is the preferred disassembly when SysOp(op1,'0111',CRm,op2) == Sys_AT.

Assembler symbols
<at_op>

Is an AT instruction name, as listed for the AT system instruction group, encoded in the
"op1:CRm<0>:op2" field. It can have the following values:
S1E1R

when op1 = 000, CRm<0> = 0, op2 = 000

S1E1W

when op1 = 000, CRm<0> = 0, op2 = 001

S1E0R

when op1 = 000, CRm<0> = 0, op2 = 010

S1E0W

when op1 = 000, CRm<0> = 0, op2 = 011

S1E2R

when op1 = 100, CRm<0> = 0, op2 = 000

S1E2W

when op1 = 100, CRm<0> = 0, op2 = 001

S12E1R

when op1 = 100, CRm<0> = 0, op2 = 100

S12E1W

when op1 = 100, CRm<0> = 0, op2 = 101

S12E0R

when op1 = 100, CRm<0> = 0, op2 = 110

S12E0W

when op1 = 100, CRm<0> = 0, op2 = 111

S1E3R

when op1 = 110, CRm<0> = 0, op2 = 000

S1E3W

when op1 = 110, CRm<0> = 0, op2 = 001

When FEAT_PAN2 is implemented, the following values are also valid:

ARM DDI 0487F.c
ID072120

S1E1RP

when op1 = 000, CRm<0> = 1, op2 = 000

S1E1WP

when op1 = 000, CRm<0> = 1, op2 = 001

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<Xt>

Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-807

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of SYS gives the operational pseudocode for this instruction.

C6-808

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.20

AUTDA, AUTDZA
Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A.
The address is in the general-purpose register that is specified by <Xd>.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTDA.

•

The value zero, for AUTDZA.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the
authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 1 1 0

5 4
Rn

0
Rd

AUTDA variant
Applies when Z == 0.
AUTDA <Xd>, <Xn|SP>

AUTDZA variant
Applies when Z == 1 && Rn == 11111.
AUTDZA <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // AUTDA
if n == 31 then source_is_sp = TRUE;
else // AUTDZA
if n != 31 then UNDEFINED;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation
if HavePACExt() then
if source_is_sp then
X[d] = AuthDA(X[d], SP[], FALSE);
else
X[d] = AuthDA(X[d], X[n], FALSE);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-809

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.21

AUTDB, AUTDZB
Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B.
The address is in the general-purpose register that is specified by <Xd>.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTDB.

•

The value zero, for AUTDZB.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the
authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 1 1 1

5 4
Rn

0
Rd

AUTDB variant
Applies when Z == 0.
AUTDB <Xd>, <Xn|SP>

AUTDZB variant
Applies when Z == 1 && Rn == 11111.
AUTDZB <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // AUTDB
if n == 31 then source_is_sp = TRUE;
else // AUTDZB
if n != 31 then UNDEFINED;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation
if HavePACExt() then
if source_is_sp then
X[d] = AuthDB(X[d], SP[], FALSE);
else
X[d] = AuthDB(X[d], X[n], FALSE);

C6-810

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.22

AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA
Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier
and key A.
The address is:
•

In the general-purpose register that is specified by <Xd> for AUTIA and AUTIZA.

•

In X17, for AUTIA1716.

•

In X30, for AUTIASP and AUTIAZ.

The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTIA.

•

The value zero, for AUTIZA and AUTIAZ.

•

In X16, for AUTIA1716.

•

In SP, for AUTIASP.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the
authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.

Integer
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 1 0 0

5 4
Rn

0
Rd

AUTIA variant
Applies when Z == 0.
AUTIA <Xd>, <Xn|SP>

AUTIZA variant
Applies when Z == 1 && Rn == 11111.
AUTIZA <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // AUTIA
if n == 31 then source_is_sp = TRUE;
else // AUTIZA
if n != 31 then UNDEFINED;

System
ARMv8.3

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-811

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 x 1 1 0 x 1 1 1 1 1
CRm
op2

AUTIA1716 variant
Applies when CRm == 0001 && op2 == 100.
AUTIA1716

AUTIASP variant
Applies when CRm == 0011 && op2 == 101.
AUTIASP

AUTIAZ variant
Applies when CRm == 0011 && op2 == 100.
AUTIAZ

Decode for all variants of this encoding
integer d;
integer n;
boolean source_is_sp = FALSE;
case CRm:op2 of
when '0011 100'
// AUTIAZ
d = 30;
n = 31;
when '0011 101'
// AUTIASP
d = 30;
source_is_sp = TRUE;
when '0001 100'
// AUTIA1716
d = 17;
n = 16;
when '0001 000' SEE "PACIA";
when '0001 010' SEE "PACIB";
when '0001 110' SEE "AUTIB";
when '0011 00x' SEE "PACIA";
when '0011 01x' SEE "PACIB";
when '0011 11x' SEE "AUTIB";
when '0000 111' SEE "XPACLRI";
otherwise SEE "HINT";

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation for all encodings
if HavePACExt() then
if source_is_sp then
X[d] = AuthIA(X[d], SP[], FALSE);
else
X[d] = AuthIA(X[d], X[n], FALSE);

C6-812

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.23

AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB
Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier
and key B.
The address is:
•

In the general-purpose register that is specified by <Xd> for AUTIB and AUTIZB.

•

In X17, for AUTIB1716.

•

In X30, for AUTIBSP and AUTIBZ.

The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for AUTIB.

•

The value zero, for AUTIZB and AUTIBZ.

•

In X16, for AUTIB1716.

•

In SP, for AUTIBSP.

If the authentication passes, the upper bits of the address are restored to enable subsequent use of the address. If the
authentication fails, the upper bits are corrupted and any subsequent use of the address results in a Translation fault.

Integer
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 1 0 1

5 4
Rn

0
Rd

AUTIB variant
Applies when Z == 0.
AUTIB <Xd>, <Xn|SP>

AUTIZB variant
Applies when Z == 1 && Rn == 11111.
AUTIZB <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // AUTIB
if n == 31 then source_is_sp = TRUE;
else // AUTIZB
if n != 31 then UNDEFINED;

System
ARMv8.3

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-813

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 x 1 1 1 x 1 1 1 1 1
CRm
op2

AUTIB1716 variant
Applies when CRm == 0001 && op2 == 110.
AUTIB1716

AUTIBSP variant
Applies when CRm == 0011 && op2 == 111.
AUTIBSP

AUTIBZ variant
Applies when CRm == 0011 && op2 == 110.
AUTIBZ

Decode for all variants of this encoding
integer d;
integer n;
boolean source_is_sp = FALSE;
case CRm:op2 of
when '0011 110'
// AUTIBZ
d = 30;
n = 31;
when '0011 111'
// AUTIBSP
d = 30;
source_is_sp = TRUE;
when '0001 110'
// AUTIB1716
d = 17;
n = 16;
when '0001 000' SEE "PACIA";
when '0001 010' SEE "PACIB";
when '0001 100' SEE "AUTIA";
when '0011 00x' SEE "PACIA";
when '0011 01x' SEE "PACIB";
when '0011 10x' SEE "AUTIA";
when '0000 111' SEE "XPACLRI";
otherwise SEE "HINT";

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation for all encodings
if HavePACExt() then
if source_is_sp then
X[d] = AuthIB(X[d], SP[], FALSE);
else
X[d] = AuthIB(X[d], X[n], FALSE);

C6-814

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.24

AXFLAG
Convert floating-point condition flags from Arm to external format. This instruction converts the state of the
PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction
to an alternative representation required by some software.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 (0) (0) (0) (0) 0 1 0 1 1 1 1 1
CRm

Encoding
AXFLAG

Decode for this encoding
if !HaveFlagFormatExt() then UNDEFINED;

Operation
bit Z = PSTATE.Z OR PSTATE.V;
bit C = PSTATE.C AND NOT(PSTATE.V);
PSTATE.N
PSTATE.Z
PSTATE.C
PSTATE.V

ARM DDI 0487F.c
ID072120

=
=
=
=

'0';
Z;
C;
'0';

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-815

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.25

B.cond
Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.

31 30 29 28 27 26 25 24 23
0 1 0 1 0 1 0 0

5 4 3
imm19

0

0
cond

Encoding
B.<cond> <label>

Decode for this encoding
bits(64) offset = SignExtend(imm19:'00', 64);

Assembler symbols
<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

<label>

Is the program label to be conditionally branched to. Its offset from the address of this instruction,
in the range +/-1MB, is encoded as "imm19" times 4.

Operation
if ConditionHolds(cond) then
BranchTo(PC[] + offset, BranchType_DIR);

C6-816

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.26

B
Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call
or return.

31 30 29 28 27 26 25
0 0 0 1 0 1
op

0
imm26

Encoding
B <label>

Decode for this encoding
bits(64) offset = SignExtend(imm26:'00', 64);

Assembler symbols
Is the program label to be unconditionally branched to. Its offset from the address of this instruction,
in the range +/-128MB, is encoded as "imm26" times 4.

<label>

Operation
BranchTo(PC[] + offset, BranchType_DIR);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-817

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.27

BFC
Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the destination register to zero, leaving the other
destination bits unchanged.
This instruction is an alias of the BFM instruction. This means that:
•

The encodings in this description are named to match the encodings of BFM.

•

The description of BFM gives the operational pseudocode for this instruction.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4

1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
BFC <Wd>, #<lsb>, #<width>

is equivalent to
BFM <Wd>, WZR, #(-<lsb> MOD 32), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).
64-bit variant
Applies when sf == 1 && N == 1.
BFC <Xd>, #<lsb>, #<width>

is equivalent to
BFM <Xd>, XZR, #(-<lsb> MOD 64), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of BFM gives the operational pseudocode for this instruction.

C6-818

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-819

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.28

BFI
Bitfield Insert copies a bitfield of <width> bits from the least significant bits of the source register to bit position
<lsb> of the destination register, leaving the other destination bits unchanged.
This instruction is an alias of the BFM instruction. This means that:
•

The encodings in this description are named to match the encodings of BFM.

•

The description of BFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
!=11111
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
BFI <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
BFM

<Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).
64-bit variant
Applies when sf == 1 && N == 1.
BFI <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
BFM

<Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of BFM gives the operational pseudocode for this instruction.

C6-820

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-821

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.29

BFM
Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.
If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position
<immr> in the source register to the least significant bits of the destination register.
If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source
register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32
or 64 bits.
In both cases the other bits of the destination register remain unchanged.
This instruction is used by the aliases BFC, BFI, and BFXIL. See Alias conditions on page C6-823 for details of
when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
BFM <Wd>, <Wn>, #<immr>, #<imms>

64-bit variant
Applies when sf == 1 && N == 1.
BFM <Xd>, <Xn>, #<immr>, #<imms>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer R;
bits(datasize) wmask;
bits(datasize) tmask;
if sf == '1' && N != '1' then UNDEFINED;
if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
R = UInt(immr);
(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

C6-822

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

BFC

Rn == '11111' && UInt(imms) < UInt(immr)

BFI

Rn != '11111' && UInt(imms) < UInt(immr)

BFXIL

UInt(imms) >= UInt(immr)

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<immr>

For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.
For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.
For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
encoded in the "imms" field.

<imms>

For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
encoded in the "imms" field.

Operation
bits(datasize) dst = X[d];
bits(datasize) src = X[n];
// perform bitfield move on low bits
bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);
// combine extension bits and result bits
X[d] = (dst AND NOT(tmask)) OR (bot AND tmask);

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-823

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.30

BFXIL
Bitfield Extract and Insert Low copies a bitfield of <width> bits starting from bit position <lsb> in the source register
to the least significant bits of the destination register, leaving the other destination bits unchanged.
This instruction is an alias of the BFM instruction. This means that:
•

The encodings in this description are named to match the encodings of BFM.

•

The description of BFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
BFXIL <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
BFM

<Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when UInt(imms) >= UInt(immr).
64-bit variant
Applies when sf == 1 && N == 1.
BFXIL <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
BFM

<Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when UInt(imms) >= UInt(immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of BFM gives the operational pseudocode for this instruction.

C6-824

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-825

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.31

BIC (shifted register)
Bitwise Bit Clear (shifted register) performs a bitwise AND of a register value and the complement of an
optionally-shifted register value, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 0 1 0 1 0 shift 1
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
BIC <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
BIC <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

C6-826

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
operand2 = NOT(operand2);
result = operand1 AND operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-827

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.32

BICS (shifted register)
Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement
of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags
based on the result.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 0 shift 1
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
BICS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
BICS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

C6-828

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
operand2 = NOT(operand2);
result = operand1 AND operand2;
PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-829

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.33

BL
Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a
subroutine call.

31 30 29 28 27 26 25
1 0 0 1 0 1
op

0
imm26

Encoding
BL <label>

Decode for this encoding
bits(64) offset = SignExtend(imm26:'00', 64);

Assembler symbols
Is the program label to be unconditionally branched to. Its offset from the address of this instruction,
in the range +/-128MB, is encoded as "imm26" times 4.

<label>

Operation
X[30] = PC[] + 4;
BranchTo(PC[] + offset, BranchType_DIRCALL);

C6-830

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.34

BLR
Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 0 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0
Z
op
A M

5 4
Rn

0

0 0 0 0 0
Rm

Encoding
BLR <Xn>

Decode for this encoding
integer n = UInt(Rn);

Assembler symbols
Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
the "Rn" field.

<Xn>

Operation
bits(64) target = X[n];
X[30] = PC[] + 4;
BranchTo(target, BranchType_INDCALL);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-831

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.35

BLRAA, BLRAAZ, BLRAB, BLRABZ
Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the
general-purpose register that is specified by <Xn>, using a modifier and the specified key, and calls a subroutine at
the authenticated address, setting register X30 to PC+4.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xm|SP> for BLRAA and BLRAB.

•

The value zero, for BLRAAZ and BLRABZ.

Key A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ.
If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a
Translation fault is generated.
The authenticated address is not written back to the general-purpose register.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 0 1 1 Z 0 0 1 1 1 1 1 1 0 0 0 0 1 M
op
A

5 4
Rn

0
Rm

Key A, zero modifier variant
Applies when Z == 0 && M == 0 && Rm == 11111.
BLRAAZ <Xn>

Key A, register modifier variant
Applies when Z == 1 && M == 0.
BLRAA <Xn>, <Xm|SP>

Key B, zero modifier variant
Applies when Z == 0 && M == 1 && Rm == 11111.
BLRABZ <Xn>

Key B, register modifier variant
Applies when Z == 1 && M == 1.
BLRAB <Xn>, <Xm|SP>

Decode for all variants of this encoding
integer
integer
boolean
boolean

n = UInt(Rn);
m = UInt(Rm);
use_key_a = (M == '0');
source_is_sp = ((Z == '1') && (m == 31));

if !HavePACExt() then
UNDEFINED;
if Z == '0' && m != 31 then
UNDEFINED;

C6-832

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Assembler symbols
<Xn>

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
the "Rn" field.

<Xm|SP>

Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier,
encoded in the "Rm" field.

Operation
bits(64) target = X[n];
bits(64) modifier = if source_is_sp then SP[] else X[m];
if use_key_a then
target = AuthIA(target, modifier, TRUE);
else
target = AuthIB(target, modifier, TRUE);
X[30] = PC[] + 4;
BranchTo(target, BranchType_INDCALL);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-833

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.36

BR
Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 0 1 1 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0
Z
op
A M

5 4
Rn

0

0 0 0 0 0
Rm

Encoding
BR <Xn>

Decode for this encoding
integer n = UInt(Rn);

Assembler symbols
Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
the "Rn" field.

<Xn>

Operation
bits(64) target = X[n];
BranchTo(target, BranchType_INDIR);

C6-834

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.37

BRAA, BRAAZ, BRAB, BRABZ
Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose
register that is specified by <Xn>, using a modifier and the specified key, and branches to the authenticated address.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xm|SP> for BRAA and BRAB.

•

The value zero, for BRAAZ and BRABZ.

Key A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ.
If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a
Translation fault is generated.
The authenticated address is not written back to the general-purpose register.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 0 1 1 Z 0 0 0 1 1 1 1 1 0 0 0 0 1 M
op
A

5 4
Rn

0
Rm

Key A, zero modifier variant
Applies when Z == 0 && M == 0 && Rm == 11111.
BRAAZ <Xn>

Key A, register modifier variant
Applies when Z == 1 && M == 0.
BRAA <Xn>, <Xm|SP>

Key B, zero modifier variant
Applies when Z == 0 && M == 1 && Rm == 11111.
BRABZ <Xn>

Key B, register modifier variant
Applies when Z == 1 && M == 1.
BRAB <Xn>, <Xm|SP>

Decode for all variants of this encoding
integer
integer
boolean
boolean

n = UInt(Rn);
m = UInt(Rm);
use_key_a = (M == '0');
source_is_sp = ((Z == '1') && (m == 31));

if !HavePACExt() then
UNDEFINED;
if Z == '0' && m != 31 then
UNDEFINED;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-835

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Assembler symbols
<Xn>

Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
the "Rn" field.

<Xm|SP>

Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier,
encoded in the "Rm" field.

Operation
bits(64) target = X[n];
bits(64) modifier = if source_is_sp then SP[] else X[m];
if use_key_a then
target = AuthIA(target, modifier, TRUE);
else
target = AuthIB(target, modifier, TRUE);
BranchTo(target, BranchType_INDIR);

C6-836

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.38

BRK
Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction exception. The PE records the
exception in ESR_ELx, using the EC value 0x3c, and captures the value of the immediate argument in
ESR_ELx.ISS.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 0 0 1

5 4 3 2 1 0
imm16

0 0 0 0 0

Encoding
BRK #<imm>

Decode for this encoding
if HaveBTIExt() then
SetBTypeCompatible(TRUE);

Assembler symbols
Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<imm>

Operation
AArch64.SoftwareBreakpoint(imm16);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-837

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.39

BTI
Branch Target Identification. A BTI instruction is used to guard against the execution of instructions which are not
the intended target of a branch.
Outside of a guarded memory region, a BTI instruction executes as a NOP. Within a guarded memory region while
PSTATE.BTYPE != 0b00, a BTI instruction compatible with the current value of PSTATE.BTYPE will not generate
a Branch Target Exception and will allow execution of subsequent instructions within the memory region.
The operand <targets> passed to a BTI instruction determines the values of PSTATE.BTYPE which the BTI
instruction is compatible with.

Note
Within a guarded memory region, while PSTATE.BTYPE
!= 0b00, all instructions will generate a Branch Target
Exception, other than BRK, BTI, HLT, PACIASP,
and PACIBSP, which may not. See the individual instructions for details.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 0 0 x x 0 1 1 1 1 1
CRm
op2

Encoding
BTI {<targets>}

Decode for this encoding
SystemHintOp op;
if CRm:op2 == '0100 xx0' then
op = SystemHintOp_BTI;
// Check branch target compatibility between BTI instruction and PSTATE.BTYPE
SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
else
EndOfInstruction();

Assembler symbols
Is the type of indirection, encoded in the "op2<2:1>" field. It can have the following values:

<targets>

(omitted) when op2<2:1> = 00
c

when op2<2:1> = 01

j

when op2<2:1> = 10

jc

when op2<2:1> = 11

Operation
case op of
when SystemHintOp_YIELD
Hint_Yield();
when SystemHintOp_DGH

C6-838

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Hint_DGH();
when SystemHintOp_WFE
if IsEventRegisterSet() then
ClearEventRegister();
else
trap = FALSE;
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
if HaveTWEDExt() then
- = SCTLR[];
trap = sctlr.nTWE == '0';
target_el = EL1;
else
AArch64.CheckForWFxTrap(EL1, TRUE);
if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
if HaveTWEDExt() then
trap = HCR_EL2.TWE == '1';
target_el = EL2;
else
AArch64.CheckForWFxTrap(EL2, TRUE);
if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
if HaveTWEDExt() then
trap = SCR_EL3.TWE == '1';
target_el = EL3;
else
AArch64.CheckForWFxTrap(EL3, TRUE);
if HaveTWEDExt() && trap && PSTATE.EL != EL3 then
(delay_enabled, delay) = WFETrapDelay(target_el);

// (If trap delay is enabled, Delay

amount)
if !WaitForEventUntilDelay(delay_enabled, delay) then
// Event did not arrive before delay expired
AArch64.WFxTrap(target_el, TRUE);
// Trap WFE
else
WaitForEvent();
when SystemHintOp_WFI
if !InterruptPending() then
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
AArch64.CheckForWFxTrap(EL1, FALSE);
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
AArch64.CheckForWFxTrap(EL2, FALSE);
if HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
AArch64.CheckForWFxTrap(EL3, FALSE);
WaitForInterrupt();
when SystemHintOp_SEV
SendEvent();
when SystemHintOp_SEVL
SendEventLocal();
when SystemHintOp_ESB
SynchronizeErrors();
AArch64.ESBOperation();
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();
TakeUnmaskedSErrorInterrupts();
when SystemHintOp_PSB
ProfilingSynchronizationBarrier();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-839

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

when SystemHintOp_TSB
TraceSynchronizationBarrier();
when SystemHintOp_CSDB
ConsumptionOfSpeculativeDataBarrier();
when SystemHintOp_BTI
SetBTypeNext('00');
otherwise

C6-840

// do nothing

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.40

CASB, CASAB, CASALB, CASLB
Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a
first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed,
the read and write occur atomically such that no other modification of the memory location can take place between
the read and write.
•

CASAB and CASALB load from memory with acquire semantics.

•

CASLB and CASALB store to memory with release semantics.

•

CASB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
The architecture permits that the data read clears any exclusive monitors associated with that location, even if the
compare subsequently fails.
If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is
restored to the values held in the register before the instruction was executed.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 0 1 0 0 0 1 L 1
size

16 15 14 13 12 11 10 9
Rs

o0 1 1 1 1 1

5 4
Rn

0
Rt

CASAB variant
Applies when L == 1 && o0 == 0.
CASAB <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASALB variant
Applies when L == 1 && o0 == 1.
CASALB <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASB variant
Applies when L == 0 && o0 == 0.
CASB <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASLB variant
Applies when L == 0 && o0 == 1.
CASLB <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-841

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the "Rs"
field.

<Wt>

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the "Rt"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) comparevalue;
bits(8) newvalue;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
comparevalue = X[s];
newvalue = X[t];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);
X[s] = ZeroExtend(data, 32);

C6-842

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.41

CASH, CASAH, CASALH, CASLH
Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value
held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is
performed, the read and write occur atomically such that no other modification of the memory location can take
place between the read and write.
•

CASAH and CASALH load from memory with acquire semantics.

•

CASLH and CASALH store to memory with release semantics.

•

CAS has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
The architecture permits that the data read clears any exclusive monitors associated with that location, even if the
compare subsequently fails.
If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, is
restored to the values held in the register before the instruction was executed.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 0 0 0 1 L 1
size

16 15 14 13 12 11 10 9
Rs

o0 1 1 1 1 1

5 4
Rn

0
Rt

CASAH variant
Applies when L == 1 && o0 == 0.
CASAH <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASALH variant
Applies when L == 1 && o0 == 1.
CASALH <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASH variant
Applies when L == 0 && o0 == 0.
CASH <Ws>, <Wt>, [<Xn|SP>{,#0}]

CASLH variant
Applies when L == 0 && o0 == 1.
CASLH <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-843

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the "Rs"
field.

<Wt>

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the "Rt"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64)
bits(16)
bits(16)
bits(16)

address;
comparevalue;
newvalue;
data;

if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
comparevalue = X[s];
newvalue = X[t];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);
X[s] = ZeroExtend(data, 32);

C6-844

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.42

CASP, CASPA, CASPAL, CASPL
Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords
from memory, and compares them against the values held in the first pair of registers. If the comparison is equal,
the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes
occur atomically such that no other modification of the memory location can take place between the reads and
writes.
•

CASPA and CASPAL load from memory with acquire semantics.

•

CASPL and CASPAL store to memory with release semantics.

•

CAS has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
The architecture permits that the data read clears any exclusive monitors associated with that location, even if the
compare subsequently fails.
If the instruction generates a synchronous Data Abort, the registers which are compared and loaded, that is <Ws> and
<W(s+1)>, or <Xs> and <X(s+1)>, are restored to the values held in the registers before the instruction was executed.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 sz 0 0 1 0 0 0 0 L 1

16 15 14
Rs

10 9

o0 1 1 1 1 1
Rt2

5 4
Rn

0
Rt

32-bit CASP variant
Applies when sz == 0 && L == 0 && o0 == 0.
CASP <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]

32-bit CASPA variant
Applies when sz == 0 && L == 1 && o0 == 0.
CASPA <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]

32-bit CASPAL variant
Applies when sz == 0 && L == 1 && o0 == 1.
CASPAL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]

32-bit CASPL variant
Applies when sz == 0 && L == 0 && o0 == 1.
CASPL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]

64-bit CASP variant
Applies when sz == 1 && L == 0 && o0 == 0.
CASP <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-845

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit CASPA variant
Applies when sz == 1 && L == 1 && o0 == 0.
CASPA <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]

64-bit CASPAL variant
Applies when sz == 1 && L == 1 && o0 == 1.
CASPAL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]

64-bit CASPL variant
Applies when sz == 1 && L == 0 && o0 == 1.
CASPL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
if Rs<0> == '1' then UNDEFINED;
if Rt<0> == '1' then UNDEFINED;
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);
integer
AccType
AccType
boolean

datasize = 32 << UInt(sz);
ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Assembler symbols
<Ws>

Is the 32-bit name of the first general-purpose register to be compared and loaded, encoded in the
"Rs" field. <Ws> must be an even-numbered register.

<W(s+1)>

Is the 32-bit name of the second general-purpose register to be compared and loaded.

<Wt>

Is the 32-bit name of the first general-purpose register to be conditionally stored, encoded in the "Rt"
field. <Wt> must be an even-numbered register.

<W(t+1)>

Is the 32-bit name of the second general-purpose register to be conditionally stored.

<Xs>

Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the
"Rs" field. <Xs> must be an even-numbered register.

<X(s+1)>

Is the 64-bit name of the second general-purpose register to be compared and loaded.

<Xt>

Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the "Rt"
field. <Xt> must be an even-numbered register.

<X(t+1)>

Is the 64-bit name of the second general-purpose register to be conditionally stored.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(2*datasize) comparevalue;
bits(2*datasize) newvalue;
bits(2*datasize) data;
bits(datasize) s1 = X[s];
bits(datasize) s2 = X[s+1];

C6-846

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

bits(datasize) t1 = X[t];
bits(datasize) t2 = X[t+1];
comparevalue = if BigEndian() then s1:s2 else s2:s1;
newvalue = if BigEndian() then t1:t2 else t2:t1;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);
if BigEndian() then
X[s] = ZeroExtend(data<2*datasize-1:datasize>, datasize);
X[s+1] = ZeroExtend(data<datasize-1:0>, datasize);
else
X[s] = ZeroExtend(data<datasize-1:0>, datasize);
X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, datasize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-847

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.43

CAS, CASA, CASAL, CASL
Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and
compares it against the value held in a first register. If the comparison is equal, the value in a second register is
written to memory. If the write is performed, the read and write occur atomically such that no other modification of
the memory location can take place between the read and write.
•

CASA and CASAL load from memory with acquire semantics.

•

CASL and CASAL store to memory with release semantics.

•

CAS has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
The architecture permits that the data read clears any exclusive monitors associated with that location, even if the
compare subsequently fails.
If the instruction generates a synchronous Data Abort, the register which is compared and loaded, that is <Ws>, or
<Xs>, is restored to the value held in the register before the instruction was executed.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 0 0 1 0 0 0 1 L 1
size

16 15 14 13 12 11 10 9
Rs

o0 1 1 1 1 1

5 4
Rn

0
Rt

32-bit CAS variant
Applies when size == 10 && L == 0 && o0 == 0.
CAS <Ws>, <Wt>, [<Xn|SP>{,#0}]

32-bit CASA variant
Applies when size == 10 && L == 1 && o0 == 0.
CASA <Ws>, <Wt>, [<Xn|SP>{,#0}]

32-bit CASAL variant
Applies when size == 10 && L == 1 && o0 == 1.
CASAL <Ws>, <Wt>, [<Xn|SP>{,#0}]

32-bit CASL variant
Applies when size == 10 && L == 0 && o0 == 1.
CASL <Ws>, <Wt>, [<Xn|SP>{,#0}]

64-bit CAS variant
Applies when size == 11 && L == 0 && o0 == 0.
CAS <Xs>, <Xt>, [<Xn|SP>{,#0}]

64-bit CASA variant
Applies when size == 11 && L == 1 && o0 == 0.
C6-848

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

CASA <Xs>, <Xt>, [<Xn|SP>{,#0}]

64-bit CASAL variant
Applies when size == 11 && L == 1 && o0 == 1.
CASAL <Xs>, <Xt>, [<Xn|SP>{,#0}]

64-bit CASL variant
Applies when size == 11 && L == 0 && o0 == 1.
CASL <Xs>, <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the "Rs"
field.

<Wt>

Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the "Rt"
field.

<Xs>

Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the "Rs"
field.

<Xt>

Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the "Rt"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) comparevalue;
bits(datasize) newvalue;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
comparevalue = X[s];
newvalue = X[t];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);
X[s] = ZeroExtend(data, regsize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-849

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.44

CBNZ
Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label
at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return.
This instruction does not affect the condition flags.

31 30 29 28 27 26 25 24 23
sf 0 1 1 0 1 0 1
op

5 4
imm19

0
Rt

32-bit variant
Applies when sf == 0.
CBNZ <Wt>, <label>

64-bit variant
Applies when sf == 1.
CBNZ <Xt>, <label>

Decode for all variants of this encoding
integer t = UInt(Rt);
integer datasize = if sf == '1' then 64 else 32;
bits(64) offset = SignExtend(imm19:'00', 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

<label>

Is the program label to be conditionally branched to. Its offset from the address of this instruction,
in the range +/-1MB, is encoded as "imm19" times 4.

Operation
bits(datasize) operand1 = X[t];
if IsZero(operand1) == FALSE then
BranchTo(PC[] + offset, BranchType_DIR);

C6-850

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.45

CBZ
Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a
PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This
instruction does not affect condition flags.

31 30 29 28 27 26 25 24 23
sf 0 1 1 0 1 0 0
op

5 4
imm19

0
Rt

32-bit variant
Applies when sf == 0.
CBZ <Wt>, <label>

64-bit variant
Applies when sf == 1.
CBZ <Xt>, <label>

Decode for all variants of this encoding
integer t = UInt(Rt);
integer datasize = if sf == '1' then 64 else 32;
bits(64) offset = SignExtend(imm19:'00', 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be tested, encoded in the "Rt" field.

<label>

Is the program label to be conditionally branched to. Its offset from the address of this instruction,
in the range +/-1MB, is encoded as "imm19" times 4.

Operation
bits(datasize) operand1 = X[t];
if IsZero(operand1) == TRUE then
BranchTo(PC[] + offset, BranchType_DIR);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-851

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.46

CCMN (immediate)
Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of
a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 1 1 0 1 0 0 1 0
op

16 15
imm5

12 11 10 9
cond

1 0

5 4 3
Rn

0

0
nzcv

32-bit variant
Applies when sf == 0.
CCMN <Wn>, #<imm>, #<nzcv>, <cond>

64-bit variant
Applies when sf == 1.
CCMN <Xn>, #<imm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(4) flags = nzcv;
bits(datasize) imm = ZeroExtend(imm5, datasize);

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<imm>

Is a five bit unsigned (positive) immediate encoded in the "imm5" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) operand1 = X[n];
if ConditionHolds(cond) then
(-, flags) = AddWithCarry(operand1, imm, '0');
PSTATE.<N,Z,C,V> = flags;

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

C6-852

The values of the data supplied in any of its registers.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

—

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-853

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.47

CCMN (register)
Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a
register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 1 1 0 1 0 0 1 0
op

16 15
Rm

12 11 10 9
cond

0 0

5 4 3
Rn

0

0
nzcv

32-bit variant
Applies when sf == 0.
CCMN <Wn>, <Wm>, #<nzcv>, <cond>

64-bit variant
Applies when sf == 1.
CCMN <Xn>, <Xm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer
integer
integer
bits(4)

n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;
flags = nzcv;

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then
(-, flags) = AddWithCarry(operand1, operand2, '0');
PSTATE.<N,Z,C,V> = flags;

Operational information
If PSTATE.DIT is 1:
•

C6-854

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-855

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.48

CCMP (immediate)
Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register
value and an immediate value if the condition is TRUE, and an immediate value otherwise.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 1 1 0 1 0 0 1 0
op

16 15
imm5

12 11 10 9
cond

1 0

5 4 3
Rn

0

0
nzcv

32-bit variant
Applies when sf == 0.
CCMP <Wn>, #<imm>, #<nzcv>, <cond>

64-bit variant
Applies when sf == 1.
CCMP <Xn>, #<imm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(4) flags = nzcv;
bits(datasize) imm = ZeroExtend(imm5, datasize);

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<imm>

Is a five bit unsigned (positive) immediate encoded in the "imm5" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2;
if ConditionHolds(cond) then
operand2 = NOT(imm);
(-, flags) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = flags;

Operational information
If PSTATE.DIT is 1:
•

C6-856

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-857

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.49

CCMP (register)
Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers
if the condition is TRUE, and an immediate value otherwise.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 1 1 0 1 0 0 1 0
op

16 15
Rm

12 11 10 9
cond

0 0

5 4 3
Rn

0

0
nzcv

32-bit variant
Applies when sf == 0.
CCMP <Wn>, <Wm>, #<nzcv>, <cond>

64-bit variant
Applies when sf == 1.
CCMP <Xn>, <Xm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer
integer
integer
bits(4)

n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;
flags = nzcv;

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then
operand2 = NOT(operand2);
(-, flags) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = flags;

Operational information
If PSTATE.DIT is 1:
•

The execution time of this instruction is independent of:
—

C6-858

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

—
•

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-859

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.50

CFINV
Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 (0) (0) (0) (0) 0 0 0 1 1 1 1 1
CRm

Encoding
CFINV

Decode for this encoding
if !HaveFlagManipulateExt() then UNDEFINED;

Operation
PSTATE.C = NOT(PSTATE.C);

Operational information
If PSTATE.DIT is 1:
•

•

C6-860

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.51

CFP
Control Flow Prediction Restriction by Context prevents control flow predictions that predict execution addresses,
based on information gathered from earlier execution within a particular execution context, from allowing later
speculative execution within that context to be observable through side-channels.
For more information, see CFP RCTX.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

12 11

8 7

5 4

1 1 0 1 0 1 0 1 0 0 0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 0 0
L
op1
CRn
CRm
op2

0
Rt

Encoding
CFP RCTX, <Xt>

is equivalent to
SYS #3, C7, C3, #4, <Xt>

and is always the preferred disassembly.

Assembler symbols
Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

<Xt>

Operation
The description of SYS gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-861

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.52

CINC
Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the
condition is TRUE, and otherwise returns the value of the source register.
This instruction is an alias of the CSINC instruction. This means that:
•

The encodings in this description are named to match the encodings of CSINC.

•

The description of CSINC gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 0 0
op

16 15
!=11111
Rm

12 11 10 9
!=111x
cond

0 1
o2

5 4
!=11111
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CINC <Wd>, <Wn>, <cond>

is equivalent to
CSINC <Wd>, <Wn>, <Wn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.
64-bit variant
Applies when sf == 1.
CINC <Xd>, <Xn>, <cond>

is equivalent to
CSINC <Xd>, <Xn>, <Xn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<cond>

Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
significant bit inverted.

Operation
The description of CSINC gives the operational pseudocode for this instruction.

C6-862

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-863

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.53

CINV
Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the
condition is TRUE, and otherwise returns the value of the source register.
This instruction is an alias of the CSINV instruction. This means that:
•

The encodings in this description are named to match the encodings of CSINV.

•

The description of CSINV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 1 0 0
op

16 15
!=11111
Rm

12 11 10 9
!=111x
cond

0 0
o2

5 4
!=11111
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CINV <Wd>, <Wn>, <cond>

is equivalent to
CSINV <Wd>, <Wn>, <Wn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.
64-bit variant
Applies when sf == 1.
CINV <Xd>, <Xn>, <cond>

is equivalent to
CSINV <Xd>, <Xn>, <Xn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<cond>

Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
significant bit inverted.

Operation
The description of CSINV gives the operational pseudocode for this instruction.

C6-864

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-865

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.54

CLREX
Clear Exclusive clears the local monitor of the executing PE.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1

8 7 6 5 4 3 2 1 0
CRm

0 1 0 1 1 1 1 1

Encoding
CLREX {#<imm>}

Decode for this encoding
// CRm field is ignored

Assembler symbols
Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the
"CRm" field.

<imm>

Operation
ClearExclusiveLocal(ProcessorID());

C6-866

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.55

CLS
Count Leading Sign bits counts the number of leading bits of the source register that have the same value as the
most significant bit of the register, and writes the result to the destination register. This count does not include the
most significant bit of the source register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 1
op

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CLS <Wd>, <Wn>

64-bit variant
Applies when sf == 1.
CLS <Xd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
integer result;
bits(datasize) operand1 = X[n];
result = CountLeadingSignBits(operand1);
X[d] = result<datasize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-867

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.56

CLZ
Count Leading Zeros counts the number of binary zero bits before the first binary one bit in the value of the source
register, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0
op

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CLZ <Wd>, <Wn>

64-bit variant
Applies when sf == 1.
CLZ <Xd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
integer result;
bits(datasize) operand1 = X[n];
result = CountLeadingZeroBits(operand1);
X[d] = result<datasize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

C6-868

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.57

CMN (extended register)
Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by
an optional left shift amount. The argument that is extended from the <Rm> register can be a byte, halfword, word,
or doubleword. It updates the condition flags based on the result, and discards the result.
This instruction is an alias of the ADDS (extended register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ADDS (extended register).

•

The description of ADDS (extended register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMN <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

is equivalent to
ADDS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMN <Xn|SP>, <R><m>{, <extend> {#<amount>}}

is equivalent to
ADDS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

and is always the preferred disassembly.

Assembler symbols
<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

Is a width specifier, encoded in the "option" field. It can have the following values:

<m>

ARM DDI 0487F.c
ID072120

W

when option = 00x

W

when option = 010

X

when option = x11

W

when option = 10x

W

when option = 110

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-869

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:

<extend>

UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
The description of ADDS (extended register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-870

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.58

CMN (immediate)
Compare Negative (immediate) adds a register value and an optionally-shifted immediate value. It updates the
condition flags based on the result, and discards the result.
This instruction is an alias of the ADDS (immediate) instruction. This means that:
•

The encodings in this description are named to match the encodings of ADDS (immediate).

•

The description of ADDS (immediate) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMN <Wn|WSP>, #<imm>{, <shift>}

is equivalent to
ADDS WZR, <Wn|WSP>, #<imm> {, <shift>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMN <Xn|SP>, #<imm>{, <shift>}

is equivalent to
ADDS XZR, <Xn|SP>, #<imm> {, <shift>}

and is always the preferred disassembly.

Assembler symbols
<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

when sh = 0

LSL #12

when sh = 1

Operation
The description of ADDS (immediate) gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-871

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-872

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.59

CMN (shifted register)
Compare Negative (shifted register) adds a register value and an optionally-shifted register value. It updates the
condition flags based on the result, and discards the result.
This instruction is an alias of the ADDS (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ADDS (shifted register).

•

The description of ADDS (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMN <Wn>, <Wm>{, <shift> #<amount>}

is equivalent to
ADDS WZR, <Wn>, <Wm> {, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMN <Xn>, <Xm>{, <shift> #<amount>}

is equivalent to
ADDS XZR, <Xn>, <Xm> {, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
<amount>

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-873

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of ADDS (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-874

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.60

CMP (extended register)
Compare (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift
amount, from a register value. The argument that is extended from the <Rm> register can be a byte, halfword, word,
or doubleword. It updates the condition flags based on the result, and discards the result.
This instruction is an alias of the SUBS (extended register) instruction. This means that:
•

The encodings in this description are named to match the encodings of SUBS (extended register).

•

The description of SUBS (extended register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMP <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

is equivalent to
SUBS WZR, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMP <Xn|SP>, <R><m>{, <extend> {#<amount>}}

is equivalent to
SUBS XZR, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

and is always the preferred disassembly.

Assembler symbols
<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

Is a width specifier, encoded in the "option" field. It can have the following values:

<m>

ARM DDI 0487F.c
ID072120

W

when option = 00x

W

when option = 010

X

when option = x11

W

when option = 10x

W

when option = 110

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-875

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:

<extend>

UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
The description of SUBS (extended register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-876

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.61

CMP (immediate)
Compare (immediate) subtracts an optionally-shifted immediate value from a register value. It updates the condition
flags based on the result, and discards the result.
This instruction is an alias of the SUBS (immediate) instruction. This means that:
•

The encodings in this description are named to match the encodings of SUBS (immediate).

•

The description of SUBS (immediate) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 1 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMP <Wn|WSP>, #<imm>{, <shift>}

is equivalent to
SUBS WZR, <Wn|WSP>, #<imm> {, <shift>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMP <Xn|SP>, #<imm>{, <shift>}

is equivalent to
SUBS XZR, <Xn|SP>, #<imm> {, <shift>}

and is always the preferred disassembly.

Assembler symbols
<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

when sh = 0

LSL #12

when sh = 1

Operation
The description of SUBS (immediate) gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-877

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-878

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.62

CMP (shifted register)
Compare (shifted register) subtracts an optionally-shifted register value from a register value. It updates the
condition flags based on the result, and discards the result.
This instruction is an alias of the SUBS (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of SUBS (shifted register).

•

The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
CMP <Wn>, <Wm>{, <shift> #<amount>}

is equivalent to
SUBS WZR, <Wn>, <Wm> {, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CMP <Xn>, <Xm>{, <shift> #<amount>}

is equivalent to
SUBS XZR, <Xn>, <Xm> {, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
<amount>

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-879

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-880

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.63

CMPP
Compare with Tag subtracts the 56-bit address held in the second source register from the 56-bit address held in the
first source register, updates the condition flags based on the result of the subtraction, and discards the result.
This instruction is an alias of the SUBPS instruction. This means that:
•

The encodings in this description are named to match the encodings of SUBPS.

•

The description of SUBPS gives the operational pseudocode for this instruction.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Xm

0 0 0 0 0 0

5 4
Xn

0

1 1 1 1 1
Xd

Encoding
CMPP <Xn|SP>, <Xm|SP>

is equivalent to
SUBPS XZR, <Xn|SP>, <Xm|SP>

and is always the preferred disassembly.

Assembler symbols
<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Xn"
field.

<Xm|SP>

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the
"Xm" field.

Operation
The description of SUBPS gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-881

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.64

CNEG
Conditional Negate returns, in the destination register, the negated value of the source register if the condition is
TRUE, and otherwise returns the value of the source register.
This instruction is an alias of the CSNEG instruction. This means that:
•

The encodings in this description are named to match the encodings of CSNEG.

•

The description of CSNEG gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 1 0 0
op

16 15
Rm

12 11 10 9
!=111x
cond

0 1
o2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CNEG <Wd>, <Wn>, <cond>

is equivalent to
CSNEG <Wd>, <Wn>, <Wn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.
64-bit variant
Applies when sf == 1.
CNEG <Xd>, <Xn>, <cond>

is equivalent to
CSNEG <Xd>, <Xn>, <Xn>, invert(<cond>)

and is the preferred disassembly when Rn == Rm.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<cond>

Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
significant bit inverted.

Operation
The description of CSNEG gives the operational pseudocode for this instruction.

C6-882

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-883

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.65

CPP
Cache Prefetch Prediction Restriction by Context prevents cache allocation predictions, based on information
gathered from earlier execution within a particular execution context, from allowing later speculative execution
within that context to be observable through side-channels.
For more information, see CPP RCTX.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

12 11

8 7

5 4

1 1 0 1 0 1 0 1 0 0 0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 1 1
L
op1
CRn
CRm
op2

0
Rt

Encoding
CPP RCTX, <Xt>

is equivalent to
SYS #3, C7, C3, #7, <Xt>

and is always the preferred disassembly.

Assembler symbols
Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

<Xt>

Operation
The description of SYS gives the operational pseudocode for this instruction.

C6-884

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.66

CRC32B, CRC32H, CRC32W, CRC32X
CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose

register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second
source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align
with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7
is used for the CRC calculation.
In Armv8-A, this is an OPTIONAL instruction, and in Armv8.1 it is mandatory for all implementations to implement
it.

Note
ID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 1 0 0
C

sz

5 4
Rn

0
Rd

CRC32B variant
Applies when sf == 0 && sz == 00.
CRC32B <Wd>, <Wn>, <Wm>

CRC32H variant
Applies when sf == 0 && sz == 01.
CRC32H <Wd>, <Wn>, <Wm>

CRC32W variant
Applies when sf == 0 && sz == 10.
CRC32W <Wd>, <Wn>, <Wm>

CRC32X variant
Applies when sf == 1 && sz == 11.
CRC32X <Wd>, <Wn>, <Xm>

Decode for all variants of this encoding
if !HaveCRCExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sf == '1' && sz != '11' then UNDEFINED;
if sf == '0' && sz == '11' then UNDEFINED;
integer size = 8 << UInt(sz);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose accumulator output register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose accumulator input register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose data source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-885

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 32-bit name of the general-purpose data source register, encoded in the "Rm" field.

<Wm>

Operation
bits(32) acc = X[n];
// accumulator
bits(size) val = X[m];
// input value
bits(32) poly = 0x04C11DB7<31:0>;
bits(32+size) tempacc = BitReverse(acc):Zeros(size);
bits(size+32) tempval = BitReverse(val):Zeros(32);
// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

Operational information
If PSTATE.DIT is 1:
•

•

C6-886

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.67

CRC32CB, CRC32CH, CRC32CW, CRC32CX
CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose

register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second
source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align
with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41
is used for the CRC calculation.
In Armv8-A, this is an OPTIONAL instruction, and in Armv8.1 it is mandatory for all implementations to implement
it.

Note
ID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 1 0 1
C

sz

5 4
Rn

0
Rd

CRC32CB variant
Applies when sf == 0 && sz == 00.
CRC32CB <Wd>, <Wn>, <Wm>

CRC32CH variant
Applies when sf == 0 && sz == 01.
CRC32CH <Wd>, <Wn>, <Wm>

CRC32CW variant
Applies when sf == 0 && sz == 10.
CRC32CW <Wd>, <Wn>, <Wm>

CRC32CX variant
Applies when sf == 1 && sz == 11.
CRC32CX <Wd>, <Wn>, <Xm>

Decode for all variants of this encoding
if !HaveCRCExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sf == '1' && sz != '11' then UNDEFINED;
if sf == '0' && sz == '11' then UNDEFINED;
integer size = 8 << UInt(sz);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose accumulator output register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose accumulator input register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose data source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-887

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 32-bit name of the general-purpose data source register, encoded in the "Rm" field.

<Wm>

Operation
bits(32) acc = X[n];
// accumulator
bits(size) val = X[m];
// input value
bits(32) poly = 0x1EDC6F41<31:0>;
bits(32+size) tempacc = BitReverse(acc):Zeros(size);
bits(size+32) tempval = BitReverse(val):Zeros(32);
// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));

Operational information
If PSTATE.DIT is 1:
•

•

C6-888

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.68

CSDB
Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value
prediction.
No instruction other than branch instructions appearing in program order after the CSDB can be speculatively
executed using the results of any:
•

Data value predictions of any instructions.

•

PSTATE.{N,Z,C,V} predictions of any instructions other than conditional branch instructions appearing in
program order before the CSDB that have not been architecturally resolved.

•

Predictions of SVE predication state for any SVE instructions.

Note
For purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a data value. This definition permits:
•

Control flow speculation before and after the CSDB.

•

Speculative execution of conditional data processing instructions after the CSDB, unless they use the results
of data value or PSTATE.{N,Z,C,V} predictions of instructions appearing in program order before the CSDB
that have not been architecturally resolved.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 1 0 0 1 1 1 1 1
CRm
op2

Encoding
CSDB

Decode for this encoding
// Empty.

Operation
ConsumptionOfSpeculativeDataBarrier();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-889

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.69

CSEL
If the condition is true, Conditional Select writes the value of the first source register to the destination register. If
the condition is false, it writes the value of the second source register to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 0 0
op

16 15
Rm

12 11 10 9
cond

0 0
o2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSEL <Wd>, <Wn>, <Wm>, <cond>

64-bit variant
Applies when sf == 1.
CSEL <Xd>, <Xn>, <Xm>, <cond>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then
result = operand1;
else
result = operand2;
X[d] = result;

C6-890

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-891

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.70

CSET
Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.
This instruction is an alias of the CSINC instruction. This means that:
•

The encodings in this description are named to match the encodings of CSINC.

•

The description of CSINC gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20

16 15

sf 0 0 1 1 0 1 0 1 0 0 1 1 1 1 1
op
Rm

12 11 10 9
!=111x
cond

5 4

0 1 1 1 1 1 1
o2
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSET <Wd>, <cond>

is equivalent to
CSINC <Wd>, WZR, WZR, invert(<cond>)

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CSET <Xd>, <cond>

is equivalent to
CSINC <Xd>, XZR, XZR, invert(<cond>)

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<cond>

Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
significant bit inverted.

Operation
The description of CSINC gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

C6-892

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-893

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.71

CSETM
Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits
to 0.
This instruction is an alias of the CSINV instruction. This means that:
•

The encodings in this description are named to match the encodings of CSINV.

•

The description of CSINV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20

16 15

sf 1 0 1 1 0 1 0 1 0 0 1 1 1 1 1
op
Rm

12 11 10 9
!=111x
cond

5 4

0 0 1 1 1 1 1
o2
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSETM <Wd>, <cond>

is equivalent to
CSINV <Wd>, WZR, WZR, invert(<cond>)

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
CSETM <Xd>, <cond>

is equivalent to
CSINV <Xd>, XZR, XZR, invert(<cond>)

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<cond>

Is one of the standard conditions, excluding AL and NV, encoded in the "cond" field with its least
significant bit inverted.

Operation
The description of CSINV gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

C6-894

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-895

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.72

CSINC
Conditional Select Increment returns, in the destination register, the value of the first source register if the condition
is TRUE, and otherwise returns the value of the second source register incremented by 1.
This instruction is used by the aliases CINC and CSET. See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 0 0
op

16 15
Rm

12 11 10 9
cond

0 1
o2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSINC <Wd>, <Wn>, <Wm>, <cond>

64-bit variant
Applies when sf == 1.
CSINC <Xd>, <Xn>, <Xm>, <cond>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

CINC

Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm

CSET

Rm == '11111' && cond != '111x' && Rn == '11111'

Assembler symbols

C6-896

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then
result = operand1;
else
result = operand2 + 1;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-897

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.73

CSINV
Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is
TRUE, and otherwise returns the bitwise inversion value of the second source register.
This instruction is used by the aliases CINV and CSETM. See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 1 0 0
op

16 15
Rm

12 11 10 9
cond

0 0
o2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSINV <Wd>, <Wn>, <Wm>, <cond>

64-bit variant
Applies when sf == 1.
CSINV <Xd>, <Xn>, <Xm>, <cond>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

CINV

Rm != '11111' && cond != '111x' && Rn != '11111' && Rn == Rm

CSETM

Rm == '11111' && cond != '111x' && Rn == '11111'

Assembler symbols

C6-898

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then
result = operand1;
else
result = NOT(operand2);
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-899

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.74

CSNEG
Conditional Select Negation returns, in the destination register, the value of the first source register if the condition
is TRUE, and otherwise returns the negated value of the second source register.
This instruction is used by the alias CNEG. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 1 0 0
op

16 15
Rm

12 11 10 9
cond

0 1
o2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
CSNEG <Wd>, <Wn>, <Wm>, <cond>

64-bit variant
Applies when sf == 1.
CSNEG <Xd>, <Xn>, <Xm>, <cond>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

CNEG

cond != '111x' && Rn == Rm

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
if ConditionHolds(cond) then

C6-900

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

result = operand1;
else
result = NOT(operand2);
result = result + 1;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-901

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.75

DC
Data Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address
translation instructions on page C5-377.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 1
L

16 15
op1

12 11

0 1 1 1
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
DC <dc_op>, <Xt>

is equivalent to
SYS #<op1>, C7, <Cm>, #<op2>, <Xt>

and is the preferred disassembly when SysOp(op1,'0111',CRm,op2) == Sys_DC.

Assembler symbols
<dc_op>

Is a DC instruction name, as listed for the DC system instruction group, encoded in the
"op1:CRm:op2" field. It can have the following values:
IVAC

when op1 = 000, CRm = 0110, op2 = 001

ISW

when op1 = 000, CRm = 0110, op2 = 010

CSW

when op1 = 000, CRm = 1010, op2 = 010

CISW

when op1 = 000, CRm = 1110, op2 = 010

ZVA

when op1 = 011, CRm = 0100, op2 = 001

CVAC

when op1 = 011, CRm = 1010, op2 = 001

CVAU

when op1 = 011, CRm = 1011, op2 = 001

CIVAC

when op1 = 011, CRm = 1110, op2 = 001

When FEAT_MTE is implemented, the following values are also valid:

C6-902

IGVAC

when op1 = 000, CRm = 0110, op2 = 011

IGSW

when op1 = 000, CRm = 0110, op2 = 100

IGDVAC

when op1 = 000, CRm = 0110, op2 = 101

IGDSW

when op1 = 000, CRm = 0110, op2 = 110

CGSW

when op1 = 000, CRm = 1010, op2 = 100

CGDSW

when op1 = 000, CRm = 1010, op2 = 110

CIGSW

when op1 = 000, CRm = 1110, op2 = 100

CIGDSW

when op1 = 000, CRm = 1110, op2 = 110

GVA

when op1 = 011, CRm = 0100, op2 = 011

GZVA

when op1 = 011, CRm = 0100, op2 = 100

CGVAC

when op1 = 011, CRm = 1010, op2 = 011

CGDVAC

when op1 = 011, CRm = 1010, op2 = 101

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

CGVAP

when op1 = 011, CRm = 1100, op2 = 011

CGDVAP

when op1 = 011, CRm = 1100, op2 = 101

CGVADP

when op1 = 011, CRm = 1101, op2 = 011

CGDVADP

when op1 = 011, CRm = 1101, op2 = 101

CIGVAC

when op1 = 011, CRm = 1110, op2 = 011

CIGDVAC

when op1 = 011, CRm = 1110, op2 = 101

When FEAT_DPB is implemented, the following value is also valid:
CVAP

when op1 = 011, CRm = 1100, op2 = 001

When FEAT_DPB2 is implemented, the following value is also valid:
CVADP

when op1 = 011, CRm = 1101, op2 = 001

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<Xt>

Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

Operation
The description of SYS gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-903

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.76

DCPS1
Debug Change PE State to EL1, when executed in Debug state:
•

If executed at EL0 changes the current Exception level and SP to EL1 using SP_EL1.

•

Otherwise, if executed at ELx, selects SP_ELx.

The target exception level of a DCPS1 instruction is:
•

EL1 if the instruction is executed at EL0.

•

Otherwise, the Exception level at which the instruction is executed.

When the target Exception level of a DCPS1 instruction is ELx, on executing this instruction:
•

ELR_ELx becomes UNKNOWN.

•

SPSR_ELx becomes UNKNOWN.

•

ESR_ELx becomes UNKNOWN.

•

DLR_EL0 and DSPSR_EL0 become UNKNOWN.

•

The endianness is set according to SCTLR_ELx.EE.

This instruction is UNDEFINED at EL0 in Non-secure state if EL2 is implemented and HCR_EL2.TGE == 1.
This instruction is always UNDEFINED in Non-debug state.
For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 1 0 1

5 4 3 2 1 0
imm16

0 0 0 0 1
LL

Encoding
DCPS1 {#<imm>}

Decode for this encoding
if !Halted() then UNDEFINED;

Assembler symbols
Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
the "imm16" field.

<imm>

Operation
DCPSInstruction(LL);

C6-904

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.77

DCPS2
Debug Change PE State to EL2, when executed in Debug state:
•

If executed at EL0 or EL1 changes the current Exception level and SP to EL2 using SP_EL2.

•

Otherwise, if executed at ELx, selects SP_ELx.

The target exception level of a DCPS2 instruction is:
•

EL2 if the instruction is executed at an exception level that is not EL3.

•

EL3 if the instruction is executed at EL3.

When the target Exception level of a DCPS2 instruction is ELx, on executing this instruction:
•

ELR_ELx becomes UNKNOWN.

•

SPSR_ELx becomes UNKNOWN.

•

ESR_ELx becomes UNKNOWN.

•

DLR_EL0 and DSPSR_EL0 become UNKNOWN.

•

The endianness is set according to SCTLR_ELx.EE.

This instruction is UNDEFINED at the following exception levels:
•

All exception levels if EL2 is not implemented.

•

At EL0 and EL1 if EL2 is disabled in the current Security state.

This instruction is always UNDEFINED in Non-debug state.
For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 1 0 1

5 4 3 2 1 0
imm16

0 0 0 1 0
LL

Encoding
DCPS2 {#<imm>}

Decode for this encoding
if !Halted() then UNDEFINED;

Assembler symbols
Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
the "imm16" field.

<imm>

Operation
DCPSInstruction(LL);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-905

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.78

DCPS3
Debug Change PE State to EL3, when executed in Debug state:
•

If executed at EL3 selects SP_EL3.

•

Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.

The target exception level of a DCPS3 instruction is EL3.
On executing a DCPS3 instruction:
•

ELR_EL3 becomes UNKNOWN.

•

SPSR_EL3 becomes UNKNOWN.

•

ESR_EL3 becomes UNKNOWN.

•

DLR_EL0 and DSPSR_EL0 become UNKNOWN.

•

The endianness is set according to SCTLR_EL3.EE.

This instruction is UNDEFINED at all exception levels if either:
•

EDSCR.SDD == 1.

•

EL3 is not implemented.

This instruction is always UNDEFINED in Non-debug state.
For more information on the operation of the DCPSn instructions, see DCPS<n> on page H2-7042.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 1 0 1

5 4 3 2 1 0
imm16

0 0 0 1 1
LL

Encoding
DCPS3 {#<imm>}

Decode for this encoding
if !Halted() then UNDEFINED;

Assembler symbols
Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in
the "imm16" field.

<imm>

Operation
DCPSInstruction(LL);

C6-906

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.79

DGH
DGH is a hint instruction. A DGH instruction is not expected to be performance optimal to merge memory accesses
with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with
any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1
CRm
op2

Encoding
DGH

Decode for this encoding
if !HaveDGHExt() then EndOfInstruction();

Operation
Hint_DGH();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-907

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.80

DMB
Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data
Memory Barrier (DMB) on page B2-135.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1

8 7 6 5 4 3 2 1 0
CRm

1 0 1 1 1 1 1 1
opc

Encoding
DMB <option>|#<imm>

Decode for this encoding
case CRm<3:2>
when '00'
when '01'
when '10'
when '11'
case CRm<1:0>
when '00'
when '01'
when '10'
when '11'

of
domain = MBReqDomain_OuterShareable;
domain = MBReqDomain_Nonshareable;
domain = MBReqDomain_InnerShareable;
domain = MBReqDomain_FullSystem;
of
types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
types = MBReqTypes_Reads;
types = MBReqTypes_Writes;
types = MBReqTypes_All;

Assembler symbols
<option>

C6-908

Specifies the limitation on the barrier operation. Values are:
SY

Full system is the required shareability domain, reads and writes are the required access
types, both before and after the barrier instruction. This option is referred to as the full
system barrier. Encoded as CRm = 0b1111.

ST

Full system is the required shareability domain, writes are the required access type, both
before and after the barrier instruction. Encoded as CRm = 0b1110.

LD

Full system is the required shareability domain, reads are the required access type before
the barrier instruction, and reads and writes are the required access types after the barrier
instruction. Encoded as CRm = 0b1101.

ISH

Inner Shareable is the required shareability domain, reads and writes are the required
access types, both before and after the barrier instruction. Encoded as CRm = 0b1011.

ISHST

Inner Shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b1010.

ISHLD

Inner Shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b1001.

NSH

Non-shareable is the required shareability domain, reads and writes are the required
access, both before and after the barrier instruction. Encoded as CRm = 0b0111.

NSHST

Non-shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b0110.

NSHLD

Non-shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b0101.

OSH

Outer Shareable is the required shareability domain, reads and writes are the required
access types, both before and after the barrier instruction. Encoded as CRm = 0b0011.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

OSHST

Outer Shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b0010.

OSHLD

Outer Shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b0001.

All other encodings of CRm that are not listed above are reserved, and can be encoded using the #<imm>
syntax. All unsupported and reserved options must execute as a full system barrier operation, but
software must not rely on this behavior. For more information on whether an access is before or after
a barrier instruction, see Data Memory Barrier (DMB) on page B2-135 or see Data Synchronization
Barrier (DSB) on page B2-138.
Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.

<imm>

Operation
DataMemoryBarrier(domain, types);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-909

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.81

DRPS
Debug restore process state

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 1 0 1 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0

Encoding
DRPS

Decode for this encoding
if !Halted() || PSTATE.EL == EL0 then UNDEFINED;

Operation
DRPSInstruction();

C6-910

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.82

DSB
Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data
Synchronization Barrier (DSB) on page B2-138.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1

8 7 6 5 4 3 2 1 0
!=0x00
CRm

1 0 0 1 1 1 1 1
opc

Encoding
DSB <option>|#<imm>

Decode for this encoding
case CRm<3:2>
when '00'
when '01'
when '10'
when '11'
case CRm<1:0>
when '00'
when '01'
when '10'
when '11'

of
domain = MBReqDomain_OuterShareable;
domain = MBReqDomain_Nonshareable;
domain = MBReqDomain_InnerShareable;
domain = MBReqDomain_FullSystem;
of
types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
types = MBReqTypes_Reads;
types = MBReqTypes_Writes;
types = MBReqTypes_All;

Assembler symbols
<option>

ARM DDI 0487F.c
ID072120

Specifies the limitation on the barrier operation. Values are:
SY

Full system is the required shareability domain, reads and writes are the required access
types, both before and after the barrier instruction. This option is referred to as the full
system barrier. Encoded as CRm = 0b1111.

ST

Full system is the required shareability domain, writes are the required access type, both
before and after the barrier instruction. Encoded as CRm = 0b1110.

LD

Full system is the required shareability domain, reads are the required access type before
the barrier instruction, and reads and writes are the required access types after the barrier
instruction. Encoded as CRm = 0b1101.

ISH

Inner Shareable is the required shareability domain, reads and writes are the required
access types, both before and after the barrier instruction. Encoded as CRm = 0b1011.

ISHST

Inner Shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b1010.

ISHLD

Inner Shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b1001.

NSH

Non-shareable is the required shareability domain, reads and writes are the required
access, both before and after the barrier instruction. Encoded as CRm = 0b0111.

NSHST

Non-shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b0110.

NSHLD

Non-shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b0101.

OSH

Outer Shareable is the required shareability domain, reads and writes are the required
access types, both before and after the barrier instruction. Encoded as CRm = 0b0011.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-911

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

OSHST

Outer Shareable is the required shareability domain, writes are the required access type,
both before and after the barrier instruction. Encoded as CRm = 0b0010.

OSHLD

Outer Shareable is the required shareability domain, reads are the required access type
before the barrier instruction, and reads and writes are the required access types after the
barrier instruction. Encoded as CRm = 0b0001.

All other encodings of CRm, other than the values 0b0000 and 0b0100, that are not listed above are
reserved, and can be encoded using the #<imm> syntax. All unsupported and reserved options must
execute as a full system barrier operation, but software must not rely on this behavior. For more
information on whether an access is before or after a barrier instruction, see Data Memory Barrier
(DMB) on page B2-135 or see Data Synchronization Barrier (DSB) on page B2-138.

Note
The value 0b0000 is used to encode SSBB and the value 0b0100 is used to encode PSSBB.
Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.

<imm>

Operation
DataSynchronizationBarrier(domain, types);

C6-912

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.83

DVP
Data Value Prediction Restriction by Context prevents data value predictions, based on information gathered from
earlier execution within an particular execution context, from allowing later speculative execution within that
context to be observable through side-channels.
For more information, see DVP RCTX.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

12 11

8 7

5 4

1 1 0 1 0 1 0 1 0 0 0 0 1 0 1 1 0 1 1 1 0 0 1 1 1 0 1
L
op1
CRn
CRm
op2

0
Rt

Encoding
DVP RCTX, <Xt>

is equivalent to
SYS #3, C7, C3, #5, <Xt>

and is always the preferred disassembly.

Assembler symbols
Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

<Xt>

Operation
The description of SYS gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-913

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.84

EON (shifted register)
Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR NOT of a register value and an
optionally-shifted register value, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 0 1 0 1 0 shift 1
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
EON <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
EON <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

C6-914

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
operand2 = NOT(operand2);
result = operand1 EOR operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-915

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.85

EOR (immediate)
Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value,
and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
EOR <Wd|WSP>, <Wn>, #<imm>

64-bit variant
Applies when sf == 1.
EOR <Xd|SP>, <Xn>, #<imm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
if sf == '0' && N != '0' then UNDEFINED;
(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr".
For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr".

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
result = operand1 EOR imm;
if d == 31 then
SP[] = result;
else
X[d] = result;

C6-916

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-917

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.86

EOR (shifted register)
Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a register value and an
optionally-shifted register value, and writes the result to the destination register.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 0 1 0 1 0 shift 0
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
EOR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
EOR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

C6-918

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
result = operand1 EOR operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-919

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.87

ERET
Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores PSTATE
from the SPSR, and branches to the address held in the ELR.
The PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from
AArch64 state on page D1-2345.
ERET is UNDEFINED at EL0.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

5 4

0

1 1 0 1 0 1 1 0 1 0 0 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0
A M
Rn
op4

Encoding
ERET

Decode for this encoding
if PSTATE.EL == EL0 then UNDEFINED;

Operation
AArch64.CheckForERetTrap(FALSE, TRUE);
bits(64) target = ELR[];
AArch64.ExceptionReturn(target, SPSR[]);

C6-920

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.88

ERETAA, ERETAB
Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the
modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches
to the authenticated address.
Key A is used for ERETAA, and key B is used for ERETAB.
If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a
Translation fault is generated.
The authenticated address is not written back to ELR.
The PE checks the SPSR for the current Exception level for an illegal return event. See Illegal return events from
AArch64 state on page D1-2345.
ERETAA and ERETAB are UNDEFINED at EL0.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

5 4

0

1 1 0 1 0 1 1 0 1 0 0 1 1 1 1 1 0 0 0 0 1 M 1 1 1 1 1 1 1 1 1 1
A
Rn
op4

ERETAA variant
Applies when M == 0.
ERETAA

ERETAB variant
Applies when M == 1.
ERETAB

Decode for all variants of this encoding
if PSTATE.EL == EL0 then UNDEFINED;
boolean use_key_a = (M == '0');
if !HavePACExt() then
UNDEFINED;

Operation
AArch64.CheckForERetTrap(TRUE, use_key_a);
bits(64) target;
if use_key_a then
target = AuthIA(ELR[], SP[], TRUE);
else
target = AuthIB(ELR[], SP[], TRUE);
AArch64.ExceptionReturn(target, SPSR[]);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-921

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.89

ESB
Error Synchronization Barrier is an error synchronization event that might also update DISR_EL1 and
VDISR_EL2.
This instruction can be used at all Exception levels and in Debug state.
In Debug state, this instruction behaves as if SError interrupts are masked at all Exception levels. See Error
Synchronization Barrier in the Arm(R) Reliability, Availability, and Serviceability (RAS) Specification, Armv8, for
Armv8-A architecture profile.
If the RAS Extension is not implemented, this instruction executes as a NOP.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 1 1 1 1 1
CRm
op2

Encoding
ESB

Decode for this encoding
if !HaveRASExt() then EndOfInstruction();

Operation
SynchronizeErrors();
AArch64.ESBOperation();
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();
TakeUnmaskedSErrorInterrupts();

C6-922

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.90

EXTR
Extract register extracts a register from a pair of registers.
This instruction is used by the alias ROR (immediate). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 0 0 1 1 1 N 0

16 15
Rm

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0 && imms == 0xxxxx.
EXTR <Wd>, <Wn>, <Wm>, #<lsb>

64-bit variant
Applies when sf == 1 && N == 1.
EXTR <Xd>, <Xn>, <Xm>, #<lsb>

Decode for all variants of this encoding
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;
lsb;

if N != sf then UNDEFINED;
if sf == '0' && imms<5> == '1' then UNDEFINED;
lsb = UInt(imms);

Alias conditions
Alias

is preferred when

ROR (immediate)

Rn == Rm

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<lsb>

For the 32-bit variant: is the least significant bit position from which to extract, in the range 0 to 31,
encoded in the "imms" field.
For the 64-bit variant: is the least significant bit position from which to extract, in the range 0 to 63,
encoded in the "imms" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-923

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(2*datasize) concat = operand1:operand2;
result = concat<lsb+datasize-1:lsb>;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-924

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.91

GMI
Tag Mask Insert inserts the tag in the first source register into the excluded set specified in the second source register,
writing the new excluded set to the destination register.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Xm

0 0 0 1 0 1

5 4
Xn

0
Xd

Encoding
GMI <Xd>, <Xn|SP>, <Xm>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Xd" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Xn"
field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Xm" field.

Operation
bits(64) address = if n == 31 then SP[] else X[n];
bits(64) mask = X[m];
bits(4) tag = AArch64.AllocationTagFromAddress(address);
mask<UInt(tag)> = '1';
X[d] = mask;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-925

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.92

HINT
Hint instruction is for the instruction set space that is reserved for architectural hint instructions.
Some encodings described here are not allocated in this revision of the architecture, and behave as NOPs. These
encodings might be allocated to other hint functionality in future revisions of the architecture and therefore must
not be used by software.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0

8 7
CRm

5 4 3 2 1 0
op2

1 1 1 1 1

Encoding
HINT #<imm>

Decode for this encoding
SystemHintOp op;
case CRm:op2 of
when '0000 000' op = SystemHintOp_NOP;
when '0000 001' op = SystemHintOp_YIELD;
when '0000 010' op = SystemHintOp_WFE;
when '0000 011' op = SystemHintOp_WFI;
when '0000 100' op = SystemHintOp_SEV;
when '0000 101' op = SystemHintOp_SEVL;
when '0000 110'
if !HaveDGHExt() then EndOfInstruction();
// Instruction executes as NOP
op = SystemHintOp_DGH;
when '0000 111' SEE "XPACLRI";
when '0001 xxx'
case op2 of
when '000' SEE "PACIA1716";
when '010' SEE "PACIB1716";
when '100' SEE "AUTIA1716";
when '110' SEE "AUTIB1716";
otherwise EndOfInstruction();
when '0010 000'
if !HaveRASExt() then EndOfInstruction();
// Instruction executes as NOP
op = SystemHintOp_ESB;
when '0010 001'
if !HaveStatisticalProfiling() then EndOfInstruction();
// Instruction executes as NOP
op = SystemHintOp_PSB;
when '0010 010'
if !HaveSelfHostedTrace() then EndOfInstruction();
// Instruction executes as NOP
op = SystemHintOp_TSB;
when '0010 100'
op = SystemHintOp_CSDB;
when '0011 xxx'
case op2 of
when '000' SEE "PACIAZ";
when '001' SEE "PACIASP";
when '010' SEE "PACIBZ";
when '011' SEE "PACIBSP";
when '100' SEE "AUTIAZ";
when '101' SEE "AUTHASP";
when '110' SEE "AUTIBZ";
when '111' SEE "AUTIBSP";
when '0100 xx0'
op = SystemHintOp_BTI;

C6-926

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// Check branch target compatibility between BTI instruction and PSTATE.BTYPE
SetBTypeCompatible(BTypeCompatible_BTI(op2<2:1>));
otherwise EndOfInstruction();

Assembler symbols
Is a 7-bit unsigned immediate, in the range 0 to 127 encoded in the "CRm:op2" field.

<imm>

The encodings that are allocated to architectural hint functionality are described in the "Hints" table
in the "Index by Encoding".

Note
For allocated encodings of "CRm:op2":
•

A disassembler will disassemble the allocated instruction, rather than the HINT instruction.

•

An assembler may support assembly of allocated encodings using HINT with the
corresponding <imm> value, but it is not required to do so.

Operation
case op of
when SystemHintOp_YIELD
Hint_Yield();
when SystemHintOp_DGH
Hint_DGH();
when SystemHintOp_WFE
if IsEventRegisterSet() then
ClearEventRegister();
else
trap = FALSE;
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
if HaveTWEDExt() then
- = SCTLR[];
trap = sctlr.nTWE == '0';
target_el = EL1;
else
AArch64.CheckForWFxTrap(EL1, TRUE);
if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
if HaveTWEDExt() then
trap = HCR_EL2.TWE == '1';
target_el = EL2;
else
AArch64.CheckForWFxTrap(EL2, TRUE);
if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
if HaveTWEDExt() then
trap = SCR_EL3.TWE == '1';
target_el = EL3;
else
AArch64.CheckForWFxTrap(EL3, TRUE);
if HaveTWEDExt() && trap && PSTATE.EL != EL3 then
(delay_enabled, delay) = WFETrapDelay(target_el);

// (If trap delay is enabled, Delay

amount)
if !WaitForEventUntilDelay(delay_enabled, delay) then
// Event did not arrive before delay expired
AArch64.WFxTrap(target_el, TRUE);
// Trap WFE
else
WaitForEvent();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-927

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

when SystemHintOp_WFI
if !InterruptPending() then
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
AArch64.CheckForWFxTrap(EL1, FALSE);
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
AArch64.CheckForWFxTrap(EL2, FALSE);
if HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
AArch64.CheckForWFxTrap(EL3, FALSE);
WaitForInterrupt();
when SystemHintOp_SEV
SendEvent();
when SystemHintOp_SEVL
SendEventLocal();
when SystemHintOp_ESB
SynchronizeErrors();
AArch64.ESBOperation();
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();
TakeUnmaskedSErrorInterrupts();
when SystemHintOp_PSB
ProfilingSynchronizationBarrier();
when SystemHintOp_TSB
TraceSynchronizationBarrier();
when SystemHintOp_CSDB
ConsumptionOfSpeculativeDataBarrier();
when SystemHintOp_BTI
SetBTypeNext('00');
otherwise

C6-928

// do nothing

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.93

HLT
Halt instruction. An HLT instruction can generate a Halt Instruction debug event, which causes entry into Debug
state.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 0 1 0

5 4 3 2 1 0
imm16

0 0 0 0 0

Encoding
HLT #<imm>

Decode for this encoding
if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
if HaveBTIExt() then
SetBTypeCompatible(TRUE);

Assembler symbols
Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<imm>

Operation
Halt(DebugHalt_HaltInstruction);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-929

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.94

HVC
Hypervisor Call causes an exception to EL2. Non-secure software executing at EL1 can use this instruction to call
the hypervisor to request a service.
The HVC instruction is UNDEFINED:
•

At EL0.

•

At EL1 if EL2 is not enabled in the current Security state.

•

When SCR_EL3.HCE is set to 0.

On executing an HVC instruction, the PE records the exception as a Hypervisor Call exception in ESR_ELx, using
the EC value 0x16, and the value of the immediate argument.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 0 0 0

5 4 3 2 1 0
imm16

0 0 0 1 0

Encoding
HVC #<imm>

Decode for this encoding
// Empty.

Assembler symbols
Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<imm>

Operation
if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && (!IsSecureEL2Enabled() && IsSecure())) then
UNDEFINED;
hvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);
if hvc_enable == '0' then
UNDEFINED;
else
AArch64.CallHypervisor(imm16);

C6-930

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.95

IC
Instruction Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and
address translation instructions on page C5-377.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 1
L

16 15
op1

12 11

0 1 1 1
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
IC <ic_op>{, <Xt>}

is equivalent to
SYS #<op1>, C7, <Cm>, #<op2>{, <Xt>}

and is the preferred disassembly when SysOp(op1,'0111',CRm,op2) == Sys_IC.

Assembler symbols
Is an IC instruction name, as listed for the IC system instruction pages, encoded in the
"op1:CRm:op2" field. It can have the following values:

<ic_op>

IALLUIS

when op1 = 000, CRm = 0001, op2 = 000

IALLU

when op1 = 000, CRm = 0101, op2 = 000

IVAU

when op1 = 011, CRm = 0101, op2 = 001

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<Xt>

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
the "Rt" field.

Operation
The description of SYS gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-931

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.96

IRG
Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the
result to the destination register. Any tags specified in the optional second source register or in GCR_EL1.Exclude
are excluded from the selection of the random Logical Address Tag.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Xm

0 0 0 1 0 0

5 4
Xn

0
Xd

Encoding
IRG <Xd|SP>, <Xn|SP>{, <Xm>}

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

Assembler symbols
<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Xd"
field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Xn"
field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Xm" field.
Defaults to XZR if absent.

Operation
bits(64) operand = if n == 31 then SP[] else X[n];
bits(64) exclude_reg = X[m];
bits(16) exclude = exclude_reg<15:0> OR GCR_EL1.Exclude;
if AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then
if GCR_EL1.RRND == '1' then
rtag = _ChooseRandomNonExcludedTag(exclude);
else
bits(4) start = RGSR_EL1.TAG;
bits(4) offset = AArch64.RandomTag();
rtag = AArch64.ChooseNonExcludedTag(start, offset, exclude);
RGSR_EL1.TAG = rtag;
else
rtag = '0000';
bits(64) result = AArch64.AddressWithAllocationTag(operand, AccType_NORMAL, rtag);
if d == 31 then
SP[] = result;
else
X[d] = result;

C6-932

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.97

ISB
Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more
information, see Instruction Synchronization Barrier (ISB) on page B2-135.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1

8 7 6 5 4 3 2 1 0
CRm

1 1 0 1 1 1 1 1
opc

Encoding
ISB {<option>|#<imm>}

Decode for this encoding
// No additional decoding required

Assembler symbols
Specifies an optional limitation on the barrier operation. Values are:

<option>

SY

Full system barrier operation, encoded as CRm = 0b1111. Can be omitted.

All other encodings of CRm are reserved. The corresponding instructions execute as full system
barrier operations, but must not be relied upon by software.
Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the
"CRm" field.

<imm>

Operation
InstructionSynchronizationBarrier();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-933

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.98

LDADDB, LDADDAB, LDADDALB, LDADDLB
Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it,
and stores the result back to memory. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDADDAB and LDADDALB load from memory with acquire semantics.

•

LDADDLB and LDADDALB store to memory with release semantics.

•

LDADDB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STADDB, STADDLB. See Alias conditions on page C6-935 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0
Rt

LDADDAB variant
Applies when A == 1 && R == 0.
LDADDAB <Ws>, <Wt>, [<Xn|SP>]

LDADDALB variant
Applies when A == 1 && R == 1.
LDADDALB <Ws>, <Wt>, [<Xn|SP>]

LDADDB variant
Applies when A == 0 && R == 0.
LDADDB <Ws>, <Wt>, [<Xn|SP>]

LDADDLB variant
Applies when A == 0 && R == 1.
LDADDLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-934

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STADDB, STADDLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ADD, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-935

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.99

LDADDH, LDADDAH, LDADDALH, LDADDLH
Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a
register to it, and stores the result back to memory. The value initially loaded from memory is returned in the
destination register.
•

If the destination register is not WZR, LDADDAH and LDADDALH load from memory with acquire semantics.

•

LDADDLH and LDADDALH store to memory with release semantics.

•

LDADDH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STADDH, STADDLH. See Alias conditions on page C6-937 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0
Rt

LDADDAH variant
Applies when A == 1 && R == 0.
LDADDAH <Ws>, <Wt>, [<Xn|SP>]

LDADDALH variant
Applies when A == 1 && R == 1.
LDADDALH <Ws>, <Wt>, [<Xn|SP>]

LDADDH variant
Applies when A == 0 && R == 0.
LDADDH <Ws>, <Wt>, [<Xn|SP>]

LDADDLH variant
Applies when A == 0 && R == 1.
LDADDLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-936

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STADDH, STADDLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ADD, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-937

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.100

LDADD, LDADDA, LDADDAL, LDADDL
Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory,
adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDADDA and LDADDAL load from memory with acquire
semantics.

•

LDADDL and LDADDAL store to memory with release semantics.

•

LDADD has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STADD, STADDL. See Alias conditions on page C6-939 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0
Rt

32-bit LDADD variant
Applies when size == 10 && A == 0 && R == 0.
LDADD <Ws>, <Wt>, [<Xn|SP>]

32-bit LDADDA variant
Applies when size == 10 && A == 1 && R == 0.
LDADDA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDADDAL variant
Applies when size == 10 && A == 1 && R == 1.
LDADDAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDADDL variant
Applies when size == 10 && A == 0 && R == 1.
LDADDL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDADD variant
Applies when size == 11 && A == 0 && R == 0.
LDADD <Xs>, <Xt>, [<Xn|SP>]

64-bit LDADDA variant
Applies when size == 11 && A == 1 && R == 0.
LDADDA <Xs>, <Xt>, [<Xn|SP>]

C6-938

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDADDAL variant
Applies when size == 11 && A == 1 && R == 1.
LDADDAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDADDL variant
Applies when size == 11 && A == 0 && R == 1.
LDADDL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STADD, STADDL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ADD, value, ldacctype, stacctype);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-939

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-940

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.101

LDAPR
Load-Acquire RCpc Register derives an address from a base register value, loads a 32-bit word or 64-bit
doubleword from the derived address in memory, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14 13 12 11 10 9

1 x 1 1 1 0 0 0 1 0 1 (1) (1) (1) (1) (1) 1 1 0 0 0 0
size
Rs

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDAPR <Wt>, [<Xn|SP> {,#0}]

64-bit variant
Applies when size == 11.
LDAPR <Xt>, [<Xn|SP> {,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-941

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, dbytes, AccType_ORDERED];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-942

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.102

LDAPRB
Load-Acquire RCpc Register Byte derives an address from a base register value, loads a byte from the derived
address in memory, zero-extends it and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14 13 12 11 10 9

0 0 1 1 1 0 0 0 1 0 1 (1) (1) (1) (1) (1) 1 1 0 0 0 0
size
Rs

5 4
Rn

0
Rt

Encoding
LDAPRB <Wt>, [<Xn|SP> {,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 1, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-943

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-944

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.103

LDAPRH
Load-Acquire RCpc Register Halfword derives an address from a base register value, loads a halfword from the
derived address in memory, zero-extends it and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14 13 12 11 10 9

0 1 1 1 1 0 0 0 1 0 1 (1) (1) (1) (1) (1) 1 1 0 0 0 0
size
Rs

5 4
Rn

0
Rt

Encoding
LDAPRH <Wt>, [<Xn|SP> {,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 2, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-945

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-946

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.104

LDAPUR
Load-Acquire RCpc Register (unscaled) calculates an address from a base register and an immediate offset, loads
a 32-bit word or 64-bit doubleword from memory, zero-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
1 x 0 1 1 0 0 1 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDAPUR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
LDAPUR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer regsize;
regsize = if size == '11' then 64 else 32;
integer datasize = 8 << scale;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-947

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, datasize DIV 8, AccType_ORDERED];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-948

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.105

LDAPURB
Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base register and an immediate offset,
loads a byte from memory, zero-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 0 0 1 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDAPURB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-949

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

address = X[n];
address = address + offset;
data = Mem[address, 1, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-950

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.106

LDAPURH
Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base register and an immediate
offset, loads a halfword from memory, zero-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 0 0 1 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDAPURH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-951

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

address = X[n];
address = address + offset;
data = Mem[address, 2, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-952

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.107

LDAPURSB
Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a base register and an immediate
offset, loads a signed byte from memory, sign-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 0 0 1 1 x 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDAPURSB <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDAPURSB <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-953

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 1, AccType_ORDERED] = data;
when MemOp_LOAD
data = Mem[address, 1, AccType_ORDERED];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-954

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.108

LDAPURSH
Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from a base register and an
immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 0 0 1 1 x 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDAPURSH <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDAPURSH <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-955

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 2, AccType_ORDERED] = data;
when MemOp_LOAD
data = Mem[address, 2, AccType_ORDERED];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-956

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.109

LDAPURSW
Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a base register and an immediate
offset, loads a signed word from memory, sign-extends it, and writes it to a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139, except that:
•

There is no ordering requirement, separate from the requirements of a Load-AcquirePC or a Store-Release,
created by having a Store-Release followed by a Load-AcquirePC instruction.

•

The reading of a value written by a Store-Release by a Load-AcquirePC instruction by the same observer
does not make the write of the Store-Release globally observed.

This difference in memory ordering is not described in the pseudocode.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 0 1 1 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDAPURSW <Xt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(32) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-957

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

address = X[n];
address = address + offset;
data = Mem[address, 4, AccType_ORDERED];
X[t] = SignExtend(data, 64);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-958

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.110

LDAR
Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from
memory, and writes it to a register. The instruction also has memory ordering semantics as described in
Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDAR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
LDAR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-959

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

data = Mem[address, dbytes, AccType_ORDERED];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-960

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.111

LDARB
Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends
it and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire,
Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see Load/Store
addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDARB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 1, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-961

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.112

LDARH
Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory,
zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in
Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDARH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 2, AccType_ORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-962

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.113

LDAXP
Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or
two 64-bit doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be
doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be
quadword aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the
physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive
instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering
semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information
about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

1 sz 0 0 1 0 0 0 0 1 1 (1) (1) (1) (1) (1) 1
L
Rs
o0

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when sz == 0.
LDAXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]

64-bit variant
Applies when sz == 1.
LDAXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
integer elsize = 32 << UInt(sz);
integer datasize = elsize * 2;
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDAXP on page K1-7972.

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-963

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, dbytes);
if rt_unknown then
// ConstrainedUNPREDICTABLE case
X[t] = bits(datasize) UNKNOWN;
// In this case t = t2
elsif elsize == 32 then
// 32-bit load exclusive pair (atomic)
data = Mem[address, dbytes, AccType_ORDEREDATOMIC];
if BigEndian() then
X[t] = data<datasize-1:elsize>;
X[t2] = data<elsize-1:0>;
else
X[t] = data<elsize-1:0>;
X[t2] = data<datasize-1:elsize>;
else // elsize == 64
// 64-bit load exclusive pair (not atomic),
// but must be 128-bit aligned
if address != Align(address, dbytes) then
AArch64.Abort(address, AArch64.AlignmentFault(AccType_ORDEREDATOMIC, FALSE, FALSE));
X[t] = Mem[address, 8, AccType_ORDEREDATOMIC];
X[t2] = Mem[address+8, 8, AccType_ORDEREDATOMIC];

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-964

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.114

LDAXR
Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit
doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical
address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive
instructions. See Synchronization and semaphores on page B2-166. The instruction also has memory ordering
semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information
about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDAXR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
LDAXR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
//
//
//
//

ARM DDI 0487F.c
ID072120

Tell the Exclusives monitors to record a sequence of one or more atomic
memory reads from virtual address range [address, address+dbytes-1].
The Exclusives monitor will only be set if all the reads are from the
same dbytes-aligned physical address, to allow for the possibility of

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-965

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, dbytes);
data = Mem[address, dbytes, AccType_ORDEREDATOMIC];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-966

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.115

LDAXRB
Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory,
zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being
accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See
Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described
in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDAXRB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, 1);
data = Mem[address, 1, AccType_ORDEREDATOMIC];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-967

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.116

LDAXRH
Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from
memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address
being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See
Synchronization and semaphores on page B2-166. The instruction also has memory ordering semantics as described
in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory accesses see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDAXRH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, 2);
data = Mem[address, 2, AccType_ORDEREDATOMIC];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-968

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.117

LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB
Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the
complement of the value held in a register on it, and stores the result back to memory. The value initially loaded
from memory is returned in the destination register.
•

If the destination register is not WZR, LDCLRAB and LDCLRALB load from memory with acquire semantics.

•

LDCLRLB and LDCLRALB store to memory with release semantics.

•

LDCLRB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STCLRB, STCLRLB. See Alias conditions on page C6-970 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0
Rt

LDCLRAB variant
Applies when A == 1 && R == 0.
LDCLRAB <Ws>, <Wt>, [<Xn|SP>]

LDCLRALB variant
Applies when A == 1 && R == 1.
LDCLRALB <Ws>, <Wt>, [<Xn|SP>]

LDCLRB variant
Applies when A == 0 && R == 0.
LDCLRB <Ws>, <Wt>, [<Xn|SP>]

LDCLRLB variant
Applies when A == 0 && R == 1.
LDCLRLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-969

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STCLRB, STCLRLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_BIC, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-970

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.118

LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH
Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND
with the complement of the value held in a register on it, and stores the result back to memory. The value initially
loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDCLRAH and LDCLRALH load from memory with acquire semantics.

•

LDCLRLH and LDCLRALH store to memory with release semantics.

•

LDCLRH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STCLRH, STCLRLH. See Alias conditions on page C6-972 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0
Rt

LDCLRAH variant
Applies when A == 1 && R == 0.
LDCLRAH <Ws>, <Wt>, [<Xn|SP>]

LDCLRALH variant
Applies when A == 1 && R == 1.
LDCLRALH <Ws>, <Wt>, [<Xn|SP>]

LDCLRH variant
Applies when A == 0 && R == 0.
LDCLRH <Ws>, <Wt>, [<Xn|SP>]

LDCLRLH variant
Applies when A == 0 && R == 1.
LDCLRLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-971

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STCLRH, STCLRLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_BIC, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-972

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.119

LDCLR, LDCLRA, LDCLRAL, LDCLRL
Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from
memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result
back to memory. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL load from memory with acquire
semantics.

•

LDCLRL and LDCLRAL store to memory with release semantics.

•

LDCLR has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STCLR, STCLRL. See Alias conditions on page C6-974 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0
Rt

32-bit LDCLR variant
Applies when size == 10 && A == 0 && R == 0.
LDCLR <Ws>, <Wt>, [<Xn|SP>]

32-bit LDCLRA variant
Applies when size == 10 && A == 1 && R == 0.
LDCLRA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDCLRAL variant
Applies when size == 10 && A == 1 && R == 1.
LDCLRAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDCLRL variant
Applies when size == 10 && A == 0 && R == 1.
LDCLRL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDCLR variant
Applies when size == 11 && A == 0 && R == 0.
LDCLR <Xs>, <Xt>, [<Xn|SP>]

64-bit LDCLRA variant
Applies when size == 11 && A == 1 && R == 0.
LDCLRA <Xs>, <Xt>, [<Xn|SP>]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-973

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDCLRAL variant
Applies when size == 11 && A == 1 && R == 1.
LDCLRAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDCLRL variant
Applies when size == 11 && A == 0 && R == 1.
LDCLRL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STCLR, STCLRL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_BIC, value, ldacctype, stacctype);

C6-974

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-975

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.120

LDEORB, LDEORAB, LDEORALB, LDEORLB
Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive OR
with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory
is returned in the destination register.
•

If the destination register is not WZR, LDEORAB and LDEORALB load from memory with acquire semantics.

•

LDEORLB and LDEORALB store to memory with release semantics.

•

LDEORB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STEORB, STEORLB. See Alias conditions on page C6-977 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0
Rt

LDEORAB variant
Applies when A == 1 && R == 0.
LDEORAB <Ws>, <Wt>, [<Xn|SP>]

LDEORALB variant
Applies when A == 1 && R == 1.
LDEORALB <Ws>, <Wt>, [<Xn|SP>]

LDEORB variant
Applies when A == 0 && R == 0.
LDEORB <Ws>, <Wt>, [<Xn|SP>]

LDEORLB variant
Applies when A == 0 && R == 1.
LDEORLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-976

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STEORB, STEORLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_EOR, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-977

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.121

LDEORH, LDEORAH, LDEORALH, LDEORLH
Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an
exclusive OR with the value held in a register on it, and stores the result back to memory. The value initially loaded
from memory is returned in the destination register.
•

If the destination register is not WZR, LDEORAH and LDEORALH load from memory with acquire semantics.

•

LDEORLH and LDEORALH store to memory with release semantics.

•

LDEORH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STEORH, STEORLH. See Alias conditions on page C6-979 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0
Rt

LDEORAH variant
Applies when A == 1 && R == 0.
LDEORAH <Ws>, <Wt>, [<Xn|SP>]

LDEORALH variant
Applies when A == 1 && R == 1.
LDEORALH <Ws>, <Wt>, [<Xn|SP>]

LDEORH variant
Applies when A == 0 && R == 0.
LDEORH <Ws>, <Wt>, [<Xn|SP>]

LDEORLH variant
Applies when A == 0 && R == 1.
LDEORLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-978

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STEORH, STEORLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_EOR, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-979

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.122

LDEOR, LDEORA, LDEORAL, LDEORL
Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from
memory, performs an exclusive OR with the value held in a register on it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDEORA and LDEORAL load from memory with acquire
semantics.

•

LDEORL and LDEORAL store to memory with release semantics.

•

LDEOR has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STEOR, STEORL. See Alias conditions on page C6-981 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0
Rt

32-bit LDEOR variant
Applies when size == 10 && A == 0 && R == 0.
LDEOR <Ws>, <Wt>, [<Xn|SP>]

32-bit LDEORA variant
Applies when size == 10 && A == 1 && R == 0.
LDEORA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDEORAL variant
Applies when size == 10 && A == 1 && R == 1.
LDEORAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDEORL variant
Applies when size == 10 && A == 0 && R == 1.
LDEORL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDEOR variant
Applies when size == 11 && A == 0 && R == 0.
LDEOR <Xs>, <Xt>, [<Xn|SP>]

64-bit LDEORA variant
Applies when size == 11 && A == 1 && R == 0.
LDEORA <Xs>, <Xt>, [<Xn|SP>]

C6-980

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDEORAL variant
Applies when size == 11 && A == 1 && R == 1.
LDEORAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDEORL variant
Applies when size == 11 && A == 0 && R == 1.
LDEORL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STEOR, STEORL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_EOR, value, ldacctype, stacctype);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-981

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-982

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.123

LDG
Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the
Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base
register and an immediate signed offset scaled by the Tag granule.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 1 1

12 11 10 9
imm9

0 0

5 4
Xn

0
Xt

Encoding
LDG <Xt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer t = UInt(Xt);
integer n = UInt(Xn);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<simm>

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0
and encoded in the "imm9" field.

Operation
bits(64) address;
bits(4) tag;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
address = Align(address, TAG_GRANULE);
tag = AArch64.MemTag[address, AccType_NORMAL];
X[t] = AArch64.AddressWithAllocationTag(X[t], AccType_NORMAL, tag);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-983

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.124

LDGM
Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where the size of N is identified in
GMID_EL1.BS, and writes the Allocation Tag read from address A to the destination register at
4*A<7:4>+3:4*A<7:4>. Bits of the destination register not written with an Allocation Tag are set to 0.
This instruction is UNDEFINED at EL0.
This instruction generates an Unchecked access.
If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0

5 4
Xn

0
Xt

Encoding
LDGM <Xt>, [<Xn|SP>]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer t = UInt(Xt);
integer n = UInt(Xn);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

Operation
if PSTATE.EL == EL0 then
UNDEFINED;
bits(64) data = Zeros(64);
bits(64) address;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
integer
address
integer
integer

size = 4 * (2 ^ (UInt(GMID_EL1.BS)));
= Align(address, size);
count = size >> LOG2_TAG_GRANULE;
index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);

for i = 0 to count-1
bits(4) tag = AArch64.MemTag[address, AccType_NORMAL];
data<(index*4)+3:index*4> = tag;
address = address + TAG_GRANULE;
index = index + 1;
X[t] = data;

C6-984

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.125

LDLARB
Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction
also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For
information about memory accesses, see Load/Store addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDLARB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 1, AccType_LIMITEDORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-985

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.126

LDLARH
Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The
instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDLARH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = Mem[address, 2, AccType_LIMITEDORDERED];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-986

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.127

LDLAR
Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The
instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

Note
For this instruction, if the destination is WZR/XZR, it is impossible for software to observe the presence of the
acquire semantic other than its effect on the arrival at endpoints.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 1 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDLAR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
LDLAR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-987

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

data = Mem[address, dbytes, AccType_LIMITEDORDERED];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-988

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.128

LDNP
Load Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate
offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers.
For information about memory accesses, see Load/Store addressing modes on page C1-187. For information about
Non-temporal pair instructions, see Load/Store Non-temporal Pair on page C3-210.

31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 0 0 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 10.
LDNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
// Empty.

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDNP on page K1-7972.

Assembler symbols
<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc<0> == '1' then UNDEFINED;
integer scale = 2 + UInt(opc<1>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-989

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = n != 31;

Operation
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data1 = Mem[address, dbytes, AccType_STREAM];
data2 = Mem[address+dbytes, dbytes, AccType_STREAM];
if rt_unknown then
data1 = bits(datasize) UNKNOWN;
data2 = bits(datasize) UNKNOWN;
X[t] = data1;
X[t2] = data2;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-990

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.129

LDP
Load Pair of Registers calculates an address from a base register value and an immediate offset, loads two 32-bit
words or two 64-bit doublewords from memory, and writes them to two registers. For information about memory
accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 0 1 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>

64-bit variant
Applies when opc == 10.
LDP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;

Pre-index
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 1 1 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!

64-bit variant
Applies when opc == 10.
LDP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;

Signed offset
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 1 0 1
opc
L

ARM DDI 0487F.c
ID072120

15 14
imm7

10 9
Rt2

5 4
Rn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Rt

C6-991

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

32-bit variant
Applies when opc == 00.
LDP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 10.
LDP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDP on page K1-7973.

Assembler symbols
<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.
For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.
For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if L:opc<0> == '01' || opc == '11' then UNDEFINED;
boolean signed = (opc<0> != '0');
integer scale = 2 + UInt(opc<1>);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

Operation for all encodings
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;

C6-992

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
boolean wb_unknown = FALSE;
if wback && (t == n || t2 == n) && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data1 = Mem[address, dbytes, AccType_NORMAL];
data2 = Mem[address+dbytes, dbytes, AccType_NORMAL];
if rt_unknown then
data1 = bits(datasize) UNKNOWN;
data2 = bits(datasize) UNKNOWN;
if signed then
X[t] = SignExtend(data1, 64);
X[t2] = SignExtend(data2, 64);
else
X[t] = data1;
X[t2] = data2;
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-993

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.130

LDPSW
Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads
two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory
accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 0 1 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

Encoding
LDPSW <Xt1>, <Xt2>, [<Xn|SP>], #<imm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;

Pre-index
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 1 1 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

Encoding
LDPSW <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;

Signed offset
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 1 0 1
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

Encoding
LDPSW <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDPSW on page K1-7974.

C6-994

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Assembler symbols
<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the post-index and pre-index variant: is the signed immediate byte offset, a multiple of 4 in the
range -256 to 252, encoded in the "imm7" field as <imm>/4.
For the signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the
range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
bits(64) offset = LSL(SignExtend(imm7, 64), 2);
boolean tag_checked = wback || n != 31;

Operation for all encodings
bits(64) address;
bits(32) data1;
bits(32) data2;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
boolean wb_unknown = FALSE;
if wback && (t == n || t2 == n) && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data1 = Mem[address, 4, AccType_NORMAL];
data2 = Mem[address+4, 4, AccType_NORMAL];
if rt_unknown then
data1 = bits(32) UNKNOWN;
data2 = bits(32) UNKNOWN;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-995

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

X[t] = SignExtend(data1, 64);
X[t2] = SignExtend(data2, 64);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-996

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.131

LDR (immediate)
Load Register (immediate) loads a word or doubleword from memory and writes it to a register. The address that is
used for the load is calculated from a base register and an immediate offset. For information about memory accesses,
see Load/Store addressing modes on page C1-187. The Unsigned offset variant scales the immediate offset value
by the size of the value accessed before adding it to the base register value.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDR <Wt>, [<Xn|SP>], #<simm>

64-bit variant
Applies when size == 11.
LDR <Xt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDR <Wt>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when size == 11.
LDR <Xt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-997

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
1 x 1 1 1 0 0 1 0 1
size
opc

10 9
imm12

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDR <Wt>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when size == 11.
LDR <Xt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDR (immediate) on page K1-7974.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.
For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer regsize;
regsize = if size == '11' then 64 else 32;
integer datasize = 8 << scale;
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;

C6-998

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

boolean wb_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data = Mem[address, datasize DIV 8, AccType_NORMAL];
X[t] = ZeroExtend(data, regsize);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-999

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.132

LDR (literal)
Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory,
and writes it to a register. For information about memory accesses, see Load/Store addressing modes on
page C1-187.

31 30 29 28 27 26 25 24 23
0 x 0 1 1 0 0 0
opc

5 4
imm19

0
Rt

32-bit variant
Applies when opc == 00.
LDR <Wt>, <label>

64-bit variant
Applies when opc == 01.
LDR <Xt>, <label>

Decode for all variants of this encoding
integer t = UInt(Rt);
MemOp memop = MemOp_LOAD;
boolean signed = FALSE;
integer size;
bits(64) offset;
case opc of
when '00'
size = 4;
when '01'
size = 8;
when '10'
size = 4;
signed = TRUE;
when '11'
memop = MemOp_PREFETCH;
offset = SignExtend(imm19:'00', 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<label>

Is the program label from which the data is to be loaded. Its offset from the address of this
instruction, in the range +/-1MB, is encoded as "imm19" times 4.

Operation
bits(64) address = PC[] + offset;
bits(size*8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
case memop of

C6-1000

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

when MemOp_LOAD
data = Mem[address, size, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, 64);
else
X[t] = data;
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1001

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.133

LDR (register)
Load Register (register) calculates an address from a base register value and an offset register value, loads a word
from memory, and writes it to a register. The offset register value can optionally be shifted and extended. For
information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 1 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

64-bit variant
Applies when size == 11.
LDR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for all variants of this encoding
integer scale = UInt(size);
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:

<amount>

C6-1002

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

For the 32-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#2

when S = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 64-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#3

when S = 1

Shared decode for all encodings
integer
integer
integer
integer

n = UInt(Rn);
t = UInt(Rt);
m = UInt(Rm);
regsize;

regsize = if size == '11' then 64 else 32;
integer datasize = 8 << scale;

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, datasize DIV 8, AccType_NORMAL];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1003

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.134

LDRAA, LDRAB
Load Register, with pointer authentication. This instruction authenticates an address from a base register using a
modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit
doubleword from memory at this resulting address into a register.
Key A is used for LDRAA, and key B is used for LDRAB.
If the authentication passes, the PE behaves the same as for an LDR instruction. If the authentication fails, a
Translation fault is generated.
The authenticated address is not written back to the base register, unless the pre-indexed variant of the instruction
is used. In this case, the address that is written back to the base register does not include the pointer authentication
code.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20
1 1 1 1 1 0 0 0 M S 1
size

12 11 10 9
imm9

W 1

5 4
Rn

0
Rt

Key A, offset variant
Applies when M == 0 && W == 0.
LDRAA <Xt>, [<Xn|SP>{, #<simm>}]

Key A, pre-indexed variant
Applies when M == 0 && W == 1.
LDRAA <Xt>, [<Xn|SP>{, #<simm>}]!

Key B, offset variant
Applies when M == 1 && W == 0.
LDRAB <Xt>, [<Xn|SP>{, #<simm>}]

Key B, pre-indexed variant
Applies when M == 1 && W == 1.
LDRAB <Xt>, [<Xn|SP>{, #<simm>}]!

Decode for all variants of this encoding
if !HavePACExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
boolean wback = (W == '1');
boolean use_key_a = (M == '0');
bits(10) S10 = S:imm9;
bits(64) offset = LSL(SignExtend(S10, 64), 3);
boolean tag_checked = wback || n != 31;

Assembler symbols
<Xt>

C6-1004

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, a multiple of 8 in the range -4096 to 4088, defaulting
to 0 and encoded in the "S:imm9" field as <simm>/8.

Operation
bits(64) address;
bits(64) data;
boolean wb_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
address = SP[];
else
address = X[n];
if use_key_a then
address = AuthDA(address, X[31], TRUE);
else
address = AuthDB(address, X[31], TRUE);
if n == 31 then
CheckSPAlignment();
address = address + offset;
data = Mem[address, 8, AccType_NORMAL];
X[t] = data;
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1005

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.135

LDRB (immediate)
Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The
address that is used for the load is calculated from a base register and an immediate offset. For information about
memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

Encoding
LDRB <Wt>, [<Xn|SP>], #<simm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

Encoding
LDRB <Wt>, [<Xn|SP>, #<simm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 0 1 1 1 0 0 1 0 1
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
LDRB <Wt>, [<Xn|SP>{, #<pimm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 0);

C6-1006

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDRB (immediate) on page K1-7974.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
in the "imm12" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
boolean wb_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data = Mem[address, 1, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1007

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1008

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.136

LDRB (register)
Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a
byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 1 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Extended register variant
Applies when option != 011.
LDRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

Shifted register variant
Applies when option == 011.
LDRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

Decode for all variants of this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend specifier, encoded in the "option" field. It can have the following values:
UXTW

when option = 010

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, it must be #0, encoded in "S" as 0 if omitted, or as 1 if present.

<amount>

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

Operation
bits(64) offset = ExtendReg(m, extend_type, 0);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1009

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 1, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1010

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.137

LDRH (immediate)
Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a
register. The address that is used for the load is calculated from a base register and an immediate offset. For
information about memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

Encoding
LDRH <Wt>, [<Xn|SP>], #<simm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

Encoding
LDRH <Wt>, [<Xn|SP>, #<simm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 1 1 1 1 0 0 1 0 1
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
LDRH <Wt>, [<Xn|SP>{, #<pimm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 1);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1011

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDRH (immediate) on page K1-7975.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
and encoded in the "imm12" field as <pimm>/2.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
boolean wb_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data = Mem[address, 2, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1012

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1013

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.138

LDRH (register)
Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads
a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 1 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Encoding
LDRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then 1 else 0;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:

<amount>

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, optional only when <extend> is not LSL. Where it is permitted to be
optional, it defaults to #0. It is encoded in the "S" field. It can have the following values:
#0

when S = 0

#1

when S = 1

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

C6-1014

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 2, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1015

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.139

LDRSB (immediate)
Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and
writes the result to a register. The address that is used for the load is calculated from a base register and an immediate
offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDRSB <Wt>, [<Xn|SP>], #<simm>

64-bit variant
Applies when opc == 10.
LDRSB <Xt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDRSB <Wt>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when opc == 10.
LDRSB <Xt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 0 1 1 1 0 0 1 1 x
size
opc

C6-1016

10 9
imm12

5 4
Rn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Rt

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

32-bit variant
Applies when opc == 11.
LDRSB <Wt>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when opc == 10.
LDRSB <Xt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 0);

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDRSB (immediate) on
page K1-7975.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
in the "imm12" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1017

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;
if memop == MemOp_LOAD && wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if memop == MemOp_STORE && wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is original value
when Constraint_UNKNOWN rt_unknown = TRUE;
// value stored is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
case memop of
when MemOp_STORE
if rt_unknown then
data = bits(8) UNKNOWN;
else
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 1, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1018

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.140

LDRSB (register)
Load Register Signed Byte (register) calculates an address from a base register value and an offset register value,
loads a byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 1 x 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

32-bit with extended register offset variant
Applies when opc == 11 && option != 011.
LDRSB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

32-bit with shifted register offset variant
Applies when opc == 11 && option == 011.
LDRSB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

64-bit with extended register offset variant
Applies when opc == 10 && option != 011.
LDRSB <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

64-bit with shifted register offset variant
Applies when opc == 10 && option == 011.
LDRSB <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

Decode for all variants of this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

<amount>

ARM DDI 0487F.c
ID072120

Is the index extend specifier, encoded in the "option" field. It can have the following values:
UXTW

when option = 010

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, it must be #0, encoded in "S" as 0 if omitted, or as 1 if present.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1019

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH;

Operation
bits(64) offset = ExtendReg(m, extend_type, 0);
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 1, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1020

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.141

LDRSH (immediate)
Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits,
and writes the result to a register. The address that is used for the load is calculated from a base register and an
immediate offset. For information about memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDRSH <Wt>, [<Xn|SP>], #<simm>

64-bit variant
Applies when opc == 10.
LDRSH <Xt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDRSH <Wt>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when opc == 10.
LDRSH <Xt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 1 1 1 1 0 0 1 1 x
size
opc

ARM DDI 0487F.c
ID072120

10 9
imm12

5 4
Rn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Rt

C6-1021

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

32-bit variant
Applies when opc == 11.
LDRSH <Wt>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when opc == 10.
LDRSH <Xt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 1);

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDRSH (immediate) on
page K1-7976.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
and encoded in the "imm12" field as <pimm>/2.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;

C6-1022

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;
if memop == MemOp_LOAD && wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if memop == MemOp_STORE && wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is original value
when Constraint_UNKNOWN rt_unknown = TRUE;
// value stored is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
case memop of
when MemOp_STORE
if rt_unknown then
data = bits(16) UNKNOWN;
else
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 2, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1023

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.142

LDRSH (register)
Load Register Signed Halfword (register) calculates an address from a base register value and an offset register
value, loads a halfword from memory, sign-extends it, and writes it to a register. For information about memory
accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 1 x 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDRSH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

64-bit variant
Applies when opc == 10.
LDRSH <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for all variants of this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then 1 else 0;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:

<amount>

C6-1024

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, optional only when <extend> is not LSL. Where it is permitted to be
optional, it defaults to #0. It is encoded in the "S" field. It can have the following values:
#0

when S = 0

#1

when S = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH;

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 2, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1025

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.143

LDRSW (immediate)
Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result
to a register. The address that is used for the load is calculated from a base register and an immediate offset. For
information about memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 0 0 1 0 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

Encoding
LDRSW <Xt>, [<Xn|SP>], #<simm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 0 0 1 0 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

Encoding
LDRSW <Xt>, [<Xn|SP>, #<simm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
1 0 1 1 1 0 0 1 1 0
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
LDRSW <Xt>, [<Xn|SP>{, #<pimm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 2);

C6-1026

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDRSW (immediate) on
page K1-7976.

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to
0 and encoded in the "imm12" field as <pimm>/4.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(32) data;
boolean wb_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_WBSUPPRESS wback = FALSE;
// writeback is suppressed
when Constraint_UNKNOWN
wb_unknown = TRUE;
// writeback is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data = Mem[address, 4, AccType_NORMAL];
X[t] = SignExtend(data, 64);
if wback then
if wb_unknown then
address = bits(64) UNKNOWN;
elsif postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1027

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1028

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.144

LDRSW (literal)
Load Register Signed Word (literal) calculates an address from the PC value and an immediate offset, loads a word
from memory, and writes it to a register. For information about memory accesses, see Load/Store addressing modes
on page C1-187.

31 30 29 28 27 26 25 24 23
1 0 0 1 1 0 0 0
opc

5 4
imm19

0
Rt

Encoding
LDRSW <Xt>, <label>

Decode for this encoding
integer t = UInt(Rt);
bits(64) offset;
offset = SignExtend(imm19:'00', 64);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<label>

Is the program label from which the data is to be loaded. Its offset from the address of this
instruction, in the range +/-1MB, is encoded as "imm19" times 4.

Operation
bits(64) address = PC[] + offset;
bits(32) data;
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
data = Mem[address, 4, AccType_NORMAL];
X[t] = SignExtend(data, 64);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1029

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.145

LDRSW (register)
Load Register Signed Word (register) calculates an address from a base register value and an offset register value,
loads a word from memory, sign-extends it to form a 64-bit value, and writes it to a register. The offset register value
can be shifted left by 0 or 2 bits. For information about memory accesses, see Load/Store addressing modes on
page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 0 0 1 0 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Encoding
LDRSW <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then 2 else 0;

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:
UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, optional only when <extend> is not LSL. Where it is permitted to be
optional, it defaults to #0. It is encoded in the "S" field. It can have the following values:

<amount>

#0

when S = 0

#2

when S = 1

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);

C6-1030

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

bits(64) address;
bits(32) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 4, AccType_NORMAL];
X[t] = SignExtend(data, 64);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1031

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.146

LDSETB, LDSETAB, LDSETALB, LDSETLB
Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value
held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in
the destination register.
•

If the destination register is not WZR, LDSETAB and LDSETALB load from memory with acquire semantics.

•

LDSETLB and LDSETALB store to memory with release semantics.

•

LDSETB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSETB, STSETLB. See Alias conditions on page C6-1033 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0
Rt

LDSETAB variant
Applies when A == 1 && R == 0.
LDSETAB <Ws>, <Wt>, [<Xn|SP>]

LDSETALB variant
Applies when A == 1 && R == 1.
LDSETALB <Ws>, <Wt>, [<Xn|SP>]

LDSETB variant
Applies when A == 0 && R == 0.
LDSETB <Ws>, <Wt>, [<Xn|SP>]

LDSETLB variant
Applies when A == 0 && R == 1.
LDSETLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1032

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSETB, STSETLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ORR, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1033

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.147

LDSETH, LDSETAH, LDSETALH, LDSETLH
Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with
the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is
returned in the destination register.
•

If the destination register is not WZR, LDSETAH and LDSETALH load from memory with acquire semantics.

•

LDSETLH and LDSETALH store to memory with release semantics.

•

LDSETH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSETH, STSETLH. See Alias conditions on page C6-1035 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0
Rt

LDSETAH variant
Applies when A == 1 && R == 0.
LDSETAH <Ws>, <Wt>, [<Xn|SP>]

LDSETALH variant
Applies when A == 1 && R == 1.
LDSETALH <Ws>, <Wt>, [<Xn|SP>]

LDSETH variant
Applies when A == 0 && R == 0.
LDSETH <Ws>, <Wt>, [<Xn|SP>]

LDSETLH variant
Applies when A == 0 && R == 1.
LDSETLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1034

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSETH, STSETLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ORR, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1035

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.148

LDSET, LDSETA, LDSETAL, LDSETL
Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from
memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The
value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDSETA and LDSETAL load from memory with acquire
semantics.

•

LDSETL and LDSETAL store to memory with release semantics.

•

LDSET has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSET, STSETL. See Alias conditions on page C6-1037 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0
Rt

32-bit LDSET variant
Applies when size == 10 && A == 0 && R == 0.
LDSET <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSETA variant
Applies when size == 10 && A == 1 && R == 0.
LDSETA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSETAL variant
Applies when size == 10 && A == 1 && R == 1.
LDSETAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSETL variant
Applies when size == 10 && A == 0 && R == 1.
LDSETL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDSET variant
Applies when size == 11 && A == 0 && R == 0.
LDSET <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSETA variant
Applies when size == 11 && A == 1 && R == 0.
LDSETA <Xs>, <Xt>, [<Xn|SP>]

C6-1036

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSETAL variant
Applies when size == 11 && A == 1 && R == 1.
LDSETAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSETL variant
Applies when size == 11 && A == 0 && R == 1.
LDSETL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STSET, STSETL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_ORR, value, ldacctype, stacctype);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1037

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1038

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.149

LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB
Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the
value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value
initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from memory with acquire semantics.

•

LDSMAXLB and LDSMAXALB store to memory with release semantics.

•

LDSMAXB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMAXB, STSMAXLB. See Alias conditions on page C6-1040 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0
Rt

LDSMAXAB variant
Applies when A == 1 && R == 0.
LDSMAXAB <Ws>, <Wt>, [<Xn|SP>]

LDSMAXALB variant
Applies when A == 1 && R == 1.
LDSMAXALB <Ws>, <Wt>, [<Xn|SP>]

LDSMAXB variant
Applies when A == 0 && R == 0.
LDSMAXB <Ws>, <Wt>, [<Xn|SP>]

LDSMAXLB variant
Applies when A == 0 && R == 1.
LDSMAXLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1039

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSMAXB, STSMAXLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMAX, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1040

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.150

LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH
Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it
against the value held in a register, and stores the larger value back to memory, treating the values as signed
numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from memory with acquire semantics.

•

LDSMAXLH and LDSMAXALH store to memory with release semantics.

•

LDSMAXH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMAXH, STSMAXLH. See Alias conditions on page C6-1042 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0
Rt

LDSMAXAH variant
Applies when A == 1 && R == 0.
LDSMAXAH <Ws>, <Wt>, [<Xn|SP>]

LDSMAXALH variant
Applies when A == 1 && R == 1.
LDSMAXALH <Ws>, <Wt>, [<Xn|SP>]

LDSMAXH variant
Applies when A == 0 && R == 0.
LDSMAXH <Ws>, <Wt>, [<Xn|SP>]

LDSMAXLH variant
Applies when A == 0 && R == 1.
LDSMAXLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1041

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSMAXH, STSMAXLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMAX, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1042

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.151

LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL
Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword
from memory, compares it against the value held in a register, and stores the larger value back to memory, treating
the values as signed numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL load from memory with acquire
semantics.

•

LDSMAXL and LDSMAXAL store to memory with release semantics.

•

LDSMAX has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMAX, STSMAXL. See Alias conditions on page C6-1044 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0
Rt

32-bit LDSMAX variant
Applies when size == 10 && A == 0 && R == 0.
LDSMAX <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMAXA variant
Applies when size == 10 && A == 1 && R == 0.
LDSMAXA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMAXAL variant
Applies when size == 10 && A == 1 && R == 1.
LDSMAXAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMAXL variant
Applies when size == 10 && A == 0 && R == 1.
LDSMAXL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDSMAX variant
Applies when size == 11 && A == 0 && R == 0.
LDSMAX <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSMAXA variant
Applies when size == 11 && A == 1 && R == 0.
LDSMAXA <Xs>, <Xt>, [<Xn|SP>]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1043

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSMAXAL variant
Applies when size == 11 && A == 1 && R == 1.
LDSMAXAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSMAXL variant
Applies when size == 11 && A == 0 && R == 1.
LDSMAXL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STSMAX, STSMAXL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMAX, value, ldacctype, stacctype);

C6-1044

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1045

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.152

LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB
Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the
value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The
value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDSMINAB and LDSMINALB load from memory with acquire semantics.

•

LDSMINLB and LDSMINALB store to memory with release semantics.

•

LDSMINB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMINB, STSMINLB. See Alias conditions on page C6-1047 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0
Rt

LDSMINAB variant
Applies when A == 1 && R == 0.
LDSMINAB <Ws>, <Wt>, [<Xn|SP>]

LDSMINALB variant
Applies when A == 1 && R == 1.
LDSMINALB <Ws>, <Wt>, [<Xn|SP>]

LDSMINB variant
Applies when A == 0 && R == 0.
LDSMINB <Ws>, <Wt>, [<Xn|SP>]

LDSMINLB variant
Applies when A == 0 && R == 1.
LDSMINLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1046

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSMINB, STSMINLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMIN, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1047

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.153

LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH
Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it
against the value held in a register, and stores the smaller value back to memory, treating the values as signed
numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDSMINAH and LDSMINALH load from memory with acquire semantics.

•

LDSMINLH and LDSMINALH store to memory with release semantics.

•

LDSMINH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMINH, STSMINLH. See Alias conditions on page C6-1049 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0
Rt

LDSMINAH variant
Applies when A == 1 && R == 0.
LDSMINAH <Ws>, <Wt>, [<Xn|SP>]

LDSMINALH variant
Applies when A == 1 && R == 1.
LDSMINALH <Ws>, <Wt>, [<Xn|SP>]

LDSMINH variant
Applies when A == 0 && R == 0.
LDSMINH <Ws>, <Wt>, [<Xn|SP>]

LDSMINLH variant
Applies when A == 0 && R == 1.
LDSMINLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1048

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STSMINH, STSMINLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMIN, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1049

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.154

LDSMIN, LDSMINA, LDSMINAL, LDSMINL
Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword
from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating
the values as signed numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL load from memory with acquire
semantics.

•

LDSMINL and LDSMINAL store to memory with release semantics.

•

LDSMIN has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STSMIN, STSMINL. See Alias conditions on page C6-1051 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0
Rt

32-bit LDSMIN variant
Applies when size == 10 && A == 0 && R == 0.
LDSMIN <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMINA variant
Applies when size == 10 && A == 1 && R == 0.
LDSMINA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMINAL variant
Applies when size == 10 && A == 1 && R == 1.
LDSMINAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDSMINL variant
Applies when size == 10 && A == 0 && R == 1.
LDSMINL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDSMIN variant
Applies when size == 11 && A == 0 && R == 0.
LDSMIN <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSMINA variant
Applies when size == 11 && A == 1 && R == 0.
LDSMINA <Xs>, <Xt>, [<Xn|SP>]

C6-1050

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSMINAL variant
Applies when size == 11 && A == 1 && R == 1.
LDSMINAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDSMINL variant
Applies when size == 11 && A == 0 && R == 1.
LDSMINL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STSMIN, STSMINL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_SMIN, value, ldacctype, stacctype);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1051

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1052

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.155

LDTR
Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that
is used for the load is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDTR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
LDTR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1053

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

integer regsize;
regsize = if size == '11' then 64 else 32;
integer datasize = 8 << scale;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, datasize DIV 8, acctype];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1054

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.156

LDTRB
Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The
address that is used for the load is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

Encoding
LDTRB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1055

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 1, acctype];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1056

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.157

LDTRH
Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a
register. The address that is used for the load is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

Encoding
LDTRH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1057

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 2, acctype];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1058

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.158

LDTRSB
Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes
the result to a register. The address that is used for the load is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDTRSB <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDTRSB <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
MemOp memop;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1059

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 1, acctype] = data;
when MemOp_LOAD
data = Mem[address, 1, acctype];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1060

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.159

LDTRSH
Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits,
and writes the result to a register. The address that is used for the load is calculated from a base register and an
immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDTRSH <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDTRSH <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1061

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 2, acctype] = data;
when MemOp_LOAD
data = Mem[address, 2, acctype];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1062

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.160

LDTRSW
Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the
result to a register. The address that is used for the load is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 0 0 1 0 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

Encoding
LDTRSW <Xt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(32) data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1063

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 4, acctype];
X[t] = SignExtend(data, 64);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1064

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.161

LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB
Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against
the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers.
The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from memory with acquire semantics.

•

LDUMAXLB and LDUMAXALB store to memory with release semantics.

•

LDUMAXB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMAXB, STUMAXLB. See Alias conditions on page C6-1066 for details
of when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0
Rt

LDUMAXAB variant
Applies when A == 1 && R == 0.
LDUMAXAB <Ws>, <Wt>, [<Xn|SP>]

LDUMAXALB variant
Applies when A == 1 && R == 1.
LDUMAXALB <Ws>, <Wt>, [<Xn|SP>]

LDUMAXB variant
Applies when A == 0 && R == 0.
LDUMAXB <Ws>, <Wt>, [<Xn|SP>]

LDUMAXLB variant
Applies when A == 0 && R == 1.
LDUMAXLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1065

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STUMAXB, STUMAXLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMAX, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1066

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.162

LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH
Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it
against the value held in a register, and stores the larger value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from memory with acquire semantics.

•

LDUMAXLH and LDUMAXALH store to memory with release semantics.

•

LDUMAXH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMAXH, STUMAXLH. See Alias conditions on page C6-1068 for details
of when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0
Rt

LDUMAXAH variant
Applies when A == 1 && R == 0.
LDUMAXAH <Ws>, <Wt>, [<Xn|SP>]

LDUMAXALH variant
Applies when A == 1 && R == 1.
LDUMAXALH <Ws>, <Wt>, [<Xn|SP>]

LDUMAXH variant
Applies when A == 0 && R == 0.
LDUMAXH <Ws>, <Wt>, [<Xn|SP>]

LDUMAXLH variant
Applies when A == 0 && R == 1.
LDUMAXLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1067

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STUMAXH, STUMAXLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMAX, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1068

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.163

LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL
Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword
from memory, compares it against the value held in a register, and stores the larger value back to memory, treating
the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL load from memory with acquire
semantics.

•

LDUMAXL and LDUMAXAL store to memory with release semantics.

•

LDUMAX has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMAX, STUMAXL. See Alias conditions on page C6-1070 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0
Rt

32-bit LDUMAX variant
Applies when size == 10 && A == 0 && R == 0.
LDUMAX <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMAXA variant
Applies when size == 10 && A == 1 && R == 0.
LDUMAXA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMAXAL variant
Applies when size == 10 && A == 1 && R == 1.
LDUMAXAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMAXL variant
Applies when size == 10 && A == 0 && R == 1.
LDUMAXL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDUMAX variant
Applies when size == 11 && A == 0 && R == 0.
LDUMAX <Xs>, <Xt>, [<Xn|SP>]

64-bit LDUMAXA variant
Applies when size == 11 && A == 1 && R == 0.
LDUMAXA <Xs>, <Xt>, [<Xn|SP>]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1069

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDUMAXAL variant
Applies when size == 11 && A == 1 && R == 1.
LDUMAXAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDUMAXL variant
Applies when size == 11 && A == 0 && R == 1.
LDUMAXL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STUMAX, STUMAXL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMAX, value, ldacctype, stacctype);

C6-1070

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1071

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.164

LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB
Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the
value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The
value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDUMINAB and LDUMINALB load from memory with acquire semantics.

•

LDUMINLB and LDUMINALB store to memory with release semantics.

•

LDUMINB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMINB, STUMINLB. See Alias conditions on page C6-1073 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0
Rt

LDUMINAB variant
Applies when A == 1 && R == 0.
LDUMINAB <Ws>, <Wt>, [<Xn|SP>]

LDUMINALB variant
Applies when A == 1 && R == 1.
LDUMINALB <Ws>, <Wt>, [<Xn|SP>]

LDUMINB variant
Applies when A == 0 && R == 0.
LDUMINB <Ws>, <Wt>, [<Xn|SP>]

LDUMINLB variant
Applies when A == 0 && R == 1.
LDUMINLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1072

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STUMINB, STUMINLB

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) value;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMIN, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1073

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.165

LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH
Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it
against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned
numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, LDUMINAH and LDUMINALH load from memory with acquire semantics.

•

LDUMINLH and LDUMINALH store to memory with release semantics.

•

LDUMINH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMINH, STUMINLH. See Alias conditions on page C6-1075 for details of
when each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0
Rt

LDUMINAH variant
Applies when A == 1 && R == 0.
LDUMINAH <Ws>, <Wt>, [<Xn|SP>]

LDUMINALH variant
Applies when A == 1 && R == 1.
LDUMINALH <Ws>, <Wt>, [<Xn|SP>]

LDUMINH variant
Applies when A == 0 && R == 0.
LDUMINH <Ws>, <Wt>, [<Xn|SP>]

LDUMINLH variant
Applies when A == 0 && R == 1.
LDUMINLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

C6-1074

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

is preferred when

STUMINH, STUMINLH

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) value;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMIN, value, ldacctype, stacctype);
if t != 31 then
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1075

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.166

LDUMIN, LDUMINA, LDUMINAL, LDUMINL
Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword
from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating
the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL load from memory with acquire
semantics.

•

LDUMINL and LDUMINAL store to memory with release semantics.

•

LDUMIN has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is used by the alias STUMIN, STUMINL. See Alias conditions on page C6-1077 for details of when
each alias is preferred.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0
Rt

32-bit LDUMIN variant
Applies when size == 10 && A == 0 && R == 0.
LDUMIN <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMINA variant
Applies when size == 10 && A == 1 && R == 0.
LDUMINA <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMINAL variant
Applies when size == 10 && A == 1 && R == 1.
LDUMINAL <Ws>, <Wt>, [<Xn|SP>]

32-bit LDUMINL variant
Applies when size == 10 && A == 0 && R == 1.
LDUMINL <Ws>, <Wt>, [<Xn|SP>]

64-bit LDUMIN variant
Applies when size == 11 && A == 0 && R == 0.
LDUMIN <Xs>, <Xt>, [<Xn|SP>]

64-bit LDUMINA variant
Applies when size == 11 && A == 1 && R == 0.
LDUMINA <Xs>, <Xt>, [<Xn|SP>]

C6-1076

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDUMINAL variant
Applies when size == 11 && A == 1 && R == 1.
LDUMINAL <Xs>, <Xt>, [<Xn|SP>]

64-bit LDUMINL variant
Applies when size == 11 && A == 0 && R == 1.
LDUMINL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Alias conditions
Alias

is preferred when

STUMIN, STUMINL

A == '0' && Rt == '11111'

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) value;
bits(datasize) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
value = X[s];
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = MemAtomic(address, MemAtomicOp_UMIN, value, ldacctype, stacctype);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1077

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if t != 31 then
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1078

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.167

LDUR
Load Register (unscaled) calculates an address from a base register and an immediate offset, loads a 32-bit word or
64-bit doubleword from memory, zero-extends it, and writes it to a register. For information about memory accesses,
see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDUR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
LDUR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer regsize;
regsize = if size == '11' then 64 else 32;
integer datasize = 8 << scale;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1079

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

address = X[n];
address = address + offset;
data = Mem[address, datasize DIV 8, AccType_NORMAL];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1080

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.168

LDURB
Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from
memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store
addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDURB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 1, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1081

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.169

LDURH
Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a
halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 1 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDURH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 2, AccType_NORMAL];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1082

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.170

LDURSB
Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a
signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDURSB <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDURSB <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1083

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 1, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1084

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.171

LDURSH
Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads
a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses,
see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 1 x 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 11.
LDURSH <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when opc == 10.
LDURSH <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop;
boolean signed;
integer regsize;
if opc<1> == '0' then
// store or zero-extending load
memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
regsize = 32;
signed = FALSE;
else
// sign-extending load
memop = MemOp_LOAD;
regsize = if opc<0> == '1' then 32 else 64;
signed = TRUE;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1085

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
if memop != MemOp_PREFETCH then CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;
when MemOp_LOAD
data = Mem[address, 2, AccType_NORMAL];
if signed then
X[t] = SignExtend(data, regsize);
else
X[t] = ZeroExtend(data, regsize);
when MemOp_PREFETCH
Prefetch(address, t<4:0>);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1086

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.172

LDURSW
Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a
signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 0 0 1 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
LDURSW <Xt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(32) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = Mem[address, 4, AccType_NORMAL];
X[t] = SignExtend(data, 64);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1087

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.173

LDXP
Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit
doublewords from memory, and writes them to two registers. A 32-bit pair requires the address to be doubleword
aligned and is single-copy atomic at doubleword granularity. A 64-bit pair requires the address to be quadword
aligned and is single-copy atomic for each doubleword at doubleword granularity. The PE marks the physical
address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive
instructions. See Synchronization and semaphores on page B2-166. For information about memory accesses see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

1 sz 0 0 1 0 0 0 0 1 1 (1) (1) (1) (1) (1) 0
L
Rs
o0

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when sz == 0.
LDXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]

64-bit variant
Applies when sz == 1.
LDXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
integer elsize = 32 << UInt(sz);
integer datasize = elsize * 2;
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDXP on page K1-7976.

Assembler symbols

C6-1088

<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, dbytes);
if rt_unknown then
// ConstrainedUNPREDICTABLE case
X[t] = bits(datasize) UNKNOWN;
// In this case t = t2
elsif elsize == 32 then
// 32-bit load exclusive pair (atomic)
data = Mem[address, dbytes, AccType_ATOMIC];
if BigEndian() then
X[t] = data<datasize-1:elsize>;
X[t2] = data<elsize-1:0>;
else
X[t] = data<elsize-1:0>;
X[t2] = data<datasize-1:elsize>;
else // elsize == 64
// 64-bit load exclusive pair (not atomic),
// but must be 128-bit aligned
if address != Align(address, dbytes) then
AArch64.Abort(address, AArch64.AlignmentFault(AccType_ATOMIC, FALSE, FALSE));
X[t] = Mem[address, 8, AccType_ATOMIC];
X[t2] = Mem[address+8, 8, AccType_ATOMIC];

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1089

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.174

LDXR
Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword
from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being
accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See
Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store
addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
LDXR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
LDXR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
//
//
//
//
//

C6-1090

Tell the Exclusives monitors to record a sequence of one or more atomic
memory reads from virtual address range [address, address+dbytes-1].
The Exclusives monitor will only be set if all the reads are from the
same dbytes-aligned physical address, to allow for the possibility of
an atomicity break if the translation is changed between reads.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

AArch64.SetExclusiveMonitors(address, dbytes);
data = Mem[address, dbytes, AccType_ATOMIC];
X[t] = ZeroExtend(data, regsize);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1091

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.175

LDXRB
Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends
it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an
exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and
semaphores on page B2-166. For information about memory accesses see Load/Store addressing modes on
page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDXRB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, 1);
data = Mem[address, 1, AccType_ATOMIC];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1092

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.176

LDXRH
Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory,
zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being
accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See
Synchronization and semaphores on page B2-166. For information about memory accesses see Load/Store
addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 0 1 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
LDXRH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
// Tell the Exclusives monitors to record a sequence of one or more atomic
// memory reads from virtual address range [address, address+dbytes-1].
// The Exclusives monitor will only be set if all the reads are from the
// same dbytes-aligned physical address, to allow for the possibility of
// an atomicity break if the translation is changed between reads.
AArch64.SetExclusiveMonitors(address, 2);
data = Mem[address, 2, AccType_ATOMIC];
X[t] = ZeroExtend(data, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1093

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.177

LSL (register)
Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the
result to the destination register. The remainder obtained by dividing the second source register by the data size
defines the number of bits by which the first source register is left-shifted.
This instruction is an alias of the LSLV instruction. This means that:
•

The encodings in this description are named to match the encodings of LSLV.

•

The description of LSLV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
LSL <Wd>, <Wn>, <Wm>

is equivalent to
LSLV <Wd>, <Wn>, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
LSL <Xd>, <Xn>, <Xm>

is equivalent to
LSLV <Xd>, <Xn>, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
The description of LSLV gives the operational pseudocode for this instruction.

C6-1094

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1095

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.178

LSL (immediate)
Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and
writes the result to the destination register.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0 && imms != 011111.
LSL <Wd>, <Wn>, #<shift>

is equivalent to
UBFM <Wd>, <Wn>, #(-<shift> MOD 32), #(31-<shift>)

and is the preferred disassembly when imms + 1 == immr.
64-bit variant
Applies when sf == 1 && N == 1 && imms != 111111.
LSL <Xd>, <Xn>, #<shift>

is equivalent to
UBFM <Xd>, <Xn>, #(-<shift> MOD 64), #(63-<shift>)

and is the preferred disassembly when imms + 1 == immr.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<shift>

For the 32-bit variant: is the shift amount, in the range 0 to 31.
For the 64-bit variant: is the shift amount, in the range 0 to 63.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

C6-1096

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1097

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.179

LSLV
Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the
result to the destination register. The remainder obtained by dividing the second source register by the data size
defines the number of bits by which the first source register is left-shifted.
This instruction is used by the alias LSL (register). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
LSLV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
LSLV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ShiftType shift_type = DecodeShift(op2);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand2 = X[m];
result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
X[d] = result;

C6-1098

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1099

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.180

LSR (register)
Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes
the result to the destination register. The remainder obtained by dividing the second source register by the data size
defines the number of bits by which the first source register is right-shifted.
This instruction is an alias of the LSRV instruction. This means that:
•

The encodings in this description are named to match the encodings of LSRV.

•

The description of LSRV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
LSR <Wd>, <Wn>, <Wm>

is equivalent to
LSRV <Wd>, <Wn>, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
LSR <Xd>, <Xn>, <Xm>

is equivalent to
LSRV <Xd>, <Xn>, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
The description of LSRV gives the operational pseudocode for this instruction.

C6-1100

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1101

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.181

LSR (immediate)
Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and
writes the result to the destination register.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9

x 1 1 1 1 1
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0 && imms == 011111.
LSR <Wd>, <Wn>, #<shift>

is equivalent to
UBFM <Wd>, <Wn>, #<shift>, #31

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1 && N == 1 && imms == 111111.
LSR <Xd>, <Xn>, #<shift>

is equivalent to
UBFM <Xd>, <Xn>, #<shift>, #63

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<shift>

For the 32-bit variant: is the shift amount, in the range 0 to 31, encoded in the "immr" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the "immr" field.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

C6-1102

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1103

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.182

LSRV
Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes
the result to the destination register. The remainder obtained by dividing the second source register by the data size
defines the number of bits by which the first source register is right-shifted.
This instruction is used by the alias LSR (register). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
LSRV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
LSRV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ShiftType shift_type = DecodeShift(op2);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand2 = X[m];
result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
X[d] = result;

C6-1104

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1105

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.183

MADD
Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination
register.
This instruction is used by the alias MUL. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 1 0 0 0

16 15 14
Rm

0
o0

10 9
Ra

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MADD <Wd>, <Wn>, <Wm>, <Wa>

64-bit variant
Applies when sf == 1.
MADD <Xd>, <Xn>, <Xm>, <Xa>

Decode for all variants of this encoding
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
a = UInt(Ra);
destsize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

MUL

Ra == '11111'

Assembler symbols

C6-1106

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Wa>

Is the 32-bit name of the third general-purpose source register holding the addend, encoded in the
"Ra" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
"Ra" field.

<Xa>

Operation
bits(destsize) operand1 = X[n];
bits(destsize) operand2 = X[m];
bits(destsize) operand3 = X[a];
integer result;
result = UInt(operand3) + (UInt(operand1) * UInt(operand2));
X[d] = result<destsize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1107

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.184

MNEG
Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register.
This instruction is an alias of the MSUB instruction. This means that:
•

The encodings in this description are named to match the encodings of MSUB.

•

The description of MSUB gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 1 0 0 0

16 15 14
Rm

10 9

1 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MNEG <Wd>, <Wn>, <Wm>

is equivalent to
MSUB <Wd>, <Wn>, <Wm>, WZR

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
MNEG <Xd>, <Xn>, <Xm>

is equivalent to
MSUB <Xd>, <Xn>, <Xm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of MSUB gives the operational pseudocode for this instruction.

C6-1108

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1109

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.185

MOV (to/from SP)
Move between register and stack pointer : Rd = Rn
This instruction is an alias of the ADD (immediate) instruction. This means that:
•

The encodings in this description are named to match the encodings of ADD (immediate).

•

The description of ADD (immediate) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

10 9

sf 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
op S
sh
imm12

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MOV <Wd|WSP>, <Wn|WSP>

is equivalent to
ADD <Wd|WSP>, <Wn|WSP>, #0

and is the preferred disassembly when (Rd == '11111' || Rn == '11111').
64-bit variant
Applies when sf == 1.
MOV <Xd|SP>, <Xn|SP>

is equivalent to
ADD <Xd|SP>, <Xn|SP>, #0

and is the preferred disassembly when (Rd == '11111' || Rn == '11111').

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

Operation
The description of ADD (immediate) gives the operational pseudocode for this instruction.

C6-1110

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.186

MOV (inverted wide immediate)
Move (inverted wide immediate) moves an inverted 16-bit immediate value to a register.
This instruction is an alias of the MOVN instruction. This means that:
•

The encodings in this description are named to match the encodings of MOVN.

•

The description of MOVN gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 0 0 1 0 1
opc

hw

5 4
imm16

0
Rd

32-bit variant
Applies when sf == 0 && hw == 0x.
MOV <Wd>, #<imm>

is equivalent to
MOVN <Wd>, #<imm16>, LSL #<shift>

and is the preferred disassembly when ! (IsZero(imm16) && hw != '00') && ! IsOnes(imm16).
64-bit variant
Applies when sf == 1.
MOV <Xd>, #<imm>

is equivalent to
MOVN <Xd>, #<imm16>, LSL #<shift>

and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<imm>

For the 32-bit variant: is a 32-bit immediate, the bitwise inverse of which can be encoded in
"imm16:hw", but excluding 0xffff0000 and 0x0000ffff
For the 64-bit variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in
"imm16:hw".
For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
16, encoded in the "hw" field as <shift>/16.

<shift>

For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
32 or 48, encoded in the "hw" field as <shift>/16.

Operation
The description of MOVN gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1111

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1112

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.187

MOV (wide immediate)
Move (wide immediate) moves a 16-bit immediate value to a register.
This instruction is an alias of the MOVZ instruction. This means that:
•

The encodings in this description are named to match the encodings of MOVZ.

•

The description of MOVZ gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 0 0 1 0 1
opc

hw

5 4
imm16

0
Rd

32-bit variant
Applies when sf == 0 && hw == 0x.
MOV <Wd>, #<imm>

is equivalent to
MOVZ <Wd>, #<imm16>, LSL #<shift>

and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').
64-bit variant
Applies when sf == 1.
MOV <Xd>, #<imm>

is equivalent to
MOVZ <Xd>, #<imm16>, LSL #<shift>

and is the preferred disassembly when ! (IsZero(imm16) && hw != '00').

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<imm>

For the 32-bit variant: is a 32-bit immediate which can be encoded in "imm16:hw".
For the 64-bit variant: is a 64-bit immediate which can be encoded in "imm16:hw".
For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
16, encoded in the "hw" field as <shift>/16.

<shift>

For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
32 or 48, encoded in the "hw" field as <shift>/16.

Operation
The description of MOVZ gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1113

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1114

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.188

MOV (bitmask immediate)
Move (bitmask immediate) writes a bitmask immediate value to a register.
This instruction is an alias of the ORR (immediate) instruction. This means that:
•

The encodings in this description are named to match the encodings of ORR (immediate).

•

The description of ORR (immediate) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4

1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
MOV <Wd|WSP>, #<imm>

is equivalent to
ORR <Wd|WSP>, WZR, #<imm>

and is the preferred disassembly when ! MoveWidePreferred(sf, N, imms, immr).
64-bit variant
Applies when sf == 1.
MOV <Xd|SP>, #<imm>

is equivalent to
ORR <Xd|SP>, XZR, #<imm>

and is the preferred disassembly when ! MoveWidePreferred(sf, N, imms, immr).

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<imm>

For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr", but excluding values
which could be encoded by MOVZ or MOVN.
For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr", but excluding values
which could be encoded by MOVZ or MOVN.

Operation
The description of ORR (immediate) gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1115

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1116

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.189

MOV (register)
Move (register) copies the value in a source register to the destination register.
This instruction is an alias of the ORR (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ORR (shifted register).

•

The description of ORR (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 0 0 0 0
opc
shift N

16 15
Rm

10 9

5 4

0 0 0 0 0 0 1 1 1 1 1
imm6
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MOV <Wd>, <Wm>

is equivalent to
ORR <Wd>, WZR, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
MOV <Xd>, <Xm>

is equivalent to
ORR <Xd>, XZR, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

Operation
The description of ORR (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1117

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

C6-1118

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.190

MOVK
Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits
unchanged.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 1 0 0 1 0 1
opc

hw

5 4
imm16

0
Rd

32-bit variant
Applies when sf == 0 && hw == 0x.
MOVK <Wd>, #<imm>{, LSL #<shift>}

64-bit variant
Applies when sf == 1.
MOVK <Xd>, #<imm>{, LSL #<shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer datasize = if sf == '1' then 64 else 32;
integer pos;
if sf == '0' && hw<1> == '1' then UNDEFINED;
pos = UInt(hw:'0000');

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<imm>

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<shift>

For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
16, encoded in the "hw" field as <shift>/16.
For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
32 or 48, encoded in the "hw" field as <shift>/16.

Operation
bits(datasize) result;
result = X[d];
result<pos+15:pos> = imm16;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1119

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

C6-1120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.191

MOVN
Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register.
This instruction is used by the alias MOV (inverted wide immediate). See Alias conditions for details of when each
alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 0 0 1 0 1
opc

5 4

hw

imm16

0
Rd

32-bit variant
Applies when sf == 0 && hw == 0x.
MOVN <Wd>, #<imm>{, LSL #<shift>}

64-bit variant
Applies when sf == 1.
MOVN <Xd>, #<imm>{, LSL #<shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer datasize = if sf == '1' then 64 else 32;
integer pos;
if sf == '0' && hw<1> == '1' then UNDEFINED;
pos = UInt(hw:'0000');

Alias conditions
Alias

of variant

is preferred when

MOV (inverted wide immediate)

64-bit

! (IsZero(imm16) && hw != '00')

MOV (inverted wide immediate)

32-bit

! (IsZero(imm16) && hw != '00') && ! IsOnes(imm16)

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<imm>

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<shift>

For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
16, encoded in the "hw" field as <shift>/16.
For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
32 or 48, encoded in the "hw" field as <shift>/16.

Operation
bits(datasize) result;
result = Zeros();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1121

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

result<pos+15:pos> = imm16;
result = NOT(result);
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1122

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.192

MOVZ
Move wide with zero moves an optionally-shifted 16-bit immediate value to a register.
This instruction is used by the alias MOV (wide immediate). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 0 0 1 0 1
opc

5 4

hw

imm16

0
Rd

32-bit variant
Applies when sf == 0 && hw == 0x.
MOVZ <Wd>, #<imm>{, LSL #<shift>}

64-bit variant
Applies when sf == 1.
MOVZ <Xd>, #<imm>{, LSL #<shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer datasize = if sf == '1' then 64 else 32;
integer pos;
if sf == '0' && hw<1> == '1' then UNDEFINED;
pos = UInt(hw:'0000');

Alias conditions
Alias

is preferred when

MOV (wide immediate)

! (IsZero(imm16) && hw != '00')

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<imm>

Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<shift>

For the 32-bit variant: is the amount by which to shift the immediate left, either 0 (the default) or
16, encoded in the "hw" field as <shift>/16.
For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16,
32 or 48, encoded in the "hw" field as <shift>/16.

Operation
bits(datasize) result;
result = Zeros();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1123

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

result<pos+15:pos> = imm16;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1124

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.193

MRS
Move System Register allows the PE to read an AArch64 System register into a general-purpose register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 1 1 o0
L

16 15
op1

12 11
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
MRS <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)

Decode for this encoding
AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
integer t = UInt(Rt);
integer
integer
integer
integer
integer

sys_op0
sys_op1
sys_op2
sys_crn
sys_crm

=
=
=
=
=

2 + UInt(o0);
UInt(op1);
UInt(op2);
UInt(CRn);
UInt(CRm);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rt" field.

<systemreg>

Is a System register name, encoded in the "o0:op1:CRn:CRm:op2".
The System register names are defined in Chapter D13 AArch64 System Register Descriptions.
Is an unsigned immediate, encoded in the "o0" field. It can have the following values:

<op0>

2

when o0 = 0

3

when o0 = 1

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cn>

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

Operation
X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1125

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.194

MSR (immediate)
Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more
information, see PSTATE.
The bits that can be written by this instruction are:
•

PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP.

•

If FEAT_SSBS is implemented, PSTATE.SSBS.

•

If FEAT_PAN is implemented, PSTATE.PAN.

•

If FEAT_UAO is implemented, PSTATE.UAO.

•

If FEAT_DIT is implemented, PSTATE.DIT.

•

If FEAT_MTE is implemented, PSTATE.TCO.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 0

16 15 14 13 12 11
op1

0 1 0 0

8 7
CRm

5 4 3 2 1 0
op2

1 1 1 1 1

Encoding
MSR <pstatefield>, #<imm>

Decode for this encoding
if op1 == '000' && op2 == '000' then SEE "CFINV";
if op1 == '000' && op2 == '001' then SEE "XAFLAG";
if op1 == '000' && op2 == '010' then SEE "AXFLAG";
AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');
PSTATEField field;
case op1:op2 of
when '000 011'
if !HaveUAOExt() then
UNDEFINED;
field = PSTATEField_UAO;
when '000 100'
if !HavePANExt() then
UNDEFINED;
field = PSTATEField_PAN;
when '000 101' field = PSTATEField_SP;
when '011 010'
if !HaveDITExt() then
UNDEFINED;
field = PSTATEField_DIT;
when '011 100'
if !HaveMTEExt() then
UNDEFINED;
field = PSTATEField_TCO;
when '011 110' field = PSTATEField_DAIFSet;
when '011 111' field = PSTATEField_DAIFClr;
when '011 001'
if !HaveSSBSExt() then
UNDEFINED;
field = PSTATEField_SSBS;
otherwise UNDEFINED;

C6-1126

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted
if PSTATE.EL == EL0 && field IN {PSTATEField_DAIFSet, PSTATEField_DAIFClr} then
if !ELUsingAArch32(EL1) && ((EL2Enabled() && HCR_EL2.<E2H,TGE> == '11') || SCTLR_EL1.UMA == '0')
then
if EL2Enabled() && !ELUsingAArch32(EL2) && HCR_EL2.TGE == '1' then
AArch64.SystemAccessTrap(EL2, 0x18);
else
AArch64.SystemAccessTrap(EL1, 0x18);

Assembler symbols
<pstatefield> Is a PSTATE field name, encoded in the "op1:op2" field. It can have the following values:
SPSel

when op1 = 000, op2 = 101

DAIFSet

when op1 = 011, op2 = 110

DAIFClr

when op1 = 011, op2 = 111

When FEAT_UAO is implemented, the following value is also valid:
UAO

when op1 = 000, op2 = 011

When FEAT_PAN is implemented, the following value is also valid:
PAN

when op1 = 000, op2 = 100

When FEAT_SSBS is implemented, the following value is also valid:
SSBS

when op1 = 011, op2 = 001

When FEAT_DIT is implemented, the following value is also valid:
DIT

when op1 = 011, op2 = 010

When FEAT_MTE is implemented, the following value is also valid:
TCO

when op1 = 011, op2 = 100

See PSTATE on page C4-274 when op1 = 000, op2 = 00x.
See PSTATE on page C4-274 when op1 = 000, op2 = 010.
The following encodings are reserved:
•

op1 = 000, op2 = 11x.

•

op1 = 001, op2 = xxx.

•

op1 = 010, op2 = xxx.

•

op1 = 011, op2 = 000.

•

op1 = 011, op2 = 011.

•

op1 = 011, op2 = 101.

•

op1 = 1xx, op2 = xxx.

Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the "CRm" field.

<imm>

Operation
case field of
when PSTATEField_SSBS
PSTATE.SSBS = CRm<0>;
when PSTATEField_SP
PSTATE.SP = CRm<0>;
when PSTATEField_DAIFSet
PSTATE.D = PSTATE.D OR CRm<3>;
PSTATE.A = PSTATE.A OR CRm<2>;
PSTATE.I = PSTATE.I OR CRm<1>;
PSTATE.F = PSTATE.F OR CRm<0>;
when PSTATEField_DAIFClr
PSTATE.D = PSTATE.D AND NOT(CRm<3>);
PSTATE.A = PSTATE.A AND NOT(CRm<2>);
PSTATE.I = PSTATE.I AND NOT(CRm<1>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1127

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

PSTATE.F = PSTATE.F AND NOT(CRm<0>);
when PSTATEField_PAN
PSTATE.PAN = CRm<0>;
when PSTATEField_UAO
PSTATE.UAO = CRm<0>;
when PSTATEField_DIT
PSTATE.DIT = CRm<0>;
when PSTATEField_TCO
PSTATE.TCO = CRm<0>;

C6-1128

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.195

MSR (register)
Move general-purpose register to System Register allows the PE to write an AArch64 System register from a
general-purpose register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 1 o0
L

16 15
op1

12 11
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
MSR (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>

Decode for this encoding
AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);
integer t = UInt(Rt);
integer
integer
integer
integer
integer

sys_op0
sys_op1
sys_op2
sys_crn
sys_crm

=
=
=
=
=

2 + UInt(o0);
UInt(op1);
UInt(op2);
UInt(CRn);
UInt(CRm);

Assembler symbols
<systemreg>

Is a System register name, encoded in the "o0:op1:CRn:CRm:op2".
The System register names are defined in Chapter D13 AArch64 System Register Descriptions.
Is an unsigned immediate, encoded in the "o0" field. It can have the following values:

<op0>

2

when o0 = 0

3

when o0 = 1

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cn>

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<Xt>

Is the 64-bit name of the general-purpose source register, encoded in the "Rt" field.

Operation
AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1129

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.196

MSUB
Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the
result to the destination register.
This instruction is used by the alias MNEG. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 1 0 0 0

16 15 14
Rm

1
o0

10 9
Ra

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MSUB <Wd>, <Wn>, <Wm>, <Wa>

64-bit variant
Applies when sf == 1.
MSUB <Xd>, <Xn>, <Xm>, <Xa>

Decode for all variants of this encoding
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
a = UInt(Ra);
destsize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

MNEG

Ra == '11111'

Assembler symbols

C6-1130

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Wa>

Is the 32-bit name of the third general-purpose source register holding the minuend, encoded in the
"Ra" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
"Ra" field.

<Xa>

Operation
bits(destsize) operand1 = X[n];
bits(destsize) operand2 = X[m];
bits(destsize) operand3 = X[a];
integer result;
result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
X[d] = result<destsize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1131

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.197

MUL
Multiply : Rd = Rn * Rm
This instruction is an alias of the MADD instruction. This means that:
•

The encodings in this description are named to match the encodings of MADD.

•

The description of MADD gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 1 0 0 0

16 15 14
Rm

10 9

0 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MUL <Wd>, <Wn>, <Wm>

is equivalent to
MADD <Wd>, <Wn>, <Wm>, WZR

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
MUL <Xd>, <Xn>, <Xm>

is equivalent to
MADD <Xd>, <Xn>, <Xm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of MADD gives the operational pseudocode for this instruction.

C6-1132

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.198

MVN
Bitwise NOT writes the bitwise inverse of a register value to the destination register.
This instruction is an alias of the ORN (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ORN (shifted register).

•

The description of ORN (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 0 shift 1
opc
N

16 15
Rm

10 9
imm6

5 4

1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0.
MVN <Wd>, <Wm>{, <shift> #<amount>}

is equivalent to
ORN <Wd>, WZR, <Wm>{, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
MVN <Xd>, <Xm>{, <shift> #<amount>}

is equivalent to
ORN <Xd>, XZR, <Xm>{, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1133

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of ORN (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1134

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.199

NEG (shifted register)
Negate (shifted register) negates an optionally-shifted register value, and writes the result to the destination register.
This instruction is an alias of the SUB (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of SUB (shifted register).

•

The description of SUB (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4

1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0.
NEG <Wd>, <Wm>{, <shift> #<amount>}

is equivalent to
SUB

<Wd>, WZR, <Wm> {, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
NEG <Xd>, <Xm>{, <shift> #<amount>}

is equivalent to
SUB

<Xd>, XZR, <Xm> {, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
<amount>

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1135

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of SUB (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1136

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.200

NEGS
Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It
updates the condition flags based on the result.
This instruction is an alias of the SUBS (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of SUBS (shifted register).

•

The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4

1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0.
NEGS <Wd>, <Wm>{, <shift> #<amount>}

is equivalent to
SUBS <Wd>, WZR, <Wm> {, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
NEGS <Xd>, <Xm>{, <shift> #<amount>}

is equivalent to
SUBS <Xd>, XZR, <Xm> {, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
<amount>

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1137

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of SUBS (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1138

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.201

NGC
Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to
the destination register.
This instruction is an alias of the SBC instruction. This means that:
•

The encodings in this description are named to match the encodings of SBC.

•

The description of SBC gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

5 4

0 0 0 0 0 0 1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0.
NGC <Wd>, <Wm>

is equivalent to
SBC <Wd>, WZR, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
NGC <Xd>, <Xm>

is equivalent to
SBC <Xd>, XZR, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

Operation
The description of SBC gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1139

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

C6-1140

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.202

NGCS
Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes
the result to the destination register. It updates the condition flags based on the result.
This instruction is an alias of the SBCS instruction. This means that:
•

The encodings in this description are named to match the encodings of SBCS.

•

The description of SBCS gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

5 4

0 0 0 0 0 0 1 1 1 1 1
Rn

0
Rd

32-bit variant
Applies when sf == 0.
NGCS <Wd>, <Wm>

is equivalent to
SBCS <Wd>, WZR, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
NGCS <Xd>, <Xm>

is equivalent to
SBCS <Xd>, XZR, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wm>

Is the 32-bit name of the general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xm>

Is the 64-bit name of the general-purpose source register, encoded in the "Rm" field.

Operation
The description of SBCS gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1141

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

C6-1142

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.203

NOP
No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used
for instruction alignment purposes.

Note
The timing effects of including a NOP instruction in a program are not guaranteed. It can increase execution time,
leave it unchanged, or even reduce it. Therefore, NOP instructions are not suitable for timing loops.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1
CRm
op2

Encoding
NOP

Decode for this encoding
// Empty.

Operation
// do nothing

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1143

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.204

ORN (shifted register)
Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a register value and the complement of an
optionally-shifted register value, and writes the result to the destination register.
This instruction is used by the alias MVN. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 0 shift 1
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ORN <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
ORN <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

MVN

Rn == '11111'

Assembler symbols

C6-1144

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
operand2 = NOT(operand2);
result = operand1 OR operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1145

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.205

ORR (immediate)
Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate register value, and
writes the result to the destination register.
This instruction is used by the alias MOV (bitmask immediate). See Alias conditions for details of when each alias
is preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 0 1 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
ORR <Wd|WSP>, <Wn>, #<imm>

64-bit variant
Applies when sf == 1.
ORR <Xd|SP>, <Xn>, #<imm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
if sf == '0' && N != '0' then UNDEFINED;
(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

Alias conditions
Alias

is preferred when

MOV (bitmask immediate)

Rn == '11111' && ! MoveWidePreferred(sf, N, imms, immr)

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr".
For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr".

C6-1146

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
result = operand1 OR imm;
if d == 31 then
SP[] = result;
else
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1147

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.206

ORR (shifted register)
Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register
value, and writes the result to the destination register.
This instruction is used by the alias MOV (register). See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 1 0 1 0 1 0 shift 0
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ORR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
ORR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

MOV (register)

shift == '00' && imm6 == '000000' && Rn == '11111'

Assembler symbols

C6-1148

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:
LSL

when shift = 00

LSR

when shift = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
result = operand1 OR operand2;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1149

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.207

PACDA, PACDZA
Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer
authentication code for a data address, using a modifier and key A.
The address is in the general-purpose register that is specified by <Xd>.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACDA.

•

The value zero, for PACDZA.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 0 1 0

5 4
Rn

0
Rd

PACDA variant
Applies when Z == 0.
PACDA <Xd>, <Xn|SP>

PACDZA variant
Applies when Z == 1 && Rn == 11111.
PACDZA <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // PACDA
if n == 31 then source_is_sp = TRUE;
else // PACDZA
if n != 31 then UNDEFINED;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation
if source_is_sp then
X[d] = AddPACDA(X[d], SP[]);
else
X[d] = AddPACDA(X[d], X[n]);

C6-1150

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.208

PACDB, PACDZB
Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer
authentication code for a data address, using a modifier and key B.
The address is in the general-purpose register that is specified by <Xd>.
The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACDB.

•

The value zero, for PACDZB.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 0 1 1

5 4
Rn

0
Rd

PACDB variant
Applies when Z == 0.
PACDB <Xd>, <Xn|SP>

PACDZB variant
Applies when Z == 1 && Rn == 11111.
PACDZB <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // PACDB
if n == 31 then source_is_sp = TRUE;
else // PACDZB
if n != 31 then UNDEFINED;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation
if source_is_sp then
X[d] = AddPACDB(X[d], SP[]);
else
X[d] = AddPACDB(X[d], X[n]);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1151

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.209

PACGA
Pointer Authentication Code, using Generic key. This instruction computes the pointer authentication code for an
address in the first source register, using a modifier in the second source register, and the Generic key. The computed
pointer authentication code is returned in the upper 32 bits of the destination register.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 0

5 4
Rn

0
Rd

Encoding
PACGA <Xd>, <Xn>, <Xm|SP>

Decode for this encoding
boolean
integer
integer
integer

source_is_sp = FALSE;
d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);

if !HavePACExt() then
UNDEFINED;
if m == 31 then source_is_sp = TRUE;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm|SP>

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the
"Rm" field.

Operation
if source_is_sp then
X[d] = AddPACGA(X[n], SP[]);
else
X[d] = AddPACGA(X[n], X[m]);

C6-1152

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.210

PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA
Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer
authentication code for an instruction address, using a modifier and key A.
The address is:
•

In the general-purpose register that is specified by <Xd> for PACIA and PACIZA.

•

In X17, for PACIA1716.

•

In X30, for PACIASP and PACIAZ.

The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACIA.

•

The value zero, for PACIZA and PACIAZ.

•

In X16, for PACIA1716.

•

In SP, for PACIASP.

Integer
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 0 0 0

5 4
Rn

0
Rd

PACIA variant
Applies when Z == 0.
PACIA <Xd>, <Xn|SP>

PACIZA variant
Applies when Z == 1 && Rn == 11111.
PACIZA <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // PACIA
if n == 31 then source_is_sp = TRUE;
else // PACIZA
if n != 31 then UNDEFINED;

System
ARMv8.3

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1153

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 x 1 0 0 x 1 1 1 1 1
CRm
op2

PACIA1716 variant
Applies when CRm == 0001 && op2 == 000.
PACIA1716

PACIASP variant
Applies when CRm == 0011 && op2 == 001.
PACIASP

PACIAZ variant
Applies when CRm == 0011 && op2 == 000.
PACIAZ

Decode for all variants of this encoding
integer d;
integer n;
boolean source_is_sp = FALSE;
case CRm:op2 of
when '0011 000'
// PACIAZ
d = 30;
n = 31;
when '0011 001'
// PACIASP
d = 30;
source_is_sp = TRUE;
if HaveBTIExt() then
// Check for branch target compatibility between PSTATE.BTYPE
// and implicit branch target of PACIASP instruction.
SetBTypeCompatible(BTypeCompatible_PACIXSP());
when '0001 000'
// PACIA1716
d = 17;
n = 16;
when '0001 010' SEE "PACIB";
when '0001 100' SEE "AUTIA";
when '0001 110' SEE "AUTIB";
when '0011 01x' SEE "PACIB";
when '0011 10x' SEE "AUTIA";
when '0011 11x' SEE "AUTIB";
when '0000 111' SEE "XPACLRI";
otherwise SEE "HINT";

Assembler symbols

C6-1154

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation for all encodings
if HavePACExt() then
if source_is_sp then
X[d] = AddPACIA(X[d], SP[]);
else
X[d] = AddPACIA(X[d], X[n]);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1155

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.211

PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB
Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer
authentication code for an instruction address, using a modifier and key B.
The address is:
•

In the general-purpose register that is specified by <Xd> for PACIB and PACIZB.

•

In X17, for PACIB1716.

•

In X30, for PACIBSP and PACIBZ.

The modifier is:
•

In the general-purpose register or stack pointer that is specified by <Xn|SP> for PACIB.

•

The value zero, for PACIZB and PACIBZ.

•

In X16, for PACIB1716.

•

In SP, for PACIBSP.

Integer
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 Z 0 0 1

5 4
Rn

0
Rd

PACIB variant
Applies when Z == 0.
PACIB <Xd>, <Xn|SP>

PACIZB variant
Applies when Z == 1 && Rn == 11111.
PACIZB <Xd>

Decode for all variants of this encoding
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HavePACExt() then
UNDEFINED;
if Z == '0' then // PACIB
if n == 31 then source_is_sp = TRUE;
else // PACIZB
if n != 31 then UNDEFINED;

System
ARMv8.3

C6-1156

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 x 1 0 1 x 1 1 1 1 1
CRm
op2

PACIB1716 variant
Applies when CRm == 0001 && op2 == 010.
PACIB1716

PACIBSP variant
Applies when CRm == 0011 && op2 == 011.
PACIBSP

PACIBZ variant
Applies when CRm == 0011 && op2 == 010.
PACIBZ

Decode for all variants of this encoding
integer d;
integer n;
boolean source_is_sp = FALSE;
case CRm:op2 of
when '0011 010'
// PACIBZ
d = 30;
n = 31;
when '0011 011'
// PACIBSP
d = 30;
source_is_sp = TRUE;
if HaveBTIExt() then
// Check for branch target compatibility between PSTATE.BTYPE
// and implicit branch target of PACIBSP instruction.
SetBTypeCompatible(BTypeCompatible_PACIXSP());
when '0001 010'
// PACIB1716
d = 17;
n = 16;
when '0001 000' SEE "PACIA";
when '0001 100' SEE "AUTIA";
when '0001 110' SEE "AUTIB";
when '0011 00x' SEE "PACIA";
when '0011 10x' SEE "AUTIA";
when '0011 11x' SEE "AUTIB";
when '0000 111' SEE "XPACLRI";
otherwise SEE "HINT";

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the "Rn" field.

Operation for all encodings
if HavePACExt() then
if source_is_sp then
X[d] = AddPACIB(X[d], SP[]);
else
X[d] = AddPACIB(X[d], X[n]);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1157

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.212

PRFM (immediate)
Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are
likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up
the memory accesses when they do occur, such as preloading the cache line containing the specified address into
one or more caches.
The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on
page C3-218.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21
1 1 1 1 1 0 0 1 1 0
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
PRFM (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]

Decode for this encoding
bits(64) offset = LSL(ZeroExtend(imm12, 64), 3);

Assembler symbols
<prfop>

Is the prefetch operation, defined as <type><target><policy>.
<type> is one of:
PLD

Prefetch for load, encoded in the "Rt<4:3>" field as 0b00.

PLI

Preload instructions, encoded in the "Rt<4:3>" field as 0b01.

PST

Prefetch for store, encoded in the "Rt<4:3>" field as 0b10.

<target> is one of:
L1

Level 1 cache, encoded in the "Rt<2:1>" field as 0b00.

L2

Level 2 cache, encoded in the "Rt<2:1>" field as 0b01.

L3

Level 3 cache, encoded in the "Rt<2:1>" field as 0b10.

<policy> is one of:
KEEP

Retained or temporal prefetch, allocated in the cache normally. Encoded in the "Rt<0>"
field as 0.

STRM

Streaming or non-temporal prefetch, for data that is used only once. Encoded in the
"Rt<0>" field as 1.

For more information on these prefetch operations, see Prefetch memory on page C3-218.
For other encodings of the "Rt" field, use <imm5>.
<imm5>

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the "Rt" field.
This syntax is only for encodings that are not accessible using <prfop>.

C6-1158

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<pimm>

Is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to
0 and encoded in the "imm12" field as <pimm>/8.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
bits(64) address;
if n == 31 then
address = SP[];
else
address = X[n];
address = address + offset;
Prefetch(address, t<4:0>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1159

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.213

PRFM (literal)
Prefetch Memory (literal) signals the memory system that data memory accesses from a specified address are likely
to occur in the near future. The memory system can respond by taking actions that are expected to speed up the
memory accesses when they do occur, such as preloading the cache line containing the specified address into one
or more caches.
The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on
page C3-218.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23
1 1 0 1 1 0 0 0
opc

5 4
imm19

0
Rt

Encoding
PRFM (<prfop>|#<imm5>), <label>

Decode for this encoding
integer t = UInt(Rt);
bits(64) offset;
offset = SignExtend(imm19:'00', 64);

Assembler symbols
<prfop>

Is the prefetch operation, defined as <type><target><policy>.
<type> is one of:
PLD

Prefetch for load, encoded in the "Rt<4:3>" field as 0b00.

PLI

Preload instructions, encoded in the "Rt<4:3>" field as 0b01.

PST

Prefetch for store, encoded in the "Rt<4:3>" field as 0b10.

<target> is one of:
L1

Level 1 cache, encoded in the "Rt<2:1>" field as 0b00.

L2

Level 2 cache, encoded in the "Rt<2:1>" field as 0b01.

L3

Level 3 cache, encoded in the "Rt<2:1>" field as 0b10.

<policy> is one of:
KEEP

Retained or temporal prefetch, allocated in the cache normally. Encoded in the "Rt<0>"
field as 0.

STRM

Streaming or non-temporal prefetch, for data that is used only once. Encoded in the
"Rt<0>" field as 1.

For more information on these prefetch operations, see Prefetch memory on page C3-218.
For other encodings of the "Rt" field, use <imm5>.
<imm5>

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the "Rt" field.
This syntax is only for encodings that are not accessible using <prfop>.

<label>

C6-1160

Is the program label from which the data is to be loaded. Its offset from the address of this
instruction, in the range +/-1MB, is encoded as "imm19" times 4.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) address = PC[] + offset;
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
Prefetch(address, t<4:0>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1161

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.214

PRFM (register)
Prefetch Memory (register) signals the memory system that data memory accesses from a specified address are
likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up
the memory accesses when they do occur, such as preloading the cache line containing the specified address into
one or more caches.
The effect of an PRFM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on
page C3-218.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 1 1 1 0 0 0 1 0 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Encoding
PRFM (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then 3 else 0;

Assembler symbols
<prfop>

Is the prefetch operation, defined as <type><target><policy>.
<type> is one of:
PLD

Prefetch for load, encoded in the "Rt<4:3>" field as 0b00.

PLI

Preload instructions, encoded in the "Rt<4:3>" field as 0b01.

PST

Prefetch for store, encoded in the "Rt<4:3>" field as 0b10.

<target> is one of:
L1

Level 1 cache, encoded in the "Rt<2:1>" field as 0b00.

L2

Level 2 cache, encoded in the "Rt<2:1>" field as 0b01.

L3

Level 3 cache, encoded in the "Rt<2:1>" field as 0b10.

<policy> is one of:
KEEP

Retained or temporal prefetch, allocated in the cache normally. Encoded in the "Rt<0>"
field as 0.

STRM

Streaming or non-temporal prefetch, for data that is used only once. Encoded in the
"Rt<0>" field as 1.

For more information on these prefetch operations, see Prefetch memory on page C3-218.
For other encodings of the "Rt" field, use <imm5>.
<imm5>

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the "Rt" field.
This syntax is only for encodings that are not accessible using <prfop>.

C6-1162

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:
UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, optional only when <extend> is not LSL. Where it is permitted to be
optional, it defaults to #0. It is encoded in the "S" field. It can have the following values:

<amount>

#0

when S = 0

#3

when S = 1

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
bits(64) address;
if n == 31 then
address = SP[];
else
address = X[n];
address = address + offset;
Prefetch(address, t<4:0>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1163

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.215

PRFUM
Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address
are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed
up the memory accesses when they do occur, such as preloading the cache line containing the specified address into
one or more caches.
The effect of an PRFUM instruction is IMPLEMENTATION DEFINED. For more information, see Prefetch memory on
page C3-218.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 1 1 1 0 0 0 1 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<prfop>

Is the prefetch operation, defined as <type><target><policy>.
<type> is one of:
PLD

Prefetch for load, encoded in the "Rt<4:3>" field as 0b00.

PLI

Preload instructions, encoded in the "Rt<4:3>" field as 0b01.

PST

Prefetch for store, encoded in the "Rt<4:3>" field as 0b10.

<target> is one of:
L1

Level 1 cache, encoded in the "Rt<2:1>" field as 0b00.

L2

Level 2 cache, encoded in the "Rt<2:1>" field as 0b01.

L3

Level 3 cache, encoded in the "Rt<2:1>" field as 0b10.

<policy> is one of:
KEEP

Retained or temporal prefetch, allocated in the cache normally. Encoded in the "Rt<0>"
field as 0.

STRM

Streaming or non-temporal prefetch, for data that is used only once. Encoded in the
"Rt<0>" field as 1.

For more information on these prefetch operations, see Prefetch memory on page C3-218.
For other encodings of the "Rt" field, use <imm5>.
<imm5>

Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the "Rt" field.
This syntax is only for encodings that are not accessible using <prfop>.

C6-1164

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
bits(64) address;
if n == 31 then
address = SP[];
else
address = X[n];
address = address + offset;
Prefetch(address, t<4:0>);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1165

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.216

PSB CSYNC
Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the
current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the
profiling buffer have been initiated. A following DSB instruction completes when the writes to the profiling buffer
have completed.
If the Statistical Profiling Extension is not implemented, this instruction executes as a NOP.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 0 0 1 1 1 1 1 1
CRm
op2

Encoding
PSB CSYNC

Decode for this encoding
if !HaveStatisticalProfiling() then EndOfInstruction();

Operation
ProfilingSynchronizationBarrier();

C6-1166

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.217

PSSBB
Physical Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing
earlier stores to the same physical address.
The semantics of the Physical Speculative Store Bypass Barrier are:
•

When a load to a location appears in program order after the PSSBB, then the load does not speculatively
read an entry earlier in the coherence order for that location than the entry generated by the latest store
satisfying all of the following conditions:

•

—

The store is to the same location as the load.

—

The store appears in program order before the PSSBB.

When a load to a location appears in program order before the PSSBB, then the load does not speculatively
read data from any store satisfying all of the following conditions:
—

The store is to the same location as the load.

—

The store appears in program order after the PSSBB.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 1 1 1 1
CRm
opc

Encoding
PSSBB

Decode for this encoding
// No additional decoding required

Operation
SpeculativeStoreBypassBarrierToPA();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1167

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.218

RBIT
Reverse Bits reverses the bit order in a register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
RBIT <Wd>, <Wn>

64-bit variant
Applies when sf == 1.
RBIT <Xd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
bits(datasize) operand = X[n];
bits(datasize) result;
for i = 0 to datasize-1
result<datasize-1-i> = operand<i>;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1168

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.219

RET
Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine
return.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 0 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 0 0
Z
op
A M

5 4
Rn

0

0 0 0 0 0
Rm

Encoding
RET {<Xn>}

Decode for this encoding
integer n = UInt(Rn);

Assembler symbols
Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in
the "Rn" field. Defaults to X30 if absent.

<Xn>

Operation
bits(64) target = X[n];
BranchTo(target, BranchType_RET);

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1169

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.220

RETAA, RETAB
Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR,
using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction
is a subroutine return.
Key A is used for RETAA, and key B is used for RETAB.
If the authentication passes, the PE continues execution at the target of the branch. If the authentication fails, a
Translation fault is generated.
The authenticated address is not written back to LR.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

5 4

0

1 1 0 1 0 1 1 0 0 1 0 1 1 1 1 1 0 0 0 0 1 M 1 1 1 1 1 1 1 1 1 1
Z
op
A
Rn
Rm

RETAA variant
Applies when M == 0.
RETAA

RETAB variant
Applies when M == 1.
RETAB

Decode for all variants of this encoding
boolean use_key_a = (M == '0');
if !HavePACExt() then
UNDEFINED;

Operation
bits(64) target = X[30];
bits(64) modifier = SP[];
if use_key_a then
target = AuthIA(target, modifier, TRUE);
else
target = AuthIB(target, modifier, TRUE);
BranchTo(target, BranchType_RET);

C6-1170

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.221

REV
Reverse Bytes reverses the byte order in a register.
This instruction is used by the pseudo-instruction REV64. The pseudo-instruction is never the preferred
disassembly.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 x
opc

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && opc == 10.
REV <Wd>, <Wn>

64-bit variant
Applies when sf == 1 && opc == 11.
REV <Xd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer container_size;
case opc of
when '00'
Unreachable();
when '01'
container_size = 16;
when '10'
container_size = 32;
when '11'
if sf == '0' then UNDEFINED;
container_size = 64;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
bits(datasize) operand = X[n];
bits(datasize) result;
integer
integer
integer
integer

ARM DDI 0487F.c
ID072120

containers = datasize DIV container_size;
elements_per_container = container_size DIV 8;
index = 0;
rev_index;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1171

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

for c = 0 to containers-1
rev_index = index + ((elements_per_container - 1) * 8);
for e = 0 to elements_per_container-1
result<rev_index+7:rev_index> = operand<index+7:index>;
index = index + 8;
rev_index = rev_index - 8;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1172

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.222

REV16
Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
sf 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1
opc

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
REV16 <Wd>, <Wn>

64-bit variant
Applies when sf == 1.
REV16 <Xd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer container_size;
case opc of
when '00'
Unreachable();
when '01'
container_size = 16;
when '10'
container_size = 32;
when '11'
if sf == '0' then UNDEFINED;
container_size = 64;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
bits(datasize) operand = X[n];
bits(datasize) result;
integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV 8;
integer index = 0;
integer rev_index;
for c = 0 to containers-1
rev_index = index + ((elements_per_container - 1) * 8);
for e = 0 to elements_per_container-1

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1173

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

result<rev_index+7:rev_index> = operand<index+7:index>;
index = index + 8;
rev_index = rev_index - 8;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1174

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.223

REV32
Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0
sf
opc

5 4
Rn

0
Rd

Encoding
REV32 <Xd>, <Xn>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer container_size;
case opc of
when '00'
Unreachable();
when '01'
container_size = 16;
when '10'
container_size = 32;
when '11'
if sf == '0' then UNDEFINED;
container_size = 64;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
bits(datasize) operand = X[n];
bits(datasize) result;
integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV 8;
integer index = 0;
integer rev_index;
for c = 0 to containers-1
rev_index = index + ((elements_per_container - 1) * 8);
for e = 0 to elements_per_container-1
result<rev_index+7:rev_index> = operand<index+7:index>;
index = index + 8;
rev_index = rev_index - 8;
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1175

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1176

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.224

REV64
Reverse Bytes reverses the byte order in a 64-bit general-purpose register.
When assembling for Armv8.2, an assembler must support this pseudo-instruction. It is OPTIONAL whether an
assembler supports this pseudo-instruction when assembling for an architecture earlier than Armv8.2.
This instruction is a pseudo-instruction of the REV instruction. This means that:
•

The encodings in this description are named to match the encodings of REV.

•

The assembler syntax is used only for assembly, and is not used on disassembly.

•

The description of REV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1
sf
opc

5 4
Rn

0
Rd

64-bit variant
REV64 <Xd>, <Xn>

is equivalent to
REV

<Xd>, <Xn>

and is never the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of REV gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1177

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.225

RMIF
Performs a rotation right of a value held in a general purpose register by an immediate value, and then inserts a
selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second
immediate mask.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 1 0 0 0 0
sf

15 14 13 12 11 10 9
imm6

0 0 0 0 1

5 4 3
Rn

0

0
mask

Encoding
RMIF <Xn>, #<shift>, #<mask>

Decode for this encoding
if !HaveFlagManipulateExt() then UNDEFINED;
integer lsb = UInt(imm6);
integer n = UInt(Rn);

Assembler symbols
<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<shift>

Is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the "imm6" field,

<mask>

Is the flag bit mask, an immediate in the range 0 to 15, which selects the bits that are inserted into
the NZCV condition flags, encoded in the "mask" field.

Operation
bits(4) tmp;
bits(64) tmpreg = X[n];
tmp = (tmpreg:tmpreg)<lsb+3:lsb>;
if mask<3> == '1' then PSTATE.N =
if mask<2> == '1' then PSTATE.Z =
if mask<1> == '1' then PSTATE.C =
if mask<0> == '1' then PSTATE.V =

tmp<3>;
tmp<2>;
tmp<1>;
tmp<0>;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1178

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.226

ROR (immediate)
Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The
bits that are rotated off the right end are inserted into the vacated bit positions on the left.
This instruction is an alias of the EXTR instruction. This means that:
•

The encodings in this description are named to match the encodings of EXTR.

•

The description of EXTR gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 0 0 1 1 1 N 0

16 15
Rm

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0 && imms == 0xxxxx.
ROR <Wd>, <Ws>, #<shift>

is equivalent to
EXTR <Wd>, <Ws>, <Ws>, #<shift>

and is the preferred disassembly when Rn == Rm.
64-bit variant
Applies when sf == 1 && N == 1.
ROR <Xd>, <Xs>, #<shift>

is equivalent to
EXTR <Xd>, <Xs>, <Xs>, #<shift>

and is the preferred disassembly when Rn == Rm.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Ws>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xs>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" and "Rm" fields.

<shift>

For the 32-bit variant: is the amount by which to rotate, in the range 0 to 31, encoded in the "imms"
field.
For the 64-bit variant: is the amount by which to rotate, in the range 0 to 63, encoded in the "imms"
field.

Operation
The description of EXTR gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1179

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1180

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.227

ROR (register)
Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits
that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by
dividing the second source register by the data size defines the number of bits by which the first source register is
right-shifted.
This instruction is an alias of the RORV instruction. This means that:
•

The encodings in this description are named to match the encodings of RORV.

•

The description of RORV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
ROR <Wd>, <Wn>, <Wm>

is equivalent to
RORV <Wd>, <Wn>, <Wm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
ROR <Xd>, <Xn>, <Xm>

is equivalent to
RORV <Xd>, <Xn>, <Xm>

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
The description of RORV gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1181

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1182

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.228

RORV
Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits
that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by
dividing the second source register by the data size defines the number of bits by which the first source register is
right-shifted.
This instruction is used by the alias ROR (register). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
op2

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
RORV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
RORV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ShiftType shift_type = DecodeShift(op2);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to
31 in its bottom 5 bits, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to
63 in its bottom 6 bits, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand2 = X[m];
result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1183

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1184

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.229

SB
Speculation Barrier is a barrier that controls speculation.
The semantics of the Speculation Barrier are that the execution, until the barrier completes, of any instruction that
appears later in the program order than the barrier:
•

Cannot be performed speculatively to the extent that such speculation can be observed through side-channels
as a result of control flow speculation or data value speculation.

•

Can be speculatively executed as a result of predicting that a potentially exception generating instruction has
not generated an exception.

In particular, any instruction that appears later in the program order than the barrier cannot cause a speculative
allocation into any caching structure where the allocation of that entry could be indicative of any data value present
in memory or in the registers.
The SB instruction:
•

Cannot be speculatively executed as a result of control flow speculation or data value speculation.

•

Can be speculatively executed as a result of predicting that a potentially exception generating instruction has
not generated an exception. The potentially exception generating instruction can complete once it is known
not to be speculative, and all data values generated by instructions appearing in program order before the SB
instruction have their predicted values confirmed.

When the prediction of the instruction stream is not informed by data taken from the register outputs of the
speculative execution of instructions appearing in program order after an uncompleted SB instruction, the SB
instruction has no effect on the use of prediction resources to predict the instruction stream that is being fetched.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 (0) (0) (0) (0) 1 1 1 1 1 1 1 1
CRm
opc

Encoding
SB

Decode for this encoding
if !HaveSBExt() then UNDEFINED;

Operation
SpeculationBarrier();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1185

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.230

SBC
Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes
the result to the destination register.
This instruction is used by the alias NGC. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SBC <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
SBC <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

NGC

Rn == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
operand2 = NOT(operand2);

C6-1186

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

(result, -) = AddWithCarry(operand1, operand2, PSTATE.C);
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1187

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.231

SBCS
Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value,
and writes the result to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias NGCS. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 1 1 0 1 0 0 0 0
op S

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SBCS <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
SBCS <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

NGCS

Rn == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(4) nzcv;
operand2 = NOT(operand2);

C6-1188

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1189

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.232

SBFIZ
Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register
to bit position <lsb> of the destination register, setting the destination bits below the bitfield to zero, and the bits
above the bitfield to a copy of the most significant bit of the bitfield.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
SBFIZ <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
SBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).
64-bit variant
Applies when sf == 1 && N == 1.
SBFIZ <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
SBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

C6-1190

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1191

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.233

SBFM
Signed Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.
If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position
<immr> in the source register to the least significant bits of the destination register.
If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source
register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32
or 64 bits.
In both cases the destination bits below the bitfield are set to zero, and the bits above the bitfield are set to a copy
of the most significant bit of the bitfield.
This instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB, SXTH, and SXTW. See Alias
conditions on page C6-1193 for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
SBFM <Wd>, <Wn>, #<immr>, #<imms>

64-bit variant
Applies when sf == 1 && N == 1.
SBFM <Xd>, <Xn>, #<immr>, #<imms>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer R;
integer S;
bits(datasize) wmask;
bits(datasize) tmask;
if sf == '1' && N != '1' then UNDEFINED;
if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
R = UInt(immr);
S = UInt(imms);
(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

C6-1192

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

of variant

is preferred when

ASR (immediate)

32-bit

imms == '011111'

ASR (immediate)

64-bit

imms == '111111'

SBFIZ

-

UInt(imms) < UInt(immr)

SBFX

-

BFXPreferred(sf, opc<1>, imms, immr)

SXTB

-

immr == '000000' && imms == '000111'

SXTH

-

immr == '000000' && imms == '001111'

SXTW

-

immr == '000000' && imms == '011111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<immr>

For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.
For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.
For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
encoded in the "imms" field.

<imms>

For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
encoded in the "imms" field.

Operation
bits(datasize) src = X[n];
// perform bitfield move on low bits
bits(datasize) bot = ROR(src, R) AND wmask;
// determine extension bits (sign, zero or dest register)
bits(datasize) top = Replicate(src<S>);
// combine extension bits and result bits
X[d] = (top AND NOT(tmask)) OR (bot AND tmask);

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1193

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.234

SBFX
Signed Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to the
least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most
significant bit of the bitfield.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 0 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
SBFX <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
SBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).
64-bit variant
Applies when sf == 1 && N == 1.
SBFX <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
SBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

C6-1194

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1195

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.235

SDIV
Signed Divide divides a signed integer register value by another signed integer register value, and writes the result
to the destination register. The condition flags are not affected.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1
o1

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SDIV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
SDIV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
integer result;
if IsZero(operand2) then
result = 0;
else
result = RoundTowardsZero(Real(Int(operand1, FALSE)) / Real(Int(operand2, FALSE)));
X[d] = result<datasize-1:0>;

C6-1196

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.236

SETF8, SETF16
Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an
8 bit value, and SETF16 treats the value as an 16 bit value.
The PSTATE.C flag is not affected by these instructions.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 sz 0 0 1 0
sf

5 4 3 2 1 0
Rn

0 1 1 0 1

SETF8 variant
Applies when sz == 0.
SETF8 <Wn>

SETF16 variant
Applies when sz == 1.
SETF16 <Wn>

Decode for all variants of this encoding
if !HaveFlagManipulateExt() then UNDEFINED;
integer msb = if sz == '1' then 15 else 7;
integer n = UInt(Rn);

Assembler symbols
Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Operation
bits(32) tmpreg = X[n];
PSTATE.N = tmpreg<msb>;
PSTATE.Z = if (tmpreg<msb:0> == Zeros(msb + 1)) then '1' else '0';
PSTATE.V = tmpreg<msb+1> EOR tmpreg<msb>;
//PSTATE.C unchanged;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1197

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.237

SEV
Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more
information, see Wait for Event mechanism and Send event on page D1-2391.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 0 1 1 1 1 1
CRm
op2

Encoding
SEV

Decode for this encoding
// Empty.

Operation
SendEvent();

C6-1198

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.238

SEVL
Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be
signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 0 1 1 1 1 1 1
CRm
op2

Encoding
SEVL

Decode for this encoding
// Empty.

Operation
SendEventLocal();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1199

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.239

SMADDL
Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result
to the 64-bit destination register.
This instruction is used by the alias SMULL. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 0 0 1
U

16 15 14
Rm

0
o0

10 9
Ra

5 4
Rn

0
Rd

Encoding
SMADDL <Xd>, <Wn>, <Wm>, <Xa>

Decode for this encoding
integer
integer
integer
integer

d
n
m
a

=
=
=
=

UInt(Rd);
UInt(Rn);
UInt(Rm);
UInt(Ra);

Alias conditions
Alias

is preferred when

SMULL

Ra == '11111'

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xa>

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
"Ra" field.

Operation
bits(32) operand1 = X[n];
bits(32) operand2 = X[m];
bits(64) operand3 = X[a];
integer result;
result = Int(operand3, FALSE) + (Int(operand1, FALSE) * Int(operand2, FALSE));
X[d] = result<63:0>;

C6-1200

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1201

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.240

SMC
Secure Monitor Call causes an exception to EL3.
SMC is available only for software executing at EL1 or higher. It is UNDEFINED in EL0.

If the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC instruction at EL1 or higher
generates a Secure Monitor Call exception, recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3.
If the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security state, execution of an SMC instruction
at EL1 generates an exception that is taken to EL2, regardless of the value of SCR_EL3.SMD. For more
information, see Traps to EL2 of EL1 execution of SMC instructions on page D1-2379.
If the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC instruction is UNDEFINED.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 0 0 0

5 4 3 2 1 0
imm16

0 0 0 1 1

Encoding
SMC #<imm>

Decode for this encoding
// Empty.

Assembler symbols
Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<imm>

Operation
AArch64.CheckForSMCUndefOrTrap(imm16);
AArch64.CallSecureMonitor(imm16);

C6-1202

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.241

SMNEGL
Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the
64-bit destination register.
This instruction is an alias of the SMSUBL instruction. This means that:
•

The encodings in this description are named to match the encodings of SMSUBL.

•

The description of SMSUBL gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 0 0 1
U

16 15 14
Rm

10 9

1 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

Encoding
SMNEGL <Xd>, <Wn>, <Wm>

is equivalent to
SMSUBL <Xd>, <Wn>, <Wm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of SMSUBL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1203

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.242

SMSUBL
Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register
value, and writes the result to the 64-bit destination register.
This instruction is used by the alias SMNEGL. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 0 0 1
U

16 15 14
Rm

1
o0

10 9
Ra

5 4
Rn

0
Rd

Encoding
SMSUBL <Xd>, <Wn>, <Wm>, <Xa>

Decode for this encoding
integer
integer
integer
integer

d
n
m
a

=
=
=
=

UInt(Rd);
UInt(Rn);
UInt(Rm);
UInt(Ra);

Alias conditions
Alias

is preferred when

SMNEGL

Ra == '11111'

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xa>

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
"Ra" field.

Operation
bits(32) operand1 = X[n];
bits(32) operand2 = X[m];
bits(64) operand3 = X[a];
integer result;
result = Int(operand3, FALSE) - (Int(operand1, FALSE) * Int(operand2, FALSE));
X[d] = result<63:0>;

C6-1204

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1205

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.243

SMULH
Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit
destination register.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 0 1 0
U

16 15 14
Rm

10 9

0 (1) (1) (1) (1) (1)
Ra

5 4
Rn

0
Rd

Encoding
SMULH <Xd>, <Xn>, <Xm>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
bits(64) operand1 = X[n];
bits(64) operand2 = X[m];
integer result;
result = Int(operand1, FALSE) * Int(operand2, FALSE);
X[d] = result<127:64>;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1206

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.244

SMULL
Signed Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.
This instruction is an alias of the SMADDL instruction. This means that:
•

The encodings in this description are named to match the encodings of SMADDL.

•

The description of SMADDL gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 0 0 1
U

16 15 14
Rm

10 9

0 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

Encoding
SMULL <Xd>, <Wn>, <Wm>

is equivalent to
SMADDL <Xd>, <Wn>, <Wm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of SMADDL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1207

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.245

SSBB
Speculative Store Bypass Barrier is a memory barrier which prevents speculative loads from bypassing earlier stores
to the same virtual address under certain conditions.
The semantics of the Speculative Store Bypass Barrier are:
•

When a load to a location appears in program order after the SSBB, then the load does not speculatively read
an entry earlier in the coherence order for that location than the entry generated by the latest store satisfying
all of the following conditions:

•

—

The store is to the same location as the load.

—

The store uses the same virtual address as the load.

—

The store appears in program order before the SSBB.

When a load to a location appears in program order before the SSBB, then the load does not speculatively
read data from any store satisfying all of the following conditions:
—

The store is to the same location as the load.

—

The store uses the same virtual address as the load.

—

The store appears in program order after the SSBB.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 0 0 0 0 1 0 0 1 1 1 1 1
CRm
opc

Encoding
SSBB

Decode for this encoding
// No additional decoding required

Operation
SpeculativeStoreBypassBarrierToVA();

C6-1208

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.246

ST2G
Store Allocation Tags stores an Allocation Tag to two Tag granules of memory. The address used for the store is
calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is
calculated from the Logical Address Tag in the source register.
This instruction generates an Unchecked access.

Post-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 0 1

12 11 10 9
imm9

0 1

5 4
Xn

0
Xt

Encoding
ST2G <Xt|SP>, [<Xn|SP>], #<simm>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

Pre-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 0 1

12 11 10 9
imm9

1 1

5 4
Xn

0
Xt

Encoding
ST2G <Xt|SP>, [<Xn|SP>, #<simm>]!

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

Signed offset
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 0 1

ARM DDI 0487F.c
ID072120

12 11 10 9
imm9

1 0

5 4
Xn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Xt

C6-1209

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Encoding
ST2G <Xt|SP>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Xt|SP>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<simm>

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0
and encoded in the "imm9" field.

Operation for all encodings
bits(64) address;
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
SetTagCheckedInstruction(FALSE);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
AArch64.MemTag[address, AccType_NORMAL] = tag;
AArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;
if writeback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1210

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.247

STADDB, STADDLB
Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in
a register to it, and stores the result back to memory.
•

STADDB does not have release semantics.

•

STADDLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDADDB, LDADDAB, LDADDALB, LDADDLB instruction. This means that:
•

The encodings in this description are named to match the encodings of LDADDB, LDADDAB,
LDADDALB, LDADDLB.

•

The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STADDB <Ws>, [<Xn|SP>]

is equivalent to
LDADDB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STADDLB <Ws>, [<Xn|SP>]

is equivalent to
LDADDLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1211

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1212

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.248

STADDH, STADDLH
Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value
held in a register to it, and stores the result back to memory.
•

STADDH does not have release semantics.

•

STADDLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDADDH, LDADDAH, LDADDALH, LDADDLH instruction. This means that:
•

The encodings in this description are named to match the encodings of LDADDH, LDADDAH,
LDADDALH, LDADDLH.

•

The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STADDH <Ws>, [<Xn|SP>]

is equivalent to
LDADDH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STADDLH <Ws>, [<Xn|SP>]

is equivalent to
LDADDLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1213

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1214

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.249

STADD, STADDL
Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword
from memory, adds the value held in a register to it, and stores the result back to memory.
•

STADD does not have release semantics.

•

STADDL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDADD, LDADDA, LDADDAL, LDADDL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDADD, LDADDA, LDADDAL,
LDADDL.

•

The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDADD alias variant
Applies when size == 10 && R == 0.
STADD <Ws>, [<Xn|SP>]

is equivalent to
LDADD <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDADDL alias variant
Applies when size == 10 && R == 1.
STADDL <Ws>, [<Xn|SP>]

is equivalent to
LDADDL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDADD alias variant
Applies when size == 11 && R == 0.
STADD <Xs>, [<Xn|SP>]

is equivalent to
LDADD <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1215

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDADDL alias variant
Applies when size == 11 && R == 1.
STADDL <Xs>, [<Xn|SP>]

is equivalent to
LDADDL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1216

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.250

STCLRB, STCLRLB
Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise
AND with the complement of the value held in a register on it, and stores the result back to memory.
•

STCLRB does not have release semantics.

•

STCLRLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB instruction. This means that:
•

The encodings in this description are named to match the encodings of LDCLRB, LDCLRAB, LDCLRALB,
LDCLRLB.

•

The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STCLRB <Ws>, [<Xn|SP>]

is equivalent to
LDCLRB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STCLRLB <Ws>, [<Xn|SP>]

is equivalent to
LDCLRLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1217

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1218

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.251

STCLRH, STCLRLH
Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs
a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory.
•

STCLRH does not have release semantics.

•

STCLRLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH instruction. This means that:
•

The encodings in this description are named to match the encodings of LDCLRH, LDCLRAH, LDCLRALH,
LDCLRLH.

•

The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STCLRH <Ws>, [<Xn|SP>]

is equivalent to
LDCLRH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STCLRLH <Ws>, [<Xn|SP>]

is equivalent to
LDCLRLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1219

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1220

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.252

STCLR, STCLRL
Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit
doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and
stores the result back to memory.
•

STCLR does not have release semantics.

•

STCLRL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDCLR, LDCLRA, LDCLRAL, LDCLRL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDCLR, LDCLRA, LDCLRAL,
LDCLRL.

•

The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDCLR alias variant
Applies when size == 10 && R == 0.
STCLR <Ws>, [<Xn|SP>]

is equivalent to
LDCLR <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDCLRL alias variant
Applies when size == 10 && R == 1.
STCLRL <Ws>, [<Xn|SP>]

is equivalent to
LDCLRL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDCLR alias variant
Applies when size == 11 && R == 0.
STCLR <Xs>, [<Xn|SP>]

is equivalent to
LDCLR <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1221

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDCLRL alias variant
Applies when size == 11 && R == 1.
STCLRL <Xs>, [<Xn|SP>]

is equivalent to
LDCLRL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1222

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.253

STEORB, STEORLB
Atomic exclusive OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an
exclusive OR with the value held in a register on it, and stores the result back to memory.
•

STEORB does not have release semantics.

•

STEORLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDEORB, LDEORAB, LDEORALB, LDEORLB instruction. This means that:
•

The encodings in this description are named to match the encodings of LDEORB, LDEORAB, LDEORALB,
LDEORLB.

•

The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STEORB <Ws>, [<Xn|SP>]

is equivalent to
LDEORB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STEORLB <Ws>, [<Xn|SP>]

is equivalent to
LDEORLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1223

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1224

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.254

STEORH, STEORLH
Atomic exclusive OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory,
performs an exclusive OR with the value held in a register on it, and stores the result back to memory.
•

STEORH does not have release semantics.

•

STEORLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDEORH, LDEORAH, LDEORALH, LDEORLH instruction. This means that:
•

The encodings in this description are named to match the encodings of LDEORH, LDEORAH,
LDEORALH, LDEORLH.

•

The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STEORH <Ws>, [<Xn|SP>]

is equivalent to
LDEORH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STEORLH <Ws>, [<Xn|SP>]

is equivalent to
LDEORLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational pseudocode for this
instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1225

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1226

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.255

STEOR, STEORL
Atomic exclusive OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit
doubleword from memory, performs an exclusive OR with the value held in a register on it, and stores the result
back to memory.
•

STEOR does not have release semantics.

•

STEORL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDEOR, LDEORA, LDEORAL, LDEORL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDEOR, LDEORA, LDEORAL,
LDEORL.

•

The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDEOR alias variant
Applies when size == 10 && R == 0.
STEOR <Ws>, [<Xn|SP>]

is equivalent to
LDEOR <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDEORL alias variant
Applies when size == 10 && R == 1.
STEORL <Ws>, [<Xn|SP>]

is equivalent to
LDEORL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDEOR alias variant
Applies when size == 11 && R == 0.
STEOR <Xs>, [<Xn|SP>]

is equivalent to
LDEOR <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1227

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDEORL alias variant
Applies when size == 11 && R == 1.
STEORL <Xs>, [<Xn|SP>]

is equivalent to
LDEORL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1228

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.256

STG
Store Allocation Tag stores an Allocation Tag to memory. The address used for the store is calculated from the base
register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical
Address Tag in the source register.
This instruction generates an Unchecked access.

Post-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 0 1

12 11 10 9
imm9

0 1

5 4
Xn

0
Xt

Encoding
STG <Xt|SP>, [<Xn|SP>], #<simm>

Decode for this encoding
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

Pre-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 0 1

12 11 10 9
imm9

1 1

5 4
Xn

0
Xt

Encoding
STG <Xt|SP>, [<Xn|SP>, #<simm>]!

Decode for this encoding
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

Signed offset
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 0 1

12 11 10 9
imm9

1 0

5 4
Xn

0
Xt

Encoding
STG <Xt|SP>, [<Xn|SP>{, #<simm>}]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1229

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Xt|SP>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<simm>

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0
and encoded in the "imm9" field.

Operation for all encodings
bits(64) address;
SetTagCheckedInstruction(FALSE);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
AArch64.MemTag[address, AccType_NORMAL] = tag;
if writeback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1230

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.257

STGM
Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where the size of N is identified in
GMID_EL1.BS, and the Allocation Tag written to address A is taken from the source register at
4*A<7:4>+3:4*A<7:4>.
This instruction is UNDEFINED at EL0.
This instruction generates an Unchecked access.
If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0

5 4
Xn

0
Xt

Encoding
STGM <Xt>, [<Xn|SP>]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer t = UInt(Xt);
integer n = UInt(Xn);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

Operation
if PSTATE.EL == EL0 then
UNDEFINED;
bits(64) data = X[t];
bits(64) address;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
integer
address
integer
integer

size = 4 * (2 ^ (UInt(GMID_EL1.BS)));
= Align(address, size);
count = size >> LOG2_TAG_GRANULE;
index = UInt(address<LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE>);

for i = 0 to count-1
bits(4) tag = data<(index*4)+3:index*4>;
AArch64.MemTag[address, AccType_NORMAL] = tag;
address = address + TAG_GRANULE;
index = index + 1;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1231

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.258

STGP
Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from
two registers. The address used for the store is calculated from the base register and an immediate signed offset
scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the base register.
This instruction generates an Unchecked access.

Post-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 0 1 0

15 14
simm7

10 9
Xt2

5 4
Xn

0
Xt

Encoding
STGP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>

Decode for this encoding
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

Pre-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 1 1 0

15 14
simm7

10 9
Xt2

5 4
Xn

0
Xt

Encoding
STGP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!

Decode for this encoding
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

Signed offset
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21
0 1 1 0 1 0 0 1 0 0

C6-1232

15 14
simm7

10 9
Xt2

5 4
Xn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Xt

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Encoding
STGP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Xt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Xt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<imm>

For the post-index and pre-index variant: is the signed immediate offset, a multiple of 16 in the range
-1024 to 1008, encoded in the "simm7" field.
For the signed offset variant: is the optional signed immediate offset, a multiple of 16 in the range
-1024 to 1008, defaulting to 0 and encoded in the "simm7" field.

Operation for all encodings
bits(64) address;
bits(64) data1;
bits(64) data2;
SetTagCheckedInstruction(FALSE);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data1 = X[t];
data2 = X[t2];
if !postindex then
address = address + offset;
Mem[address, 8, AccType_NORMAL] = data1;
Mem[address+8, 8, AccType_NORMAL] = data2;
AArch64.MemTag[address, AccType_NORMAL] = AArch64.AllocationTagFromAddress(address);
if writeback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1233

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.259

STLLRB
Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has
memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For information
about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLLRB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, 1, AccType_LIMITEDORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1234

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.260

STLLRH
Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction
also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140. For
information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLLRH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, 2, AccType_LIMITEDORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1235

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.261

STLLR
Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The
instruction also has memory ordering semantics as described in LoadLOAcquire, StoreLORelease on page B2-140.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 0 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STLLR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
STLLR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, dbytes, AccType_LIMITEDORDERED] = data;

C6-1236

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1237

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.262

STLR
Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The
instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

1 x 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STLR <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
STLR <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer elsize = 8 << UInt(size);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, dbytes, AccType_ORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1238

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.263

STLRB
Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has
memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.
For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 0 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLRB <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, 1, AccType_ORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1239

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.264

STLRH
Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also
has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14

10 9

0 1 0 0 1 0 0 0 1 0 0 (1) (1) (1) (1) (1) 1 (1) (1) (1) (1) (1)
size
L
Rs
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLRH <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
data = X[t];
Mem[address, 2, AccType_ORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1240

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.265

STLUR
Store-Release Register (unscaled) calculates an address from a base register value and an immediate offset, and
stores a 32-bit word or a 64-bit doubleword to the calculated address, from a register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
1 x 0 1 1 0 0 1 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STLUR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
STLUR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer datasize = 8 << scale;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1241

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, datasize DIV 8, AccType_ORDERED] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1242

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.266

STLURB
Store-Release Register Byte (unscaled) calculates an address from a base register value and an immediate offset,
and stores a byte to the calculated address, from a 32-bit register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 0 0 1 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
STLURB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 1, AccType_ORDERED] = data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1243

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1244

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.267

STLURH
Store-Release Register Halfword (unscaled) calculates an address from a base register value and an immediate
offset, and stores a halfword to the calculated address, from a 32-bit register.
The instruction has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139
For information about memory accesses, see Load/Store addressing modes on page C1-187.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 0 0 1 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
STLURH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 2, AccType_ORDERED] = data;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1245

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1246

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.268

STLXP
Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location
if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store
was successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. A 32-bit
pair requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit
pair requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic
update of the 128-bit memory location being updated. The instruction also has memory ordering semantics as
described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139. For information about memory
accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 sz 0 0 1 0 0 0 0 0 1
L

16 15 14
Rs

1
o0

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when sz == 0.
STLXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]

64-bit variant
Applies when sz == 1.
STLXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer
integer
integer
integer

n = UInt(Rn);
t = UInt(Rt);
t2 = UInt(Rt2);
s = UInt(Rs);

// ignored by load/store single register
// ignored by all loads and store-release

integer elsize = 32 << UInt(sz);
integer datasize = elsize * 2;
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STLXP on page K1-7977.

Assembler symbols
<Ws>

ARM DDI 0487F.c
ID072120

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:
0

If the operation updates memory.

1

If the operation fails to update memory.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1247

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xn|SP>

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
exception to be generated, subject to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t || (s == t2) then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(datasize) UNKNOWN;
else
bits(datasize DIV 2) el1 = X[t];
bits(datasize DIV 2) el2 = X[t2];
data = if BigEndian() then el1:el2 else el2:el1;
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, dbytes) then

C6-1248

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, dbytes, AccType_ORDEREDATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1249

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.269

STLXR
Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive
access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1
if no store was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic.
The instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139. For information about memory accesses see Load/Store addressing modes on
page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

1 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STLXR <Ws>, <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
STLXR <Ws>, <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

integer elsize = 8 << UInt(size);
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STLXR on page K1-7977.

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:

C6-1250

•

Memory is not updated.

•

<Ws> is not updated.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
exception to be generated, subject to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(elsize) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, dbytes) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, dbytes, AccType_ORDEREDATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1251

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.270

STLXRB
Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access
to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.
See Synchronization and semaphores on page B2-166. The memory access is atomic. The instruction also has
memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

1 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STLXRB on page K1-7977.

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(8) data;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then

C6-1252

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(8) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, 1) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, 1, AccType_ORDEREDATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1253

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.271

STLXRH
Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has
exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store
was performed. See Synchronization and semaphores on page B2-166. The memory access is atomic. The
instruction also has memory ordering semantics as described in Load-Acquire, Load-AcquirePC, and Store-Release
on page B2-139. For information about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

1 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

Encoding
STLXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STLXRH on page K1-7978.

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

A non halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject
to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

C6-1254

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) address;
bits(16) data;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(16) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, 2) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, 2, AccType_ORDEREDATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1255

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.272

STNP
Store Pair of Registers, with non-temporal hint, calculates an address from a base register value and an immediate
offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For
information about memory accesses, see Load/Store addressing modes on page C1-187. For information about
Non-temporal pair instructions, see Load/Store Non-temporal Pair on page C3-210.

31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 0 0 0
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 10.
STNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
// Empty.

Assembler symbols
<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc<0> == '1' then UNDEFINED;
integer scale = 2 + UInt(opc<1>);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = n != 31;

C6-1256

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data1 = X[t];
data2 = X[t2];
Mem[address, dbytes, AccType_STREAM] = data1;
Mem[address+dbytes, dbytes, AccType_STREAM] = data2;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1257

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.273

STP
Store Pair of Registers calculates an address from a base register value and an immediate offset, and stores two
32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information about
memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 0 1 0
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>

64-bit variant
Applies when opc == 10.
STP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;

Pre-index
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 1 1 0
opc
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!

64-bit variant
Applies when opc == 10.
STP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;

Signed offset
31 30 29 28 27 26 25 24 23 22 21
x 0 1 0 1 0 0 1 0 0
opc
L

C6-1258

15 14
imm7

10 9
Rt2

5 4
Rn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Rt

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

32-bit variant
Applies when opc == 00.
STP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 10.
STP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STP on page K1-7976.

Assembler symbols
<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.
For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.
For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if L:opc<0> == '01' || opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc<1>);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

Operation for all encodings
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1259

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if wback && (t == n || t2 == n) && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is pre-writeback
when Constraint_UNKNOWN rt_unknown = TRUE;
// value stored is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if rt_unknown && t == n then
data1 = bits(datasize) UNKNOWN;
else
data1 = X[t];
if rt_unknown && t2 == n then
data2 = bits(datasize) UNKNOWN;
else
data2 = X[t2];
Mem[address, dbytes, AccType_NORMAL] = data1;
Mem[address+dbytes, dbytes, AccType_NORMAL] = data2;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1260

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.274

STR (immediate)
Store Register (immediate) stores a word or a doubleword from a register to memory. The address that is used for
the store is calculated from a base register and an immediate offset. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STR <Wt>, [<Xn|SP>], #<simm>

64-bit variant
Applies when size == 11.
STR <Xt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STR <Wt>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when size == 11.
STR <Xt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1261

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
1 x 1 1 1 0 0 1 0 0
size
opc

10 9
imm12

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STR <Wt>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when size == 11.
STR <Xt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.
For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer datasize = 8 << scale;
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
boolean rt_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is original value

C6-1262

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

// value stored is UNKNOWN

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if rt_unknown then
data = bits(datasize) UNKNOWN;
else
data = X[t];
Mem[address, datasize DIV 8, AccType_NORMAL] = data;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1263

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.275

STR (register)
Store Register (register) calculates an address from a base register value and an offset register value, and stores a
32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory
accesses, see Load/Store addressing modes on page C1-187.
The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
register value and an offset register value. The offset can be optionally shifted and extended.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 0 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

64-bit variant
Applies when size == 11.
STR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for all variants of this encoding
integer scale = UInt(size);
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:

<amount>

C6-1264

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

For the 32-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#2

when S = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 64-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#3

when S = 1

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
integer datasize = 8 << scale;

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, datasize DIV 8, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1265

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.276

STRB (immediate)
Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is
used for the store is calculated from a base register and an immediate offset. For information about memory
accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

Encoding
STRB <Wt>, [<Xn|SP>], #<simm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

Encoding
STRB <Wt>, [<Xn|SP>, #<simm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 0 1 1 1 0 0 1 0 0
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
STRB <Wt>, [<Xn|SP>{, #<pimm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 0);

C6-1266

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STRB (immediate) on page K1-7978.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded
in the "imm12" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
boolean rt_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is original value
when Constraint_UNKNOWN rt_unknown = TRUE;
// value stored is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if rt_unknown then
data = bits(8) UNKNOWN;
else
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1267

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1268

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.277

STRB (register)
Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores
a byte from a 32-bit register to the calculated address. For information about memory accesses, see Load/Store
addressing modes on page C1-187.
The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
register value and an offset register value. The offset can be optionally shifted and extended.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 0 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Extended register variant
Applies when option != 011.
STRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

Shifted register variant
Applies when option == 011.
STRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

Decode for all variants of this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend specifier, encoded in the "option" field. It can have the following values:

<amount>

UXTW

when option = 010

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, it must be #0, encoded in "S" as 0 if omitted, or as 1 if present.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1269

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) offset = ExtendReg(m, extend_type, 0);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);
bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1270

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.278

STRH (immediate)
Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The
address that is used for the store is calculated from a base register and an immediate offset. For information about
memory accesses, see Load/Store addressing modes on page C1-187.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

Encoding
STRH <Wt>, [<Xn|SP>], #<simm>

Decode for this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

Encoding
STRH <Wt>, [<Xn|SP>, #<simm>]!

Decode for this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
0 1 1 1 1 0 0 1 0 0
size
opc

10 9
imm12

5 4
Rn

0
Rt

Encoding
STRH <Wt>, [<Xn|SP>{, #<pimm>}]

Decode for this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
bits(64) offset = LSL(ZeroExtend(imm12, 64), 1);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1271

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STRH (immediate) on page K1-7979.

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0
and encoded in the "imm12" field as <pimm>/2.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = wback || n != 31;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
boolean rt_unknown = FALSE;
if wback && n == t && n != 31 then
c = ConstrainUnpredictable();
assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_NONE
rt_unknown = FALSE;
// value stored is original value
when Constraint_UNKNOWN rt_unknown = TRUE;
// value stored is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if rt_unknown then
data = bits(16) UNKNOWN;
else
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1272

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1273

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.279

STRH (register)
Store Register Halfword (register) calculates an address from a base register value and an offset register value, and
stores a halfword from a 32-bit register to the calculated address. For information about memory accesses, see
Load/Store addressing modes on page C1-187.
The instruction uses an offset addressing mode, that calculates the address used for the memory access from a base
register value and an offset register value. The offset can be optionally shifted and extended.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 0 1
size
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

Encoding
STRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for this encoding
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then 1 else 0;

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

Is the index extend/shift specifier, defaulting to LSL, and which must be omitted for the LSL option
when <amount> is omitted. encoded in the "option" field. It can have the following values:

<amount>

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

Is the index shift amount, optional only when <extend> is not LSL. Where it is permitted to be
optional, it defaults to #0. It is encoded in the "S" field. It can have the following values:
#0

when S = 0

#1

when S = 1

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);

C6-1274

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(TRUE);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1275

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.280

STSETB, STSETLB
Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise
OR with the value held in a register on it, and stores the result back to memory.
•

STSETB does not have release semantics.

•

STSETLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSETB, LDSETAB, LDSETALB, LDSETLB instruction. This means that:
•

The encodings in this description are named to match the encodings of LDSETB, LDSETAB, LDSETALB,
LDSETLB.

•

The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSETB <Ws>, [<Xn|SP>]

is equivalent to
LDSETB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSETLB <Ws>, [<Xn|SP>]

is equivalent to
LDSETLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational pseudocode for this
instruction.

C6-1276

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1277

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.281

STSETH, STSETLH
Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs
a bitwise OR with the value held in a register on it, and stores the result back to memory.
•

STSETH does not have release semantics.

•

STSETLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSETH, LDSETAH, LDSETALH, LDSETLH instruction. This means that:
•

The encodings in this description are named to match the encodings of LDSETH, LDSETAH, LDSETALH,
LDSETLH.

•

The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSETH <Ws>, [<Xn|SP>]

is equivalent to
LDSETH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSETLH <Ws>, [<Xn|SP>]

is equivalent to
LDSETLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational pseudocode for this
instruction.

C6-1278

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1279

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.282

STSET, STSETL
Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit
doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back
to memory.
•

STSET does not have release semantics.

•

STSETL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSET, LDSETA, LDSETAL, LDSETL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDSET, LDSETA, LDSETAL,
LDSETL.

•

The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 0 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDSET alias variant
Applies when size == 10 && R == 0.
STSET <Ws>, [<Xn|SP>]

is equivalent to
LDSET <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDSETL alias variant
Applies when size == 10 && R == 1.
STSETL <Ws>, [<Xn|SP>]

is equivalent to
LDSETL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDSET alias variant
Applies when size == 11 && R == 0.
STSET <Xs>, [<Xn|SP>]

is equivalent to
LDSET <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

C6-1280

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSETL alias variant
Applies when size == 11 && R == 1.
STSETL <Xs>, [<Xn|SP>]

is equivalent to
LDSETL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1281

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.283

STSMAXB, STSMAXLB
Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares
it against the value held in a register, and stores the larger value back to memory, treating the values as signed
numbers.
•

STSMAXB does not have release semantics.

•

STSMAXLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB instruction. This
means that:
•

The encodings in this description are named to match the encodings of LDSMAXB, LDSMAXAB,
LDSMAXALB, LDSMAXLB.

•

The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSMAXB <Ws>, [<Xn|SP>]

is equivalent to
LDSMAXB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSMAXLB <Ws>, [<Xn|SP>]

is equivalent to
LDSMAXLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1282

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the operational pseudocode for
this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1283

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.284

STSMAXH, STSMAXLH
Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory,
compares it against the value held in a register, and stores the larger value back to memory, treating the values as
signed numbers.
•

STSMAXH does not have release semantics.

•

STSMAXLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH instruction. This
means that:
•

The encodings in this description are named to match the encodings of LDSMAXH, LDSMAXAH,
LDSMAXALH, LDSMAXLH.

•

The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSMAXH <Ws>, [<Xn|SP>]

is equivalent to
LDSMAXH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSMAXLH <Ws>, [<Xn|SP>]

is equivalent to
LDSMAXLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1284

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the operational pseudocode
for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1285

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.285

STSMAX, STSMAXL
Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or
64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back
to memory, treating the values as signed numbers.
•

STSMAX does not have release semantics.

•

STSMAXL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDSMAX, LDSMAXA,
LDSMAXAL, LDSMAXL.

•

The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDSMAX alias variant
Applies when size == 10 && R == 0.
STSMAX <Ws>, [<Xn|SP>]

is equivalent to
LDSMAX <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDSMAXL alias variant
Applies when size == 10 && R == 1.
STSMAXL <Ws>, [<Xn|SP>]

is equivalent to
LDSMAXL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDSMAX alias variant
Applies when size == 11 && R == 0.
STSMAX <Xs>, [<Xn|SP>]

is equivalent to
LDSMAX <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

C6-1286

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSMAXL alias variant
Applies when size == 11 && R == 1.
STSMAXL <Xs>, [<Xn|SP>]

is equivalent to
LDSMAXL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1287

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.286

STSMINB, STSMINLB
Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares
it against the value held in a register, and stores the smaller value back to memory, treating the values as signed
numbers.
•

STSMINB does not have release semantics.

•

STSMINLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB instruction. This means
that:
•

The encodings in this description are named to match the encodings of LDSMINB, LDSMINAB,
LDSMINALB, LDSMINLB.

•

The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational pseudocode
for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSMINB <Ws>, [<Xn|SP>]

is equivalent to
LDSMINB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSMINLB <Ws>, [<Xn|SP>]

is equivalent to
LDSMINLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1288

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1289

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.287

STSMINH, STSMINLH
Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory,
compares it against the value held in a register, and stores the smaller value back to memory, treating the values as
signed numbers.
•

STSMINH does not have release semantics.

•

STSMINLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH instruction. This means
that:
•

The encodings in this description are named to match the encodings of LDSMINH, LDSMINAH,
LDSMINALH, LDSMINLH.

•

The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational pseudocode
for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STSMINH <Ws>, [<Xn|SP>]

is equivalent to
LDSMINH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STSMINLH <Ws>, [<Xn|SP>]

is equivalent to
LDSMINLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1290

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the operational pseudocode for
this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1291

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.288

STSMIN, STSMINL
Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or
64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back
to memory, treating the values as signed numbers.
•

STSMIN does not have release semantics.

•

STSMINL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDSMIN, LDSMINA, LDSMINAL, LDSMINL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDSMIN, LDSMINA, LDSMINAL,
LDSMINL.

•

The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational pseudocode for this
instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 0 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDSMIN alias variant
Applies when size == 10 && R == 0.
STSMIN <Ws>, [<Xn|SP>]

is equivalent to
LDSMIN <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDSMINL alias variant
Applies when size == 10 && R == 1.
STSMINL <Ws>, [<Xn|SP>]

is equivalent to
LDSMINL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDSMIN alias variant
Applies when size == 11 && R == 0.
STSMIN <Xs>, [<Xn|SP>]

is equivalent to
LDSMIN <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

C6-1292

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDSMINL alias variant
Applies when size == 11 && R == 1.
STSMINL <Xs>, [<Xn|SP>]

is equivalent to
LDSMINL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1293

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.289

STTR
Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for
the store is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STTR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
STTR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;

C6-1294

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

integer datasize = 8 << scale;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, datasize DIV 8, acctype] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1295

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.290

STTRB
Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the
store is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

Encoding
STTRB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;

C6-1296

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 1, acctype] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1297

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.291

STTRH
Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used
for the store is calculated from a base register and an immediate offset.
Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the Effective value of
PSTATE.UAO is 0 and either:
•

The instruction is executed at EL1.

•

The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, TGE} is {1, 1}.

Otherwise, the memory access operates with the restrictions determined by the Exception level at which the
instruction is executed. For information about memory accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

1 0

5 4
Rn

0
Rt

Encoding
STTRH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.<NV,NV1> == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.<E2H,TGE> == '11';
user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
acctype = AccType_UNPRIV;
else
acctype = AccType_NORMAL;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;

C6-1298

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 2, acctype] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1299

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.292

STUMAXB, STUMAXLB
Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory,
compares it against the value held in a register, and stores the larger value back to memory, treating the values as
unsigned numbers.
•

STUMAXB does not have release semantics.

•

STUMAXLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB instruction. This
means that:
•

The encodings in this description are named to match the encodings of LDUMAXB, LDUMAXAB,
LDUMAXALB, LDUMAXLB.

•

The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STUMAXB <Ws>, [<Xn|SP>]

is equivalent to
LDUMAXB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STUMAXLB <Ws>, [<Xn|SP>]

is equivalent to
LDUMAXLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1300

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the operational pseudocode
for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1301

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.293

STUMAXH, STUMAXLH
Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from
memory, compares it against the value held in a register, and stores the larger value back to memory, treating the
values as unsigned numbers.
•

STUMAXH does not have release semantics.

•

STUMAXLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH instruction. This
means that:
•

The encodings in this description are named to match the encodings of LDUMAXH, LDUMAXAH,
LDUMAXALH, LDUMAXLH.

•

The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STUMAXH <Ws>, [<Xn|SP>]

is equivalent to
LDUMAXH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STUMAXLH <Ws>, [<Xn|SP>]

is equivalent to
LDUMAXLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1302

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the operational pseudocode
for this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1303

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.294

STUMAX, STUMAXL
Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or
64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back
to memory, treating the values as unsigned numbers.
•

STUMAX does not have release semantics.

•

STUMAXL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL instruction. This means
that:
•

The encodings in this description are named to match the encodings of LDUMAX, LDUMAXA,
LDUMAXAL, LDUMAXL.

•

The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational pseudocode
for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 0 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDUMAX alias variant
Applies when size == 10 && R == 0.
STUMAX <Ws>, [<Xn|SP>]

is equivalent to
LDUMAX <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDUMAXL alias variant
Applies when size == 10 && R == 1.
STUMAXL <Ws>, [<Xn|SP>]

is equivalent to
LDUMAXL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDUMAX alias variant
Applies when size == 11 && R == 0.
STUMAX <Xs>, [<Xn|SP>]

is equivalent to
LDUMAX <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

C6-1304

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDUMAXL alias variant
Applies when size == 11 && R == 1.
STUMAXL <Xs>, [<Xn|SP>]

is equivalent to
LDUMAXL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1305

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.295

STUMINB, STUMINLB
Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory,
compares it against the value held in a register, and stores the smaller value back to memory, treating the values as
unsigned numbers.
•

STUMINB does not have release semantics.

•

STUMINLB stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB instruction. This means
that:
•

The encodings in this description are named to match the encodings of LDUMINB, LDUMINAB,
LDUMINALB, LDUMINLB.

•

The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STUMINB <Ws>, [<Xn|SP>]

is equivalent to
LDUMINB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STUMINLB <Ws>, [<Xn|SP>]

is equivalent to
LDUMINLB <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1306

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the operational pseudocode for
this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1307

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.296

STUMINH, STUMINLH
Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from
memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the
values as unsigned numbers.
•

STUMINH does not have release semantics.

•

STUMINLH stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and

Store-Release on page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH instruction. This means
that:
•

The encodings in this description are named to match the encodings of LDUMINH, LDUMINAH,
LDUMINALH, LDUMINLH.

•

The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational
pseudocode for this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

No memory ordering variant
Applies when R == 0.
STUMINH <Ws>, [<Xn|SP>]

is equivalent to
LDUMINH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
Release variant
Applies when R == 1.
STUMINLH <Ws>, [<Xn|SP>]

is equivalent to
LDUMINLH <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols

C6-1308

<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the operational pseudocode for
this instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1309

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.297

STUMIN, STUMINL
Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or
64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back
to memory, treating the values as unsigned numbers.
•

STUMIN does not have release semantics.

•

STUMINL stores to memory with release semantics, as described in Load-Acquire, Load-AcquirePC, and
Store-Release on page B2-139.

For information about memory accesses see Load/Store addressing modes on page C1-187.
This instruction is an alias of the LDUMIN, LDUMINA, LDUMINAL, LDUMINL instruction. This means that:
•

The encodings in this description are named to match the encodings of LDUMIN, LDUMINA, LDUMINAL,
LDUMINL.

•

The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational pseudocode for
this instruction.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 R 1
size
A

16 15 14
Rs

12 11 10 9

0 1 1 1 0 0
opc

5 4
Rn

0

1 1 1 1 1
Rt

32-bit LDUMIN alias variant
Applies when size == 10 && R == 0.
STUMIN <Ws>, [<Xn|SP>]

is equivalent to
LDUMIN <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
32-bit LDUMINL alias variant
Applies when size == 10 && R == 1.
STUMINL <Ws>, [<Xn|SP>]

is equivalent to
LDUMINL <Ws>, WZR, [<Xn|SP>]

and is always the preferred disassembly.
64-bit LDUMIN alias variant
Applies when size == 11 && R == 0.
STUMIN <Xs>, [<Xn|SP>]

is equivalent to
LDUMIN <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

C6-1310

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

64-bit LDUMINL alias variant
Applies when size == 11 && R == 1.
STUMINL <Xs>, [<Xn|SP>]

is equivalent to
LDUMINL <Xs>, XZR, [<Xn|SP>]

and is always the preferred disassembly.

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xs>

Is the 64-bit name of the general-purpose register holding the data value to be operated on with the
contents of the memory location, encoded in the "Rs" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational pseudocode for this
instruction.

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1311

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.298

STUR
Store Register (unscaled) calculates an address from a base register value and an immediate offset, and stores a
32-bit word or a 64-bit doubleword to the calculated address, from a register. For information about memory
accesses, see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STUR <Wt>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11.
STUR <Xt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer datasize = 8 << scale;
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

C6-1312

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

address = address + offset;
data = X[t];
Mem[address, datasize DIV 8, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1313

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.299

STURB
Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores
a byte to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store
addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
STURB <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(8) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 1, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1314

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.300

STURH
Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and
stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 0 0 0
size
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

Encoding
STURH <Wt>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols
<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
boolean tag_checked = n != 31;

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
bits(64) address;
bits(16) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data = X[t];
Mem[address, 2, AccType_NORMAL] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1315

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.301

STXP
Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory
location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was
successful, or of 1 if no store was performed. See Synchronization and semaphores on page B2-166. A 32-bit pair
requires the address to be doubleword aligned and is single-copy atomic at doubleword granularity. A 64-bit pair
requires the address to be quadword aligned and, if the Store-Exclusive succeeds, it causes a single-copy atomic
update of the 128-bit memory location being updated. For information about memory accesses see Load/Store
addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 sz 0 0 1 0 0 0 0 0 1
L

16 15 14
Rs

0
o0

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when sz == 0.
STXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]

64-bit variant
Applies when sz == 1.
STXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer
integer
integer
integer

n = UInt(Rn);
t = UInt(Rt);
t2 = UInt(Rt2);
s = UInt(Rs);

// ignored by load/store single register
// ignored by all loads and store-release

integer elsize = 32 << UInt(sz);
integer datasize = elsize * 2;
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STXP on page K1-7979.

Assembler symbols
<Ws>

C6-1316

Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:
0

If the operation updates memory.

1

If the operation fails to update memory.

<Xt1>

Is the 64-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Xt2>

Is the 64-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

<Wt1>

Is the 32-bit name of the first general-purpose register to be transferred, encoded in the "Rt" field.

<Wt2>

Is the 32-bit name of the second general-purpose register to be transferred, encoded in the "Rt2"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xn|SP>

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
exception to be generated, subject to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t || (s == t2) then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(datasize) UNKNOWN;
else
bits(datasize DIV 2) el1 = X[t];
bits(datasize DIV 2) el2 = X[t2];
data = if BigEndian() then el1:el2 else el2:el1;
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, dbytes) then

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1317

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, dbytes, AccType_ATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1318

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.302

STXR
Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has
exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store
was performed. See Synchronization and semaphores on page B2-166. For information about memory accesses see
Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
1 x 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

0 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when size == 10.
STXR <Ws>, <Wt>, [<Xn|SP>{,#0}]

64-bit variant
Applies when size == 11.
STXR <Ws>, <Xt>, [<Xn|SP>{,#0}]

Decode for all variants of this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

integer elsize = 8 << UInt(size);
boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STXR on page K1-7979.

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:

ARM DDI 0487F.c
ID072120

•

Memory is not updated.

•

<Ws> is not updated.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1319

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Accessing an address that is not aligned to the size of the data being accessed causes an Alignment fault Data Abort
exception to be generated, subject to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(elsize) data;
constant integer dbytes = elsize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(elsize) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, dbytes) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, dbytes, AccType_ATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1320

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.303

STXRB
Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory
address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See
Synchronization and semaphores on page B2-166. The memory access is atomic.
For information about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

0 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

Encoding
STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

boolean tag_checked = n != 31;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly STXRB on page K1-7980.

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(8) data;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;
if HaveMTEExt() then

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1321

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(8) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, 1) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, 1, AccType_ATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1322

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.304

STXRH
Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to
the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed.
See Synchronization and semaphores on page B2-166. The memory access is atomic.
For information about memory accesses see Load/Store addressing modes on page C1-187.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 0 0 0 0 0 0
size
L

16 15 14
Rs

10 9

0 (1) (1) (1) (1) (1)
o0
Rt2

5 4
Rn

0
Rt

Encoding
STXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]

Decode for this encoding
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

// ignored by all loads and store-release

boolean tag_checked = n != 31;

Assembler symbols
Is the 32-bit name of the general-purpose register into which the status result of the store exclusive
is written, encoded in the "Rs" field. The value returned is:

<Ws>

0

If the operation updates memory.

1

If the operation fails to update memory.

<Wt>

Is the 32-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Aborts and alignment
If a synchronous Data Abort exception is generated by the execution of this instruction:
•

Memory is not updated.

•

<Ws> is not updated.

A non halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject
to the following rules:
•

If AArch64.ExclusiveMonitorsPass() returns TRUE, the exception is generated.

•

Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.

If AArch64.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a
synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated.

Operation
bits(64) address;
bits(16) data;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1323

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if s == t then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
when Constraint_NONE
rt_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if s == n && n != 31 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_NONE,
case c of
when Constraint_UNKNOWN rn_unknown = TRUE;
when Constraint_NONE
rn_unknown = FALSE;
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();

Constraint_UNDEF, Constraint_NOP};
// store UNKNOWN value
// store original value

Constraint_UNDEF, Constraint_NOP};
// address is UNKNOWN
// address is original base

if n == 31 then
CheckSPAlignment();
address = SP[];
elsif rn_unknown then
address = bits(64) UNKNOWN;
else
address = X[n];
if rt_unknown then
data = bits(16) UNKNOWN;
else
data = X[t];
bit status = '1';
// Check whether the Exclusives monitors are set to include the
// physical memory locations corresponding to virtual address
// range [address, address+dbytes-1].
if AArch64.ExclusiveMonitorsPass(address, 2) then
// This atomic write will be rejected if it does not refer
// to the same physical locations after address translation.
Mem[address, 2, AccType_ATOMIC] = data;
status = ExclusiveMonitorsStatus();
X[s] = ZeroExtend(status, 32);

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C6-1324

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.305

STZ2G
Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data
locations. The address used for the store is calculated from the base register and an immediate signed offset scaled
by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.
This instruction generates an Unchecked access.

Post-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 1 1

12 11 10 9
imm9

0 1

5 4
Xn

0
Xt

Encoding
STZ2G <Xt|SP>, [<Xn|SP>], #<simm>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

Pre-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 1 1

12 11 10 9
imm9

1 1

5 4
Xn

0
Xt

Encoding
STZ2G <Xt|SP>, [<Xn|SP>, #<simm>]!

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

Signed offset
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 1 1 1

ARM DDI 0487F.c
ID072120

12 11 10 9
imm9

1 0

5 4
Xn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Xt

C6-1325

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Encoding
STZ2G <Xt|SP>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Xt|SP>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<simm>

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0
and encoded in the "imm9" field.

Operation for all encodings
bits(64) address;
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
SetTagCheckedInstruction(FALSE);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if address != Align(address, TAG_GRANULE) then
AArch64.Abort(address, AArch64.AlignmentFault(AccType_NORMAL, TRUE, FALSE));
Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);
Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);
AArch64.MemTag[address, AccType_NORMAL] = tag;
AArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;
if writeback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1326

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.306

STZG
Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the associated data location. The address
used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The
Allocation Tag is calculated from the Logical Address Tag in the source register.
This instruction generates an Unchecked access.

Post-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 1 1

12 11 10 9
imm9

0 1

5 4
Xn

0
Xt

Encoding
STZG <Xt|SP>, [<Xn|SP>], #<simm>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

Pre-index
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 1 1

12 11 10 9
imm9

1 1

5 4
Xn

0
Xt

Encoding
STZG <Xt|SP>, [<Xn|SP>, #<simm>]!

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

Signed offset
ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 1 0 0 1 0 1 1

ARM DDI 0487F.c
ID072120

12 11 10 9
imm9

1 0

5 4
Xn

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

0
Xt

C6-1327

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Encoding
STZG <Xt|SP>, [<Xn|SP>{, #<simm>}]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Xt|SP>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

<simm>

Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0
and encoded in the "imm9" field.

Operation for all encodings
bits(64) address;
SetTagCheckedInstruction(FALSE);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
if address != Align(address, TAG_GRANULE) then
AArch64.Abort(address, AArch64.AlignmentFault(AccType_NORMAL, TRUE, FALSE));
Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
AArch64.MemTag[address, AccType_NORMAL] = tag;
if writeback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

C6-1328

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.307

STZGM
Store Tag and Zero Multiple writes a naturally aligned block of N Allocation Tags and stores zero to the associated
data locations, where the size of N is identified in DCZID_EL0.BS, and the Allocation Tag written to address A is
taken from the source register bits<3:0>.
This instruction is UNDEFINED at EL0.
This instruction generates an Unchecked access.
If ID_AA64PFR1_EL1 != 0b0010, this instruction is UNDEFINED.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 1 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0

5 4
Xn

0
Xt

Encoding
STZGM <Xt>, [<Xn|SP>]

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer t = UInt(Xt);
integer n = UInt(Xn);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.

Operation
if PSTATE.EL == EL0 then
UNDEFINED;
bits(64) data = X[t];
bits(4) tag = data<3:0>;
bits(64) address;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
integer size = 4 * (2 ^ (UInt(DCZID_EL0.BS)));
address = Align(address, size);
integer count = size >> LOG2_TAG_GRANULE;
for i = 0 to count-1
AArch64.MemTag[address, AccType_NORMAL] = tag;
Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8 * TAG_GRANULE);
address = address + TAG_GRANULE;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1329

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.308

SUB (extended register)
Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift
amount, from a register value, and writes the result to the destination register. The argument that is extended from
the <Rm> register can be a byte, halfword, word, or doubleword.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUB <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

64-bit variant
Applies when sf == 1.
SUB <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ExtendType extend_type = DecodeRegExtend(option);
integer shift = UInt(imm3);
if shift > 4 then UNDEFINED;

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

Is a width specifier, encoded in the "option" field. It can have the following values:

<m>

C6-1330

W

when option = 00x

W

when option = 010

X

when option = x11

W

when option = 10x

W

when option = 110

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:

<extend>

UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rd" or "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted
when "imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is
'010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rd" or "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
operand2 = NOT(operand2);
(result, -) = AddWithCarry(operand1, operand2, '1');
if d == 31 then
SP[] = result;
else
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1331

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

C6-1332

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.309

SUB (immediate)
Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to
the destination register.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUB <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}

64-bit variant
Applies when sf == 1.
SUB <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
case sh of
when '0' imm = ZeroExtend(imm12, datasize);
when '1' imm = ZeroExtend(imm12:Zeros(12), datasize);

Assembler symbols
<Wd|WSP>

Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Rd"
field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

when sh = 0

LSL #12

when sh = 1

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2;
operand2 = NOT(imm);
(result, -) = AddWithCarry(operand1, operand2, '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1333

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

if d == 31 then
SP[] = result;
else
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1334

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.310

SUB (shifted register)
Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result
to the destination register.
This instruction is used by the alias NEG (shifted register). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 0 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUB <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
SUB <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if shift == '11' then UNDEFINED;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

NEG (shifted register)

Rn == '11111'

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1335

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:

<shift>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
operand2 = NOT(operand2);
(result, -) = AddWithCarry(operand1, operand2, '1');
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1336

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.311

SUBG
Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register,
modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination
register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical
Address Tag.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21
1 1 0 1 0 0 0 1 1 0

16 15 14 13
uimm6

(0) (0)
op3

10 9
uimm4

5 4
Xn

0
Xd

Encoding
SUBG <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>

Decode for this encoding
if !HaveMTEExt() then UNDEFINED;
integer d = UInt(Xd);
integer n = UInt(Xn);
bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);

Assembler symbols
<Xd|SP>

Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the "Xd"
field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Xn" field.

<uimm6>

Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the "uimm6" field.

<uimm4>

Is an unsigned immediate, in the range 0 to 15, encoded in the "uimm4" field.

Operation
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);
bits(16) exclude = GCR_EL1.Exclude;
bits(64) result;
bits(4) rtag;
if AArch64.AllocationTagAccessIsEnabled(AccType_NORMAL) then
rtag = AArch64.ChooseNonExcludedTag(start_tag, uimm4, exclude);
else
rtag = '0000';
(result, -) = AddWithCarry(operand1, NOT(offset), '1');
result = AArch64.AddressWithAllocationTag(result, AccType_NORMAL, rtag);
if d == 31 then
SP[] = result;
else
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1337

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.312

SUBP
Subtract Pointer subtracts the 56-bit address held in the second source register from the 56-bit address held in the
first source register, sign-extends the result to 64-bits, and writes the result to the destination register.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Xm

0 0 0 0 0 0

5 4
Xn

0
Xd

Encoding
SUBP <Xd>, <Xn|SP>, <Xm|SP>

Decode for this encoding
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Xd" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Xn"
field.

<Xm|SP>

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the
"Xm" field.

Operation
bits(64)
bits(64)
operand1
operand2

operand1 = if n == 31 then SP[] else X[n];
operand2 = if m == 31 then SP[] else X[m];
= SignExtend(operand1<55:0>, 64);
= SignExtend(operand2<55:0>, 64);

bits(64) result;
operand2 = NOT(operand2);
(result, -) = AddWithCarry(operand1, operand2, '1');
X[d] = result;

C6-1338

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.313

SUBPS
Subtract Pointer, setting Flags subtracts the 56-bit address held in the second source register from the 56-bit address
held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register. It
updates the condition flags based on the result of the subtraction.
This instruction is used by the alias CMPP. See Alias conditions for details of when each alias is preferred.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20
1 0 1 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Xm

0 0 0 0 0 0

5 4
Xn

0
Xd

Encoding
SUBPS <Xd>, <Xn|SP>, <Xm|SP>

Decode for this encoding
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

Alias conditions
Alias

is preferred when

CMPP

S == '1' && Xd == '11111'

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Xd" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Xn"
field.

<Xm|SP>

Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the
"Xm" field.

Operation
bits(64)
bits(64)
operand1
operand2

operand1 = if n == 31 then SP[] else X[n];
operand2 = if m == 31 then SP[] else X[m];
= SignExtend(operand1<55:0>, 64);
= SignExtend(operand2<55:0>, 64);

bits(64) result;
bits(4) nzcv;
operand2 = NOT(operand2);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1339

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.314

SUBS (extended register)
Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional
left shift amount, from a register value, and writes the result to the destination register. The argument that is extended
from the <Rm> register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the
result.
This instruction is used by the alias CMP (extended register). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 1 0 0 1
op S

16 15
Rm

13 12

option

10 9

imm3

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUBS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}

64-bit variant
Applies when sf == 1.
SUBS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ExtendType extend_type = DecodeRegExtend(option);
integer shift = UInt(imm3);
if shift > 4 then UNDEFINED;

Alias conditions
Alias

is preferred when

CMP (extended register)

Rd == '11111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn|WSP>

Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the "Rn"
field.

<R>

Is a width specifier, encoded in the "option" field. It can have the following values:
W

C6-1340

when option = 00x

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

W

when option = 010

X

when option = x11

W

when option = 10x

W

when option = 110

<m>

Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in
the "Rm" field.

<extend>

For the 32-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

LSL|UXTW

when option = 010

UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (WSP) and "option" is '010' then LSL is preferred, but may be omitted when
"imm3" is '000'. In all other cases <extend> is required and must be UXTW when "option" is '010'.
For the 64-bit variant: is the extension to be applied to the second source operand, encoded in the
"option" field. It can have the following values:
UXTB

when option = 000

UXTH

when option = 001

UXTW

when option = 010

LSL|UXTX

when option = 011

SXTB

when option = 100

SXTH

when option = 101

SXTW

when option = 110

SXTX

when option = 111

If "Rn" is '11111' (SP) and "option" is '011' then LSL is preferred, but may be omitted when "imm3"
is '000'. In all other cases <extend> is required and must be UXTX when "option" is '011'.
Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in
the "imm3" field. It must be absent when <extend> is absent, is required when <extend> is LSL,
and is optional when <extend> is present but not LSL.

<amount>

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
bits(4) nzcv;
operand2 = NOT(operand2);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1341

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1342

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.315

SUBS (immediate)
Subtract (immediate), setting flags, subtracts an optionally-shifted immediate value from a register value, and writes
the result to the destination register. It updates the condition flags based on the result.
This instruction is used by the alias CMP (immediate). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 1 1 1 0 0 0 1 0 sh
op S

10 9
imm12

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUBS <Wd>, <Wn|WSP>, #<imm>{, <shift>}

64-bit variant
Applies when sf == 1.
SUBS <Xd>, <Xn|SP>, #<imm>{, <shift>}

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
bits(datasize) imm;
case sh of
when '0' imm = ZeroExtend(imm12, datasize);
when '1' imm = ZeroExtend(imm12:Zeros(12), datasize);

Alias conditions
Alias

is preferred when

CMP (immediate)

Rd == '11111'

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn|WSP>

Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn|SP>

Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the "Rn" field.

<imm>

Is an unsigned immediate, in the range 0 to 4095, encoded in the "imm12" field.

<shift>

Is the optional left shift to apply to the immediate, defaulting to LSL #0 and encoded in the "sh"
field. It can have the following values:
LSL #0

when sh = 0

LSL #12

when sh = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1343

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2;
bits(4) nzcv;
operand2 = NOT(imm);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1344

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.316

SUBS (shifted register)
Subtract (shifted register), setting flags, subtracts an optionally-shifted register value from a register value, and
writes the result to the destination register. It updates the condition flags based on the result.
This instruction is used by the aliases CMP (shifted register) and NEGS. See Alias conditions for details of when
each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 1 shift 0
op S

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
SUBS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}

64-bit variant
Applies when sf == 1.
SUBS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

if shift == '11' then UNDEFINED;
if sf == '0' && imm6<5> == '1' then UNDEFINED;
ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

Alias conditions
Alias

is preferred when

CMP (shifted register)

Rd == '11111'

NEGS

Rn == '11111'

Assembler symbols

ARM DDI 0487F.c
ID072120

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1345

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Is the optional shift type to be applied to the second source operand, defaulting to LSL and encoded
in the "shift" field. It can have the following values:

<shift>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

The encoding shift = 11 is reserved.
For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.

<amount>

For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field.

Operation
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
bits(4) nzcv;
operand2 = NOT(operand2);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');
PSTATE.<N,Z,C,V> = nzcv;
X[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1346

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.317

SVC
Supervisor Call causes an exception to be taken to EL1.
On executing an SVC instruction, the PE records the exception as a Supervisor Call exception in ESR_ELx, using the
EC value 0x15, and the value of the immediate argument.

31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 1 0 1 0 0 0 0 0

5 4 3 2 1 0
imm16

0 0 0 0 1

Encoding
SVC #<imm>

Decode for this encoding
// Empty.

Assembler symbols
Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field.

<imm>

Operation
AArch64.CheckForSVCTrap(imm16);
AArch64.CallSupervisor(imm16);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1347

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.318

SWPB, SWPAB, SWPALB, SWPLB
Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register
back to the same memory location. The value initially loaded from memory is returned in the destination register.
•

If the destination register is not WZR, SWPAB and SWPALB load from memory with acquire semantics.

•

SWPLB and SWPALB store to memory with release semantics.

•

SWPB has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 0 1 1 1 0 0 0 A R 1
size

16 15 14 13 12 11 10 9
Rs

1 0 0 0 0 0

5 4
Rn

0
Rt

SWPAB variant
Applies when A == 1 && R == 0.
SWPAB <Ws>, <Wt>, [<Xn|SP>]

SWPALB variant
Applies when A == 1 && R == 1.
SWPALB <Ws>, <Wt>, [<Xn|SP>]

SWPB variant
Applies when A == 0 && R == 0.
SWPB <Ws>, <Wt>, [<Xn|SP>]

SWPLB variant
Applies when A == 0 && R == 1.
SWPLB <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

Assembler symbols
<Ws>

C6-1348

Is the 32-bit name of the general-purpose register to be stored, encoded in the "Rs" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(8) data;
bits(8) store_value;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
store_value = X[s];
data = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);
X[t] = ZeroExtend(data, 32);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1349

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.319

SWPH, SWPAH, SWPALH, SWPLH
Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in
a register back to the same memory location. The value initially loaded from memory is returned in the destination
register.
•

If the destination register is not WZR, SWPAH and SWPALH load from memory with acquire semantics.

•

SWPLH and SWPALH store to memory with release semantics.

•

SWPH has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 0 0 0 A R 1
size

16 15 14 13 12 11 10 9
Rs

1 0 0 0 0 0

5 4
Rn

0
Rt

SWPAH variant
Applies when A == 1 && R == 0.
SWPAH <Ws>, <Wt>, [<Xn|SP>]

SWPALH variant
Applies when A == 1 && R == 1.
SWPALH <Ws>, <Wt>, [<Xn|SP>]

SWPH variant
Applies when A == 0 && R == 0.
SWPH <Ws>, <Wt>, [<Xn|SP>]

SWPLH variant
Applies when A == 0 && R == 1.
SWPLH <Ws>, <Wt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

Assembler symbols
<Ws>

C6-1350

Is the 32-bit name of the general-purpose register to be stored, encoded in the "Rs" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(16) data;
bits(16) store_value;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
store_value = X[s];
data = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);
X[t] = ZeroExtend(data, 32);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1351

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.320

SWP, SWPA, SWPAL, SWPL
Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location,
and stores the value held in a register back to the same memory location. The value initially loaded from memory
is returned in the destination register.
•

If the destination register is not one of WZR or XZR, SWPA and SWPAL load from memory with acquire semantics.

•

SWPL and SWPAL store to memory with release semantics.

•

SWP has neither acquire nor release semantics.

For more information about memory ordering semantics see Load-Acquire, Load-AcquirePC, and Store-Release on
page B2-139.
For information about memory accesses see Load/Store addressing modes on page C1-187.

ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
1 x 1 1 1 0 0 0 A R 1
size

16 15 14 13 12 11 10 9
Rs

1 0 0 0 0 0

5 4
Rn

0
Rt

32-bit SWP variant
Applies when size == 10 && A == 0 && R == 0.
SWP <Ws>, <Wt>, [<Xn|SP>]

32-bit SWPA variant
Applies when size == 10 && A == 1 && R == 0.
SWPA <Ws>, <Wt>, [<Xn|SP>]

32-bit SWPAL variant
Applies when size == 10 && A == 1 && R == 1.
SWPAL <Ws>, <Wt>, [<Xn|SP>]

32-bit SWPL variant
Applies when size == 10 && A == 0 && R == 1.
SWPL <Ws>, <Wt>, [<Xn|SP>]

64-bit SWP variant
Applies when size == 11 && A == 0 && R == 0.
SWP <Xs>, <Xt>, [<Xn|SP>]

64-bit SWPA variant
Applies when size == 11 && A == 1 && R == 0.
SWPA <Xs>, <Xt>, [<Xn|SP>]

64-bit SWPAL variant
Applies when size == 11 && A == 1 && R == 1.

C6-1352

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

SWPAL <Xs>, <Xt>, [<Xn|SP>]

64-bit SWPL variant
Applies when size == 11 && A == 0 && R == 1.
SWPL <Xs>, <Xt>, [<Xn|SP>]

Decode for all variants of this encoding
if !HaveAtomicExt() then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);
integer
integer
AccType
AccType
boolean

datasize = 8 << UInt(size);
regsize = if datasize == 64 then 64 else 32;
ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
tag_checked = n != 31;

Assembler symbols
<Ws>

Is the 32-bit name of the general-purpose register to be stored, encoded in the "Rs" field.

<Wt>

Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xs>

Is the 64-bit name of the general-purpose register to be stored, encoded in the "Rs" field.

<Xt>

Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Operation
bits(64) address;
bits(datasize) data;
bits(datasize) store_value;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
store_value = X[s];
data = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);
X[t] = ZeroExtend(data, regsize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1353

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.321

SXTB
Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the
result to the destination register.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

16 15

10 9

sf 0 0 1 0 0 1 1 0 N 0 0 0 0 0 0 0 0 0 1 1 1
opc
immr
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
SXTB <Wd>, <Wn>

is equivalent to
SBFM <Wd>, <Wn>, #0, #7

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1 && N == 1.
SXTB <Xd>, <Wn>

is equivalent to
SBFM <Xd>, <Xn>, #0, #7

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

C6-1354

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1355

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.322

SXTH
Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of the register, and writes the result to the
destination register.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

16 15

10 9

sf 0 0 1 0 0 1 1 0 N 0 0 0 0 0 0 0 0 1 1 1 1
opc
immr
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
SXTH <Wd>, <Wn>

is equivalent to
SBFM <Wd>, <Wn>, #0, #15

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1 && N == 1.
SXTH <Xd>, <Wn>

is equivalent to
SBFM <Xd>, <Xn>, #0, #15

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

C6-1356

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1357

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.323

SXTW
Sign Extend Word sign-extends a word to the size of the register, and writes the result to the destination register.
This instruction is an alias of the SBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of SBFM.

•

The description of SBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

16 15

10 9

1 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1
sf opc
N
immr
imms

5 4
Rn

0
Rd

64-bit variant
SXTW <Xd>, <Wn>

is equivalent to
SBFM <Xd>, <Xn>, #0, #31

and is always the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of SBFM gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1358

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.324

SYS
System instruction. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address
translation instructions on page C5-377 for the encodings of System instructions.
This instruction is used by the aliases AT, CFP, CPP, DC, DVP, IC, and TLBI. See Alias conditions for details of
when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 1
L

16 15
op1

12 11
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}

Decode for this encoding
AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
integer t = UInt(Rt);
integer
integer
integer
integer

sys_op1
sys_op2
sys_crn
sys_crm

=
=
=
=

UInt(op1);
UInt(op2);
UInt(CRn);
UInt(CRm);

Alias conditions
Alias

is preferred when

AT

CRn == '0111' && CRm == '100x' && SysOp(op1,'0111',CRm,op2) == Sys_AT

CFP

op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '100'

CPP

op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '111'

DC

CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_DC

DVP

op1 == '011' && CRn == '0111' && CRm == '0011' && op2 == '101'

IC

CRn == '0111' && SysOp(op1,'0111',CRm,op2) == Sys_IC

TLBI

CRn == '1000' && SysOp(op1,'1000',CRm,op2) == Sys_TLBI

Assembler symbols

ARM DDI 0487F.c
ID072120

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cn>

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<Xt>

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
the "Rt" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1359

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
AArch64.SysInstr(1, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);

C6-1360

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.325

SYSL
System instruction with result. For more information, see op0==0b01, cache maintenance, TLB maintenance, and
address translation instructions on page C5-377 for the encodings of System instructions.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 1 0 1
L

16 15
op1

12 11
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>

Decode for this encoding
AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);
integer t = UInt(Rt);
integer
integer
integer
integer

sys_op1
sys_op2
sys_crn
sys_crm

=
=
=
=

UInt(op1);
UInt(op2);
UInt(CRn);
UInt(CRm);

Assembler symbols
<Xt>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rt" field.

<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cn>

Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the "CRn" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

Operation
// No architecturally defined instructions here.
X[t] = AArch64.SysInstrWithResult(1, sys_op1, sys_crn, sys_crm, sys_op2);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1361

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.326

TBNZ
Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally
branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine
call or return. This instruction does not affect condition flags.

31 30 29 28 27 26 25 24 23
b5 0 1 1 0 1 1 1
op

19 18
b40

5 4
imm14

0
Rt

Encoding
TBNZ <R><t>, #<imm>, <label>

Decode for this encoding
integer t = UInt(Rt);
integer datasize = if b5 == '1' then 64 else 32;
integer bit_pos = UInt(b5:b40);
bits(64) offset = SignExtend(imm14:'00', 64);

Assembler symbols
Is a width specifier, encoded in the "b5" field. It can have the following values:

<R>

W

when b5 = 0

X

when b5 = 1

In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted
when the bit number is less than 32.
<t>

Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in
the "Rt" field.

<imm>

Is the bit number to be tested, in the range 0 to 63, encoded in "b5:b40".

<label>

Is the program label to be conditionally branched to. Its offset from the address of this instruction,
in the range +/-32KB, is encoded as "imm14" times 4.

Operation
bits(datasize) operand = X[t];
if operand<bit_pos> == op then
BranchTo(PC[] + offset, BranchType_DIR);

C6-1362

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.327

TBZ
Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a
PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This
instruction does not affect condition flags.

31 30 29 28 27 26 25 24 23
b5 0 1 1 0 1 1 0
op

19 18
b40

5 4
imm14

0
Rt

Encoding
TBZ <R><t>, #<imm>, <label>

Decode for this encoding
integer t = UInt(Rt);
integer datasize = if b5 == '1' then 64 else 32;
integer bit_pos = UInt(b5:b40);
bits(64) offset = SignExtend(imm14:'00', 64);

Assembler symbols
Is a width specifier, encoded in the "b5" field. It can have the following values:

<R>

W

when b5 = 0

X

when b5 = 1

In assembler source code an 'X' specifier is always permitted, but a 'W' specifier is only permitted
when the bit number is less than 32.
<t>

Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in
the "Rt" field.

<imm>

Is the bit number to be tested, in the range 0 to 63, encoded in "b5:b40".

<label>

Is the program label to be conditionally branched to. Its offset from the address of this instruction,
in the range +/-32KB, is encoded as "imm14" times 4.

Operation
bits(datasize) operand = X[t];
if operand<bit_pos> == op then
BranchTo(PC[] + offset, BranchType_DIR);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1363

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.328

TLBI
TLB Invalidate operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and
address translation instructions on page C5-377.
This instruction is an alias of the SYS instruction. This means that:
•

The encodings in this description are named to match the encodings of SYS.

•

The description of SYS gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18
1 1 0 1 0 1 0 1 0 0 0 0 1
L

16 15
op1

12 11

1 0 0 0
CRn

8 7
CRm

5 4
op2

0
Rt

Encoding
TLBI <tlbi_op>{, <Xt>}

is equivalent to
SYS #<op1>, C8, <Cm>, #<op2>{, <Xt>}

and is the preferred disassembly when SysOp(op1,'1000',CRm,op2) == Sys_TLBI.

Assembler symbols
<op1>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op1" field.

<Cm>

Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the "CRm" field.

<op2>

Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the "op2" field.

<tlbi_op>

Is a TLBI instruction name, as listed for the TLBI system instruction group, encoded in the
"op1:CRm:op2" field. It can have the following values:
VMALLE1IS when op1 = 000, CRm = 0011, op2 = 000
VAE1IS

when op1 = 000, CRm = 0011, op2 = 001

ASIDE1IS

when op1 = 000, CRm = 0011, op2 = 010

VAAE1IS

when op1 = 000, CRm = 0011, op2 = 011

VALE1IS

when op1 = 000, CRm = 0011, op2 = 101

VAALE1IS

when op1 = 000, CRm = 0011, op2 = 111

VMALLE1

when op1 = 000, CRm = 0111, op2 = 000

VAE1

when op1 = 000, CRm = 0111, op2 = 001

ASIDE1

when op1 = 000, CRm = 0111, op2 = 010

VAAE1

when op1 = 000, CRm = 0111, op2 = 011

VALE1

when op1 = 000, CRm = 0111, op2 = 101

VAALE1

when op1 = 000, CRm = 0111, op2 = 111

IPAS2E1IS when op1 = 100, CRm = 0000, op2 = 001
IPAS2LE1IS when op1 = 100, CRm = 0000, op2 = 101

C6-1364

ALLE2IS

when op1 = 100, CRm = 0011, op2 = 000

VAE2IS

when op1 = 100, CRm = 0011, op2 = 001

ALLE1IS

when op1 = 100, CRm = 0011, op2 = 100

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

VALE2IS

when op1 = 100, CRm = 0011, op2 = 101

VMALLS12E1ISwhen op1 = 100, CRm = 0011, op2 = 110
IPAS2E1

when op1 = 100, CRm = 0100, op2 = 001

IPAS2LE1

when op1 = 100, CRm = 0100, op2 = 101

ALLE2

when op1 = 100, CRm = 0111, op2 = 000

VAE2

when op1 = 100, CRm = 0111, op2 = 001

ALLE1

when op1 = 100, CRm = 0111, op2 = 100

VALE2

when op1 = 100, CRm = 0111, op2 = 101

VMALLS12E1 when op1 = 100, CRm = 0111, op2 = 110
ALLE3IS

when op1 = 110, CRm = 0011, op2 = 000

VAE3IS

when op1 = 110, CRm = 0011, op2 = 001

VALE3IS

when op1 = 110, CRm = 0011, op2 = 101

ALLE3

when op1 = 110, CRm = 0111, op2 = 000

VAE3

when op1 = 110, CRm = 0111, op2 = 001

VALE3

when op1 = 110, CRm = 0111, op2 = 101

When FEAT_TLBIOS is implemented, the following values are also valid:
VMALLE1OS when op1 = 000, CRm = 0001, op2 = 000
VAE1OS

when op1 = 000, CRm = 0001, op2 = 001

ASIDE1OS

when op1 = 000, CRm = 0001, op2 = 010

VAAE1OS

when op1 = 000, CRm = 0001, op2 = 011

VALE1OS

when op1 = 000, CRm = 0001, op2 = 101

VAALE1OS

when op1 = 000, CRm = 0001, op2 = 111

ALLE2OS

when op1 = 100, CRm = 0001, op2 = 000

VAE2OS

when op1 = 100, CRm = 0001, op2 = 001

ALLE1OS

when op1 = 100, CRm = 0001, op2 = 100

VALE2OS

when op1 = 100, CRm = 0001, op2 = 101

VMALLS12E1OSwhen op1 = 100, CRm = 0001, op2 = 110
IPAS2E1OS when op1 = 100, CRm = 0100, op2 = 000
IPAS2LE1OS when op1 = 100, CRm = 0100, op2 = 100
ALLE3OS

when op1 = 110, CRm = 0001, op2 = 000

VAE3OS

when op1 = 110, CRm = 0001, op2 = 001

VALE3OS

when op1 = 110, CRm = 0001, op2 = 101

When FEAT_TLBIRANGE is implemented, the following values are also valid:
RVAE1IS

when op1 = 000, CRm = 0010, op2 = 001

RVAAE1IS

when op1 = 000, CRm = 0010, op2 = 011

RVALE1IS

when op1 = 000, CRm = 0010, op2 = 101

RVAALE1IS when op1 = 000, CRm = 0010, op2 = 111
RVAE1OS

when op1 = 000, CRm = 0101, op2 = 001

RVAAE1OS

when op1 = 000, CRm = 0101, op2 = 011

RVALE1OS

when op1 = 000, CRm = 0101, op2 = 101

RVAALE1OS when op1 = 000, CRm = 0101, op2 = 111

ARM DDI 0487F.c
ID072120

RVAE1

when op1 = 000, CRm = 0110, op2 = 001

RVAAE1

when op1 = 000, CRm = 0110, op2 = 011

RVALE1

when op1 = 000, CRm = 0110, op2 = 101

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1365

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

RVAALE1

when op1 = 000, CRm = 0110, op2 = 111

RIPAS2E1IS when op1 = 100, CRm = 0000, op2 = 010
RIPAS2LE1ISwhen op1 = 100, CRm = 0000, op2 = 110
RVAE2IS

when op1 = 100, CRm = 0010, op2 = 001

RVALE2IS

when op1 = 100, CRm = 0010, op2 = 101

RIPAS2E1

when op1 = 100, CRm = 0100, op2 = 010

RIPAS2E1OS when op1 = 100, CRm = 0100, op2 = 011
RIPAS2LE1 when op1 = 100, CRm = 0100, op2 = 110
RIPAS2LE1OSwhen op1 = 100, CRm = 0100, op2 = 111
RVAE2OS

when op1 = 100, CRm = 0101, op2 = 001

RVALE2OS

when op1 = 100, CRm = 0101, op2 = 101

RVAE2

when op1 = 100, CRm = 0110, op2 = 001

RVALE2

when op1 = 100, CRm = 0110, op2 = 101

RVAE3IS

when op1 = 110, CRm = 0010, op2 = 001

RVALE3IS

when op1 = 110, CRm = 0010, op2 = 101

RVAE3OS

when op1 = 110, CRm = 0101, op2 = 001

RVALE3OS

when op1 = 110, CRm = 0101, op2 = 101

RVAE3

when op1 = 110, CRm = 0110, op2 = 001

RVALE3

when op1 = 110, CRm = 0110, op2 = 101

Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in
the "Rt" field.

<Xt>

Operation
The description of SYS gives the operational pseudocode for this instruction.

C6-1366

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.329

TSB CSYNC
Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions.
If FEAT_TRF is not implemented, this instruction executes as a NOP.

ARMv8.4
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0 0 1 0 1 1 1 1 1
CRm
op2

Encoding
TSB CSYNC

Decode for this encoding
if !HaveSelfHostedTrace() then EndOfInstruction();

Operation
TraceSynchronizationBarrier();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1367

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.330

TST (immediate)
Test bits (immediate), setting the condition flags and discarding the result : Rn AND imm
This instruction is an alias of the ANDS (immediate) instruction. This means that:
•

The encodings in this description are named to match the encodings of ANDS (immediate).

•

The description of ANDS (immediate) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 1 1 0 0 1 0 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0 && N == 0.
TST <Wn>, #<imm>

is equivalent to
ANDS WZR, <Wn>, #<imm>

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
TST <Xn>, #<imm>

is equivalent to
ANDS XZR, <Xn>, #<imm>

and is always the preferred disassembly.

Assembler symbols
<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the bitmask immediate, encoded in "imms:immr".
For the 64-bit variant: is the bitmask immediate, encoded in "N:imms:immr".

Operation
The description of ANDS (immediate) gives the operational pseudocode for this instruction.

C6-1368

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.331

TST (shifted register)
Test (shifted register) performs a bitwise AND operation on a register value and an optionally-shifted register value.
It updates the condition flags based on the result, and discards the result.
This instruction is an alias of the ANDS (shifted register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ANDS (shifted register).

•

The description of ANDS (shifted register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
sf 1 1 0 1 0 1 0 shift 0
opc
N

16 15
Rm

10 9
imm6

5 4
Rn

0

1 1 1 1 1
Rd

32-bit variant
Applies when sf == 0.
TST <Wn>, <Wm>{, <shift> #<amount>}

is equivalent to
ANDS WZR, <Wn>, <Wm>{, <shift> #<amount>}

and is always the preferred disassembly.
64-bit variant
Applies when sf == 1.
TST <Xn>, <Xm>{, <shift> #<amount>}

is equivalent to
ANDS XZR, <Xn>, <Xm>{, <shift> #<amount>}

and is always the preferred disassembly.

Assembler symbols
<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

<shift>

Is the optional shift to be applied to the final source, defaulting to LSL and encoded in the "shift"
field. It can have the following values:

<amount>

LSL

when shift = 00

LSR

when shift = 01

ASR

when shift = 10

ROR

when shift = 11

For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the
"imm6" field.
For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the
"imm6" field,

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1369

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operation
The description of ANDS (shifted register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1370

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.332

UBFIZ
Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the least significant bits of the source register
to bit position <lsb> of the destination register, setting the destination bits above and below the bitfield to zero.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
UBFIZ <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
UBFM <Wd>, <Wn>, #(-<lsb> MOD 32), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).
64-bit variant
Applies when sf == 1 && N == 1.
UBFIZ <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
UBFM <Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)

and is the preferred disassembly when UInt(imms) < UInt(immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1371

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1372

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.333

UBFM
Unsigned Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly.
If <imms> is greater than or equal to <immr>, this copies a bitfield of (<imms>-<immr>+1) bits starting from bit position
<immr> in the source register to the least significant bits of the destination register.
If <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from the least significant bits of the source
register to bit position (regsize-<immr>) of the destination register, where regsize is the destination register size of 32
or 64 bits.
In both cases the destination bits below and above the bitfield are set to zero.
This instruction is used by the aliases LSL (immediate), LSR (immediate), UBFIZ, UBFX, UXTB, and UXTH. See
Alias conditions on page C6-1374 for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
UBFM <Wd>, <Wn>, #<immr>, #<imms>

64-bit variant
Applies when sf == 1 && N == 1.
UBFM <Xd>, <Xn>, #<immr>, #<imms>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
integer R;
bits(datasize) wmask;
bits(datasize) tmask;
if sf == '1' && N != '1' then UNDEFINED;
if sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then UNDEFINED;
R = UInt(immr);
(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1373

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Alias conditions
Alias

of variant

is preferred when

LSL (immediate)

32-bit

imms != '011111' && imms + 1 == immr

LSL (immediate)

64-bit

imms != '111111' && imms + 1 == immr

LSR (immediate)

32-bit

imms == '011111'

LSR (immediate)

64-bit

imms == '111111'

UBFIZ

-

UInt(imms) < UInt(immr)

UBFX

-

BFXPreferred(sf, opc<1>, imms, immr)

UXTB

-

immr == '000000' && imms == '000111'

UXTH

-

immr == '000000' && imms == '001111'

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<immr>

For the 32-bit variant: is the right rotate amount, in the range 0 to 31, encoded in the "immr" field.
For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the "immr" field.
For the 32-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 31,
encoded in the "imms" field.

<imms>

For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63,
encoded in the "imms" field.

Operation
bits(datasize) src = X[n];
// perform bitfield move on low bits
bits(datasize) bot = ROR(src, R) AND wmask;
// combine extension bits and result bits
X[d] = bot AND tmask;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1374

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.334

UBFX
Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit position <lsb> in the source register to
the least significant bits of the destination register, and sets destination bits above the bitfield to zero.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21
sf 1 0 1 0 0 1 1 0 N
opc

16 15
immr

10 9
imms

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0 && N == 0.
UBFX <Wd>, <Wn>, #<lsb>, #<width>

is equivalent to
UBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).
64-bit variant
Applies when sf == 1 && N == 1.
UBFX <Xd>, <Xn>, #<lsb>, #<width>

is equivalent to
UBFM <Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)

and is the preferred disassembly when BFXPreferred(sf, opc<1>, imms, immr).

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<lsb>

For the 32-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 31.
For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.
For the 32-bit variant: is the width of the bitfield, in the range 1 to 32-<lsb>.

<width>

For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-<lsb>.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1375

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1376

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.335

UDF
Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC = 0b000000). The encodings
for UDF used in this section are defined as permanently UNDEFINED in the Armv8-A architecture.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0
imm16

Encoding
UDF #<imm>

Decode for this encoding
// The imm16 field is ignored by hardware.
UNDEFINED;

Assembler symbols
is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the "imm16" field. The PE
ignores the value of this constant.

<imm>

Operation
// No operation.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1377

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.336

UDIV
Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes
the result to the destination register. The condition flags are not affected.

31 30 29 28 27 26 25 24 23 22 21 20
sf 0 0 1 1 0 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 0
o1

5 4
Rn

0
Rd

32-bit variant
Applies when sf == 0.
UDIV <Wd>, <Wn>, <Wm>

64-bit variant
Applies when sf == 1.
UDIV <Xd>, <Xn>, <Xm>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if sf == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register, encoded in the "Rm" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register, encoded in the "Rm" field.

Operation
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
integer result;
if IsZero(operand2) then
result = 0;
else
result = RoundTowardsZero(Real(Int(operand1, TRUE)) / Real(Int(operand2, TRUE)));
X[d] = result<datasize-1:0>;

C6-1378

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.337

UMADDL
Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result
to the 64-bit destination register.
This instruction is used by the alias UMULL. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 1 0 1
U

16 15 14
Rm

0
o0

10 9
Ra

5 4
Rn

0
Rd

Encoding
UMADDL <Xd>, <Wn>, <Wm>, <Xa>

Decode for this encoding
integer
integer
integer
integer

d
n
m
a

=
=
=
=

UInt(Rd);
UInt(Rn);
UInt(Rm);
UInt(Ra);

Alias conditions
Alias

is preferred when

UMULL

Ra == '11111'

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xa>

Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the
"Ra" field.

Operation
bits(32) operand1 = X[n];
bits(32) operand2 = X[m];
bits(64) operand3 = X[a];
integer result;
result = Int(operand3, TRUE) + (Int(operand1, TRUE) * Int(operand2, TRUE));
X[d] = result<63:0>;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1379

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

C6-1380

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.338

UMNEGL
Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to
the 64-bit destination register.
This instruction is an alias of the UMSUBL instruction. This means that:
•

The encodings in this description are named to match the encodings of UMSUBL.

•

The description of UMSUBL gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 1 0 1
U

16 15 14
Rm

10 9

1 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

Encoding
UMNEGL <Xd>, <Wn>, <Wm>

is equivalent to
UMSUBL <Xd>, <Wn>, <Wm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of UMSUBL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1381

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.339

UMSUBL
Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register
value, and writes the result to the 64-bit destination register.
This instruction is used by the alias UMNEGL. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 1 0 1
U

16 15 14
Rm

1
o0

10 9
Ra

5 4
Rn

0
Rd

Encoding
UMSUBL <Xd>, <Wn>, <Wm>, <Xa>

Decode for this encoding
integer
integer
integer
integer

d
n
m
a

=
=
=
=

UInt(Rd);
UInt(Rn);
UInt(Rm);
UInt(Ra);

Alias conditions
Alias

is preferred when

UMNEGL

Ra == '11111'

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

<Xa>

Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the
"Ra" field.

Operation
bits(32) operand1 = X[n];
bits(32) operand2 = X[m];
bits(64) operand3 = X[a];
integer result;
result = Int(operand3, TRUE) - (Int(operand1, TRUE) * Int(operand2, TRUE));
X[d] = result<63:0>;

C6-1382

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1383

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.340

UMULH
Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the
64-bit destination register.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 1 1 0
U

16 15 14
Rm

10 9

0 (1) (1) (1) (1) (1)
Ra

5 4
Rn

0
Rd

Encoding
UMULH <Xd>, <Xn>, <Xm>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Xm>

Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
bits(64) operand1 = X[n];
bits(64) operand2 = X[m];
integer result;
result = Int(operand1, TRUE) * Int(operand2, TRUE);
X[d] = result<127:64>;

Operational information
If PSTATE.DIT is 1:
•

•

C6-1384

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.341

UMULL
Unsigned Multiply Long multiplies two 32-bit register values, and writes the result to the 64-bit destination register.
This instruction is an alias of the UMADDL instruction. This means that:
•

The encodings in this description are named to match the encodings of UMADDL.

•

The description of UMADDL gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
1 0 0 1 1 0 1 1 1 0 1
U

16 15 14
Rm

10 9

0 1 1 1 1 1
o0
Ra

5 4
Rn

0
Rd

Encoding
UMULL <Xd>, <Wn>, <Wm>

is equivalent to
UMADDL <Xd>, <Wn>, <Wm>, XZR

and is always the preferred disassembly.

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in
the "Rn" field.

<Wm>

Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in
the "Rm" field.

Operation
The description of UMADDL gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1385

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.342

UXTB
Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes
the result to the destination register.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

16 15

10 9

0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1
sf opc
N
immr
imms

5 4
Rn

0
Rd

32-bit variant
UXTB <Wd>, <Wn>

is equivalent to
UBFM <Wd>, <Wn>, #0, #7

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C6-1386

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.343

UXTH
Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to the size of the register, and
writes the result to the destination register.
This instruction is an alias of the UBFM instruction. This means that:
•

The encodings in this description are named to match the encodings of UBFM.

•

The description of UBFM gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21

16 15

10 9

0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1
sf opc
N
immr
imms

5 4
Rn

0
Rd

32-bit variant
UXTH <Wd>, <Wn>

is equivalent to
UBFM <Wd>, <Wn>, #0, #15

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
The description of UBFM gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1387

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.344

WFE
Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a
wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any
PE in the multiprocessor system. For more information, see Wait for Event mechanism and Send event on
page D1-2391.
As described in Wait for Event mechanism and Send event on page D1-2391, the execution of a WFE instruction that
would otherwise cause entry to a low-power state can be trapped to a higher Exception level. See:
•

Traps to EL1 of EL0 execution of WFE and WFI instructions on page D1-2371.

•

Traps to EL2 of EL0 and EL1 execution of WFE and WFI instructions on page D1-2380.

•

Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions on page D1-2387.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 0 1 1 1 1 1
CRm
op2

Encoding
WFE

Decode for this encoding
// Empty.

Operation
if IsEventRegisterSet() then
ClearEventRegister();
else
trap = FALSE;
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
if HaveTWEDExt() then
- = SCTLR[];
trap = sctlr.nTWE == '0';
target_el = EL1;
else
AArch64.CheckForWFxTrap(EL1, TRUE);
if !trap && PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
if HaveTWEDExt() then
trap = HCR_EL2.TWE == '1';
target_el = EL2;
else
AArch64.CheckForWFxTrap(EL2, TRUE);
if !trap && HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
if HaveTWEDExt() then
trap = SCR_EL3.TWE == '1';
target_el = EL3;
else
AArch64.CheckForWFxTrap(EL3, TRUE);
if HaveTWEDExt() && trap && PSTATE.EL != EL3 then
(delay_enabled, delay) = WFETrapDelay(target_el);
// (If trap delay is enabled, Delay amount)
if !WaitForEventUntilDelay(delay_enabled, delay) then

C6-1388

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

// Event did not arrive before delay expired
AArch64.WFxTrap(target_el, TRUE);
// Trap WFE
else
WaitForEvent();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1389

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.345

WFI
Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until
a wakeup event occurs. For more information, see Wait For Interrupt on page D1-2394.
As described in Wait For Interrupt on page D1-2394, the execution of a WFI instruction that would otherwise cause
entry to a low-power state can be trapped to a higher Exception level. See:
•

Traps to EL1 of EL0 execution of WFE and WFI instructions on page D1-2371.

•

Traps to EL2 of EL0 and EL1 execution of WFE and WFI instructions on page D1-2380.

•

Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions on page D1-2387.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 1 1 1 1 1
CRm
op2

Encoding
WFI

Decode for this encoding
// Empty.

Operation
if !InterruptPending() then
if PSTATE.EL == EL0 then
// Check for traps described by the OS which may be EL1 or EL2.
AArch64.CheckForWFxTrap(EL1, FALSE);
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
// Check for traps described by the Hypervisor.
AArch64.CheckForWFxTrap(EL2, FALSE);
if HaveEL(EL3) && PSTATE.EL != EL3 then
// Check for traps described by the Secure Monitor.
AArch64.CheckForWFxTrap(EL3, FALSE);
WaitForInterrupt();

C6-1390

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.346

XAFLAG
Convert floating-point condition flags from external format to Arm format. This instruction converts the state of the
PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the
result of an Arm floating-point scalar compare instruction.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7 6 5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 (0) (0) (0) (0) 0 0 1 1 1 1 1 1
CRm

Encoding
XAFLAG

Decode for this encoding
if !HaveFlagFormatExt() then UNDEFINED;

Operation
bit
bit
bit
bit

N
Z
C
V

=
=
=
=

NOT(PSTATE.C) AND NOT(PSTATE.Z);
PSTATE.Z AND PSTATE.C;
PSTATE.C OR PSTATE.Z;
NOT(PSTATE.C) AND PSTATE.Z;

PSTATE.N
PSTATE.Z
PSTATE.C
PSTATE.V

ARM DDI 0487F.c
ID072120

=
=
=
=

N;
Z;
C;
V;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1391

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.347

XPACD, XPACI, XPACLRI
Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The
address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI.
The XPACD instruction is used for data addresses, and XPACI and XPACLRI are used for instruction addresses.

Integer
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

5 4

1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 D 1 1 1 1 1
Rn

0
Rd

XPACD variant
Applies when D == 1.
XPACD <Xd>

XPACI variant
Applies when D == 0.
XPACI <Xd>

Decode for all variants of this encoding
boolean data = (D == '1');
integer d = UInt(Rd);
if !HavePACExt() then
UNDEFINED;

System
ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1

Encoding
XPACLRI

Decode for this encoding
integer d = 30;
boolean data = FALSE;

Assembler symbols
<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

Operation for all encodings
if HavePACExt() then
X[d] = Strip(X[d], data);

C6-1392

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Base Instruction Descriptions
C6.2 Alphabetical list of A64 base instructions

C6.2.348

YIELD
YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the
PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system
performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.
For more information about the recommended use of this instruction, see The YIELD instruction on page B1-112.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11

8 7

5 4 3 2 1 0

1 1 0 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 1 1 1 1 1 1
CRm
op2

Encoding
YIELD

Decode for this encoding
// Empty.

Operation
Hint_Yield();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C6-1393

