A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.1

ABS
Absolute value (vector). This instruction calculates the absolute value of each vector element in the source
SIMD&FP register, puts the result into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
ABS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
neg = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
ABS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 0x.

•

size = 10.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1399

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
if neg then
element = -element;
else
element = Abs(element);
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1400

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.2

ADD (vector)
Add (vector). This instruction adds corresponding elements in the two source SIMD&FP registers, places the results
into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1

5 4
Rn

0
Rd

Scalar variant
ADD <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
sub_op = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1

5 4
Rn

0
Rd

Vector variant
ADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 0x.

•

size = 10.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1401

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e,
element2 = Elem[operand2, e,
if sub_op then
Elem[result, e, esize] =
else
Elem[result, e, esize] =

esize];
esize];
element1 - element2;
element1 + element2;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1402

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.3

ADDHN, ADDHN2
Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP register to the
corresponding vector element in the second source SIMD&FP register, places the most significant half of the result
into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
The results are truncated. For rounded results, see RADDHN, RADDHN2.
The ADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the ADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
ADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean round = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1403

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;
for e = 0 to elements-1
element1 = Elem[operand1, e, 2*esize];
element2 = Elem[operand2, e, 2*esize];
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
sum = sum + round_const;
Elem[result, e, esize] = sum<2*esize-1:esize>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1404

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.4

ADDP (scalar)
Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&FP register and writes
the scalar result into the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 1 0 0 0 1 1 0 1 1 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
ADDP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize * 2;

Assembler symbols
Is the destination width specifier, encoded in the "size" field. It can have the following values:

<V>

D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is the source arrangement specifier, encoded in the "size" field. It can have the following values:
2D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_ADD, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1405

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-1406

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.5

ADDP (vector)
Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the first source
SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements from the concatenated vector, adds each pair of values together, places the result into a vector, and
writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 0 1 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
ADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1407

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
Elem[result, e, esize] = element1 + element2;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1408

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.6

ADDV
Add across Vector. This instruction adds every vector element in the source SIMD&FP register together, and writes
the scalar result to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 1 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
ADDV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;

Assembler symbols
Is the destination width specifier, encoded in the "size" field. It can have the following values:

<V>

B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 10, Q = 0.

•

size = 11, Q = x.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_ADD, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1409

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-1410

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.7

AESD
AES single round decryption.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 0 1 1 0
D

5 4
Rn

0
Rd

Advanced SIMD variant
AESD <Vd>.16B, <Vn>.16B

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
result = operand1 EOR operand2;
result = AESInvSubBytes(AESInvShiftRows(result));
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1411

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.8

AESE
AES single round encryption.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0
D

5 4
Rn

0
Rd

Advanced SIMD variant
AESE <Vd>.16B, <Vn>.16B

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
result = operand1 EOR operand2;
result = AESSubBytes(AESShiftRows(result));
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1412

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.9

AESIMC
AES inverse mix columns.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0
D

5 4
Rn

0
Rd

Advanced SIMD variant
AESIMC <Vd>.16B, <Vn>.16B

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand = V[n];
bits(128) result;
result = AESInvMixColumns(operand);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1413

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.10

AESMC
AES mix columns.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 1 1 0 1 0
D

5 4
Rn

0
Rd

Advanced SIMD variant
AESMC <Vd>.16B, <Vn>.16B

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand = V[n];
bits(128) result;
result = AESMixColumns(operand);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1414

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.11

AND (vector)
Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&FP registers, and
writes the result to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 1
size

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
AND <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<T>

8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
result = operand1 AND operand2;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1415

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.12

BCAX
Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a source SIMD&FP register and the
complement of the vector in another source SIMD&FP register, then performs a bitwise exclusive OR of the
resulting vector and the vector in a third source SIMD&FP register, and writes the result to the destination
SIMD&FP register.
This instruction is implemented only when FEAT_SHA3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 0 1

16 15 14
Rm

0

10 9
Ra

5 4
Rn

0
Rd

Advanced SIMD variant
BCAX <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B

Decode for this encoding
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the name of the third SIMD&FP source register, encoded in the "Ra" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128)
bits(128)
bits(128)
V[d] = Vn

Vm = V[m];
Vn = V[n];
Va = V[a];
EOR (Vm AND NOT(Va));

Operational information
If PSTATE.DIT is 1:
•

•

C7-1416

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.13

BFCVT
Floating-point convert from single-precision to BFloat16 format (scalar) converts the single-precision
floating-point value in the 32-bit SIMD&FP source register to BFloat16 format and writes the result in the 16-bit
SIMD&FP destination register.
Unlike the BFloat16 multiplication instructions, this instruction honors all the control bits in the FPCR that apply
to single-precision arithmetic, including the rounding mode. This instruction can generate a floating-point exception
that causes a cumulative exception bit in the FPSR to be set, or a synchronous exception to be taken, depending on
the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 0 1 1 0 0 0 1 1 0 1 0 0 0 0

5 4
Rn

0
Rd

Single-precision to BFloat16 variant
BFCVT <Hd>, <Sn>

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(32) operand = V[n];
bits(16) result;
result = FPConvertBF(operand, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1417

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.14

BFCVTN, BFCVTN2
Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the
SIMD&FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half
of the SIMD&FP destination vector. The result elements are half the width of the source elements.
The BFCVTN instruction writes the half-width results to the lower half of the destination vector and clears the upper
half to zero, while the BFCVTN2 instruction writes the results to the upper half of the destination vector without
affecting the other bits in the register.
Unlike the BFloat16 multiplication instructions, this instruction honors all of the control bits in the FPCR that apply
to single-precision arithmetic, including the rounding mode. It can also generate a floating-point exception that
causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken, depending on the
enable bits in the FPCR.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 0 1 0 0 0 0 1 0 1 1 0 1 0

5 4
Rn

0
Rd

Vector single-precision and BFloat16 variant
BFCVTN{2} <Vd>.<Ta>, <Vn>.4S

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);
integer part = UInt(Q);
integer elements = 64 DIV 16;

Assembler symbols
Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:

2

[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
4H

when Q = 0

8H

when Q = 1

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand = V[n];
bits(64) result;
for e = 0 to elements-1

C7-1418

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR);
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1419

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.15

BFDOT (by element)
BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of
16-bit BF16 elements. Each pair of elements in the first source vector is multiplied by the specified pair of elements
in the second source vector. The resulting single-precision products are then summed and added destructively to the
single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector.
The instruction ignores the FPCR and does not update the FPSR exception status.
The BF16 pair within the second source vector is specified using an immediate index. The index range is from 0 to
3 inclusive. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 0 1 L M

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0

5 4
Rn

0
Rd

Vector variant
BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer d = UInt(Rd);
integer i = UInt(H:L);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
4H

when Q = 0

8H

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<index>

Is the immediate index of a pair of 16-bit elements in the range 0 to 3, encoded in the "H:L" fields.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
for e = 0 to elements-1
bits(16) elt1_a = Elem[operand1, 2*e+0, 16];

C7-1420

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(16) elt1_b = Elem[operand1, 2*e+1, 16];
bits(16) elt2_a = Elem[operand2, 2*i+0, 16];
bits(16) elt2_b = Elem[operand2, 2*i+1, 16];
bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1421

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.16

BFDOT (vector)
BFloat16 floating-point dot product (vector). This instruction delimits the source vectors into pairs of 16-bit BF16
elements. Within each pair, the elements in the first source vector are multiplied by the corresponding elements in
the second source vector. The resulting single-precision products are then summed and added destructively to the
single-precision element of the destination vector that aligns with the pair of BF16 values in the first source vector.
The instruction ignores the FPCR and does not update the FPSR exception status.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector variant
BFDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
4H

when Q = 0

8H

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
for e = 0 to
bits(16)
bits(16)
bits(16)
bits(16)

elements-1
elt1_a = Elem[operand1,
elt1_b = Elem[operand1,
elt2_a = Elem[operand2,
elt2_b = Elem[operand2,

2*e+0,
2*e+1,
2*e+0,
2*e+1,

16];
16];
16];
16];

bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));

C7-1422

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1423

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.17

BFMLALB, BFMLALT (by element)
BFloat16 floating-point widening multiply-add long (by element) widens the even-numbered (bottom) or
odd-numbered (top) 16-bit elements in the first source vector, and the indexed element in the second source vector
from Bfloat16 to single-precision format. The instruction then multiplies and adds these values to the overlapping
single-precision elements of the destination vector.
This performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR
that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point
exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken,
depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is
supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 1 L M

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0

5 4
Rn

0
Rd

Vector variant
BFMLAL<bt> <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt('0':Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

Assembler symbols
Is the bottom or top element specifier, encoded in the "Q" field. It can have the following values:

<bt>

B

when Q = 0

T

when Q = 1

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, in the range V0 to V15, encoded in the "Rm"
field.

<index>

Is the element index, in the range 0 to 7, encoded in the "H:L:M" fields.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) operand3 = V[d];
bits(128) result;
bits(32) element2 = Elem[operand2, index, 16]:Zeros(16);

C7-1424

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
bits(32) element1 = Elem[operand1, 2*e+sel, 16]:Zeros(16);
bits(32) addend = Elem[operand3, e, 32];
Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1425

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.18

BFMLALB, BFMLALT (vector)
BFloat16 floating-point widening multiply-add long (vector) widens the even-numbered (bottom) or odd-numbered
(top) 16-bit elements in the first and second source vectors from Bfloat16 to single-precision format. The instruction
then multiplies and adds these values to the overlapping single-precision elements of the destination vector.
This performs a fused multiply-add without intermediate rounding that honors all of the control bits in the FPCR
that apply to single-precision arithmetic, including the rounding mode. It can also generate a floating-point
exception that causes cumulative exception bits in the FPSR to be set, or a synchronous exception to be taken,
depending on the enable bits in the FPCR. ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is
supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector variant
BFMLAL<bt> <Vd>.4S, <Vn>.8H, <Vm>.8H

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

Assembler symbols
Is the bottom or top element specifier, encoded in the "Q" field. It can have the following values:

<bt>

B

when Q = 0

T

when Q = 1

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) operand3 = V[d];
bits(128) result;
for e = 0 to elements-1
bits(32) element1 = Elem[operand1, 2*e+sel, 16]:Zeros(16);
bits(32) element2 = Elem[operand2, 2*e+sel, 16]:Zeros(16);
bits(32) addend = Elem[operand3, e, 32];
Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);
V[d] = result;

C7-1426

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.19

BFMMLA
BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix. This instruction multiplies the 2x4 matrix of
BF16 values held in the first 128-bit source vector by the 4x2 BF16 matrix in the second 128-bit source vector. The
resulting 2x2 single-precision matrix product is then added destructively to the 2x2 single-precision matrix in the
128-bit destination vector. This is equivalent to performing a 4-way dot product per destination element. The
instruction ignores the FPCR and does not update the FPSR exception status.

Note
Arm expects that the BFMMLA instruction will deliver a peak BF16 multiply throughput that is at least as high as
can be achieved using two BFDOT instructions, with a goal that it should have significantly higher throughput.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1

5 4
Rn

0
Rd

Vector variant
BFMMLA <Vd>.4S, <Vn>.8H, <Vm>.8H

Decode for this encoding
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) op1 = V[n];
bits(128) op2 = V[m];
bits(128) acc = V[d];
V[d] = BFMatMulAdd(acc, op1, op2);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1427

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.20

BIC (vector, immediate)
Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&FP
register, performs a bitwise AND between each result and the complement of an immediate constant, places the
result into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9 8 7 6 5 4

0 Q 1 0 1 1 1 1 0 0 0 0 0 a b c x x x 1 0 1 d e
op
cmode

f

g h

0
Rd

16-bit variant
Applies when cmode == 10x1.
BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit variant
Applies when cmode == 0xx1.
BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}

Decode for all variants of this encoding
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;
ImmediateOp operation;
case cmode:op of
when '0xx01' operation = ImmediateOp_MVNI;
when '0xx11' operation = ImmediateOp_BIC;
when '10x01' operation = ImmediateOp_MVNI;
when '10x11' operation = ImmediateOp_BIC;
when '110x1' operation = ImmediateOp_MVNI;
when '1110x' operation = ImmediateOp_MOVI;
when '11111'
// FMOV Dn,#imm is in main FP instruction set
if Q == '0' then UNDEFINED;
operation = ImmediateOp_MOVI;
imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

Assembler symbols

C7-1428

<Vd>

Is the name of the SIMD&FP register, encoded in the "Rd" field.

<T>

For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
2S

when Q = 0

4S

when Q = 1

<imm8>

Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

<amount>

For the 16-bit variant: is the shift amount encoded in the "cmode<1>" field. It can have the
following values:
0

when cmode<1> = 0

8

when cmode<1> = 1

defaulting to 0 if LSL is omitted.
For the 32-bit variant: is the shift amount encoded in the "cmode<2:1>" field. It can have the
following values:
0

when cmode<2:1> = 00

8

when cmode<2:1> = 01

16

when cmode<2:1> = 10

24

when cmode<2:1> = 11

defaulting to 0 if LSL is omitted.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand;
bits(datasize) result;
case operation of
when ImmediateOp_MOVI
result = imm;
when ImmediateOp_MVNI
result = NOT(imm);
when ImmediateOp_ORR
operand = V[rd];
result = operand OR imm;
when ImmediateOp_BIC
operand = V[rd];
result = operand AND NOT(imm);
V[rd] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1429

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.21

BIC (vector, register)
Bitwise bit Clear (vector, register). This instruction performs a bitwise AND between the first source SIMD&FP
register and the complement of the second source SIMD&FP register, and writes the result to the destination
SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 1
size

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
BIC <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
operand2 = NOT(operand2);
result = operand1 AND operand2;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1430

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1431

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.22

BIF
Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&FP register into the destination
SIMD&FP register if the corresponding bit of the second source SIMD&FP register is 0, otherwise leaves the bit in
the destination register unchanged.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 1
opc2

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
BIF <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];
operand1 = V[d];
operand3 = NOT(V[m]);
V[d] = operand1 EOR ((operand1 EOR operand4) AND operand3);

Operational information
If PSTATE.DIT is 1:
•

C7-1432

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1433

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.23

BIT
Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&FP register into the SIMD&FP
destination register if the corresponding bit of the second source SIMD&FP register is 1, otherwise leaves the bit in
the destination register unchanged.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 0 1
opc2

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
BIT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];
operand1 = V[d];
operand3 = V[m];
V[d] = operand1 EOR ((operand1 EOR operand4) AND operand3);

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

C7-1434

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1435

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.24

BSL
Bitwise Select. This instruction sets each bit in the destination SIMD&FP register to the corresponding bit from the
first source SIMD&FP register when the original destination bit was 1, otherwise from the second source SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 1
opc2

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
BSL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];
operand1 = V[m];
operand3 = V[d];
V[d] = operand1 EOR ((operand1 EOR operand4) AND operand3);

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

C7-1436

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1437

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.25

CLS (vector)
Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most
significant bit that are the same as the most significant bit in each vector element in the source SIMD&FP register,
places the result into a vector, and writes the vector to the destination SIMD&FP register. The count does not include
the most significant bit itself.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector variant
CLS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer count;
for e = 0 to elements-1
if countop == CountOp_CLS then
count = CountLeadingSignBits(Elem[operand, e, esize]);
else

C7-1438

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

count = CountLeadingZeroBits(Elem[operand, e, esize]);
Elem[result, e, esize] = count<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1439

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.26

CLZ (vector)
Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most
significant bit, in each vector element in the source SIMD&FP register, places the result into a vector, and writes
the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector variant
CLZ <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer count;
for e = 0 to elements-1
if countop == CountOp_CLS then
count = CountLeadingSignBits(Elem[operand, e, esize]);
else

C7-1440

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

count = CountLeadingZeroBits(Elem[operand, e, esize]);
Elem[result, e, esize] = count<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1441

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.27

CMEQ (register)
Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&FP
register with the corresponding vector element from the second source SIMD&FP register, and if the comparison is
equal sets every bit of the corresponding vector element in the destination SIMD&FP register to one, otherwise sets
every bit of the corresponding vector element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1

5 4
Rn

0
Rd

Scalar variant
CMEQ <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
and_test = (U == '0');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1

5 4
Rn

0
Rd

Vector variant
CMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean and_test = (U == '0');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:
•

C7-1442

size = 0x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if and_test then
test_passed = !IsZero(element1 AND element2);
else
test_passed = (element1 == element2);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1443

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.28

CMEQ (zero)
Compare bitwise Equal to zero (vector). This instruction reads each vector element in the source SIMD&FP register
and if the value is equal to zero sets every bit of the corresponding vector element in the destination SIMD&FP
register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register
to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar variant
CMEQ <V><d>, <V><n>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;

CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector variant
CMEQ <Vd>.<T>, <Vn>.<T>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

C7-1444

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
Is a width specifier, encoded in the "size" field. It can have the following values:

<V>

D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
case comparison of
when CompareOp_GT test_passed = element > 0;
when CompareOp_GE test_passed = element >= 0;
when CompareOp_EQ test_passed = element == 0;
when CompareOp_LE test_passed = element <= 0;
when CompareOp_LT test_passed = element < 0;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1445

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

C7-1446

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.29

CMGE (register)
Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source
SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first
signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding
vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector
element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1
eq

5 4
Rn

0
Rd

Scalar variant
CMGE <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
cmp_eq = (eq == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1
eq

5 4
Rn

0
Rd

Vector variant
CMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

ARM DDI 0487F.c
ID072120

when size = 11

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1447

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1448

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.30

CMGE (zero)
Compare signed Greater than or Equal to zero (vector). This instruction reads each vector element in the source
SIMD&FP register and if the signed integer value is greater than or equal to zero sets every bit of the corresponding
vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector
element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar variant
CMGE <V><d>, <V><n>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;

CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
CMGE <Vd>.<T>, <Vn>.<T>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1449

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
Is a width specifier, encoded in the "size" field. It can have the following values:

<V>

D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
case comparison of
when CompareOp_GT test_passed = element > 0;
when CompareOp_GE test_passed = element >= 0;
when CompareOp_EQ test_passed = element == 0;
when CompareOp_LE test_passed = element <= 0;
when CompareOp_LT test_passed = element < 0;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1450

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1451

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.31

CMGT (register)
Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&FP
register with the corresponding vector element in the second source SIMD&FP register and if the first signed integer
value is greater than the second signed integer value sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1
eq

5 4
Rn

0
Rd

Scalar variant
CMGT <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
cmp_eq = (eq == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1
eq

5 4
Rn

0
Rd

Vector variant
CMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

C7-1452

when size = 11

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1453

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.32

CMGT (zero)
Compare signed Greater than zero (vector). This instruction reads each vector element in the source SIMD&FP
register and if the signed integer value is greater than zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar variant
CMGT <V><d>, <V><n>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;

CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
CMGT <Vd>.<T>, <Vn>.<T>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

C7-1454

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
Is a width specifier, encoded in the "size" field. It can have the following values:

<V>

D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
case comparison of
when CompareOp_GT test_passed = element > 0;
when CompareOp_GE test_passed = element >= 0;
when CompareOp_EQ test_passed = element == 0;
when CompareOp_LE test_passed = element <= 0;
when CompareOp_LT test_passed = element < 0;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1455

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

C7-1456

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.33

CMHI (register)
Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&FP
register with the corresponding vector element in the second source SIMD&FP register and if the first unsigned
integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in
the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1
eq

5 4
Rn

0
Rd

Scalar variant
CMHI <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
cmp_eq = (eq == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1
eq

5 4
Rn

0
Rd

Vector variant
CMHI <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

ARM DDI 0487F.c
ID072120

when size = 11

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1457

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1458

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.34

CMHS (register)
Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source
SIMD&FP register with the corresponding vector element in the second source SIMD&FP register and if the first
unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the
corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1
eq

5 4
Rn

0
Rd

Scalar variant
CMHS <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
cmp_eq = (eq == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1
eq

5 4
Rn

0
Rd

Vector variant
CMHS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

ARM DDI 0487F.c
ID072120

when size = 11

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1459

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1460

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.35

CMLE (zero)
Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source
SIMD&FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding
vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector
element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar variant
CMLE <V><d>, <V><n>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;

CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector variant
CMLE <Vd>.<T>, <Vn>.<T>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1461

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
Is a width specifier, encoded in the "size" field. It can have the following values:

<V>

D

when size = 11

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
case comparison of
when CompareOp_GT test_passed = element > 0;
when CompareOp_GE test_passed = element >= 0;
when CompareOp_EQ test_passed = element == 0;
when CompareOp_LE test_passed = element <= 0;
when CompareOp_LT test_passed = element < 0;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1462

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1463

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.36

CMLT (zero)
Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&FP register
and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination
SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the destination
SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 0 1 0

5 4
Rn

0
Rd

Scalar variant
CMLT <V><d>, <V><n>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;

CompareOp comparison = CompareOp_LT;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 0 1 0

5 4
Rn

0
Rd

Vector variant
CMLT <Vd>.<T>, <Vn>.<T>, #0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison = CompareOp_LT;

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

C7-1464

when size = 11

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.
Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
case comparison of
when CompareOp_GT test_passed = element > 0;
when CompareOp_GE test_passed = element >= 0;
when CompareOp_EQ test_passed = element == 0;
when CompareOp_LE test_passed = element <= 0;
when CompareOp_LT test_passed = element < 0;
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1465

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.37

CMTST
Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&FP
register, performs an AND with the corresponding vector element in the second source SIMD&FP register, and if
the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&FP register to one,
otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1

5 4
Rn

0
Rd

Scalar variant
CMTST <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
and_test = (U == '0');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1

5 4
Rn

0
Rd

Vector variant
CMTST <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean and_test = (U == '0');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:
•

C7-1466

size = 0x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if and_test then
test_passed = !IsZero(element1 AND element2);
else
test_passed = (element1 == element2);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1467

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.38

CNT
Population Count per byte. This instruction counts the number of bits that have a value of one in each vector element
in the source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 0 1 1 0

5 4
Rn

0
Rd

Vector variant
CNT <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

!= '00' then UNDEFINED;
esize = 8;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV 8;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

The following encodings are reserved:
•

size = 01, Q = x.

•

size = 1x, Q = x.

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer count;
for e = 0 to elements-1
count = BitCount(Elem[operand, e, esize]);
Elem[result, e, esize] = count<esize-1:0>;
V[d] = result;

C7-1468

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1469

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.39

DUP (element)
Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element
index in the source SIMD&FP register into a scalar or each element in a vector, and writes the result to the
destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MOV (scalar). The alias is always the preferred disassembly.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 0 0 1

5 4
Rn

0
Rd

Scalar variant
DUP <V><d>, <Vn>.<T>[<index>]

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;
integer index = UInt(imm5<4:size+1>);
integer idxdsize = if imm5<4> == '1' then 128 else 64;
integer esize = 8 << size;
integer datasize = esize;
integer elements = 1;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 0 0 1

5 4
Rn

0
Rd

Vector variant
DUP <Vd>.<T>, <Vn>.<Ts>[<index>]

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;
integer index = UInt(imm5<4:size+1>);
integer idxdsize = if imm5<4> == '1' then 128 else 64;
if size
integer
integer
integer

C7-1470

== 3 && Q == '0' then UNDEFINED;
esize = 8 << size;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<T>

For the scalar variant: is the element width specifier, encoded in the "imm5" field. It can have the
following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
For the vector variant: is an arrangement specifier, encoded in the "imm5:Q" field. It can have the
following values:
8B

when imm5 = xxxx1, Q = 0

16B

when imm5 = xxxx1, Q = 1

4H

when imm5 = xxx10, Q = 0

8H

when imm5 = xxx10, Q = 1

2S

when imm5 = xx100, Q = 0

4S

when imm5 = xx100, Q = 1

2D

when imm5 = x1000, Q = 1

The following encodings are reserved:

<Ts>

•

imm5 = x0000, Q = x.

•

imm5 = x1000, Q = 0.

Is an element size specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<V>

Is the destination width specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<index>

Is the element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.

ARM DDI 0487F.c
ID072120

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1471

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(datasize) result;
bits(esize) element;
element = Elem[operand, index, esize];
for e = 0 to elements-1
Elem[result, e, esize] = element;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1472

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.40

DUP (general)
Duplicate general-purpose register to vector. This instruction duplicates the contents of the source general-purpose
register into a scalar or each element in a vector, and writes the result to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 0 1 1

5 4
Rn

0
Rd

Advanced SIMD variant
DUP <Vd>.<T>, <R><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;
// imm5<4:size+1> is IGNORED
if size
integer
integer
integer

== 3 && Q == '0' then UNDEFINED;
esize = 8 << size;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "imm5:Q" field. It can have the following values:
8B

when imm5 = xxxx1, Q = 0

16B

when imm5 = xxxx1, Q = 1

4H

when imm5 = xxx10, Q = 0

8H

when imm5 = xxx10, Q = 1

2S

when imm5 = xx100, Q = 0

4S

when imm5 = xx100, Q = 1

2D

when imm5 = x1000, Q = 1

The following encodings are reserved:

<R>

ARM DDI 0487F.c
ID072120

•

imm5 = x0000, Q = x.

•

imm5 = x1000, Q = 0.

Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
have the following values:
W

when imm5 = xxxx1

W

when imm5 = xxx10

W

when imm5 = xx100

X

when imm5 = x1000

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1473

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding imm5 = x0000 is reserved.
Unspecified bits in "imm5" are ignored but should be set to zero by an assembler.
Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.

<n>

Operation
CheckFPAdvSIMDEnabled64();
bits(esize) element = X[n];
bits(datasize) result;
for e = 0 to elements-1
Elem[result, e, esize] = element;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1474

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.41

EOR (vector)
Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive OR operation between the two source
SIMD&FP registers, and places the result in the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 0 1
opc2

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
EOR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<T>

8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand2;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];
operand1 = V[m];
operand2 = Zeros();
operand3 = Ones();
V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

ARM DDI 0487F.c
ID072120

The values of the data supplied in any of its registers.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1475

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

C7-1476

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.42

EOR3
Three-way Exclusive OR performs a three-way exclusive OR of the values in the three source SIMD&FP registers,
and writes the result to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 0 0

16 15 14
Rm

0

10 9
Ra

5 4
Rn

0
Rd

Advanced SIMD variant
EOR3 <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B

Decode for this encoding
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the name of the third SIMD&FP source register, encoded in the "Ra" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128)
bits(128)
bits(128)
V[d] = Vn

Vm = V[m];
Vn = V[n];
Va = V[a];
EOR Vm EOR Va;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1477

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.43

EXT
Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source
SIMD&FP register and the highest vector elements from the first source SIMD&FP register, concatenates the
results into a vector, and writes the vector to the destination SIMD&FP register vector. The index value specifies
the lowest vector element to extract from the first source register, and consecutive elements are extracted from the
first, then second, source registers until the destination vector is filled.
The following figure shows the operation of EXT doubleword operation for Q = 0 and imm4<2:0> = 3.
7 6 5 4 3 2 1 0
Vm

7 6 5 4 3 2 1 0
Vn

Vd

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 0 0

16 15 14
Rm

0

11 10 9
imm4

0

5 4
Rn

0
Rd

Advanced SIMD variant
EXT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if Q == '0' && imm4<3> == '1' then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer position = UInt(imm4) << 3;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<index>

Is the lowest numbered byte element to be extracted, encoded in the "Q:imm4" field. It can have the
following values:
imm4<2:0> when Q = 0, imm4<3> = 0
imm4

C7-1478

when Q = 1, imm4<3> = x

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding Q = 0, imm4<3> = 1 is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) hi = V[m];
bits(datasize) lo = V[n];
bits(datasize*2) concat = hi:lo;
V[d] = concat<position+datasize-1:position>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1479

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.44

FABD
Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of
the second source SIMD&FP register, from the corresponding floating-point values in the elements of the first
source SIMD&FP register, places the absolute value of each result in a vector, and writes the vector to the
destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Scalar half precision variant
FABD <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = esize;
elements = 1;
abs = TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FABD <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean

C7-1480

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 32 << UInt(sz);
datasize = esize;
elements = 1;
abs = TRUE;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Vector half precision variant
FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
abs = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 sz 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
abs = (U == '1');

Assembler symbols

ARM DDI 0487F.c
ID072120

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1481

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) diff;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
diff = FPSub(element1, element2, FPCR);
Elem[result, e, esize] = if abs then FPAbs(diff) else diff;
V[d] = result;

C7-1482

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.45

FABS (vector)
Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the
source SIMD&FP register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 1 1 1 0
U

5 4
Rn

0
Rd

Half-precision variant
FABS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
neg = (U == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 1 1 0
U

5 4
Rn

0
Rd

Single-precision and double-precision variant
FABS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer
boolean

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
neg = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

ARM DDI 0487F.c
ID072120

when Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1483

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
if neg then
element = FPNeg(element);
else
element = FPAbs(element);
Elem[result, e, esize] = element;
V[d] = result;

C7-1484

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.46

FABS (scalar)
Floating-point Absolute value (scalar). This instruction calculates the absolute value in the SIMD&FP source
register and writes the result to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 ftype 1 0 0 0 0 0 1 1 0 0 0 0
opc

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FABS <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FABS <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FABS <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1485

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPAbs(operand);
V[d] = result;

C7-1486

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.47

FACGE
Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of
each floating-point value in the first source SIMD&FP register with the absolute value of the corresponding
floating-point value in the second source SIMD&FP register and if the first value is greater than or equal to the
second value sets every bit of the corresponding vector element in the destination SIMD&FP register to one,
otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
ac

5 4
Rn

0
Rd

Scalar half precision variant
FACGE <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1
ac

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FACGE <V><d>, <V><n>, <V><m>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1487

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
ac

5 4
Rn

0
Rd

Vector half precision variant
FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1
ac

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

C7-1488

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1489

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if abs then
element1 = FPAbs(element1);
element2 = FPAbs(element2);
case cmp of
when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1490

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.48

FACGT
Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector
element in the first source SIMD&FP register with the absolute value of the corresponding vector element in the
second source SIMD&FP register and if the first value is greater than the second value sets every bit of the
corresponding vector element in the destination SIMD&FP register to one, otherwise sets every bit of the
corresponding vector element in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
ac

5 4
Rn

0
Rd

Scalar half precision variant
FACGT <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1
ac

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FACGT <V><d>, <V><n>, <V><m>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1491

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1
ac

5 4
Rn

0
Rd

Vector half precision variant
FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1
ac

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

C7-1492

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1493

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if abs then
element1 = FPAbs(element1);
element2 = FPAbs(element2);
case cmp of
when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1494

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.49

FADD (vector)
Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&FP
registers, writes the result into a vector, and writes the vector to the destination SIMD&FP register. All the values
in this instruction are floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1495

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
V[d] = result;

C7-1496

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.50

FADD (scalar)
Floating-point Add (scalar). This instruction adds the floating-point values of the two source SIMD&FP registers,
and writes the result to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FADD <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FADD <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FADD <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1497

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPAdd(operand1, operand2, FPCR);
V[d] = result;

C7-1498

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.51

FADDP (scalar)
Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source
SIMD&FP register and writes the scalar result into the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 1 1 0 1 1 0
sz

5 4
Rn

0
Rd

Half-precision variant
FADDP <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
esize = 16;
datasize = 32;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 1 1 0

5 4
Rn

0
Rd

Single-precision and double-precision variant
FADDP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32;
integer datasize = 64;

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, encoded in the "sz" field. It can have
the following values:
H

when sz = 0

The encoding sz = 1 is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1499

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is the source arrangement specifier, encoded in the "sz" field. It can
have the following values:
2H

when sz = 0

The encoding sz = 1 is reserved.
For the single-precision and double-precision variant: is the source arrangement specifier, encoded
in the "sz" field. It can have the following values:
2S

when sz = 0

2D

when sz = 1

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FADD, operand, esize);

C7-1500

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.52

FADDP (vector)
Floating-point Add Pairwise (vector). This instruction creates a vector by concatenating the vector elements of the
first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair
of adjacent vector elements from the concatenated vector, adds each pair of values together, places the result into a
vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are
floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1501

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
V[d] = result;

C7-1502

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.53

FCADD
Floating-point Complex Add.
This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with
the more significant element holding the imaginary part of the number and the less significant element holding the
real part of the number. Each element holds a floating-point value. It performs the following computation on the
corresponding complex number element pairs from the two source registers:
•

Considering the complex number from the second source register on an Argand diagram, the number is
rotated counterclockwise by 90 or 270 degrees.

•

The rotated complex number is added to the complex number from the first source register.

This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 1 1 rot 0 1

5 4
Rn

0
Rd

Vector variant
FCADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>

Decode for this encoding
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '00' then UNDEFINED;
if Q == '0' && size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00, Q = x.

•

size = 11, Q = 0.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1503

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.
Is the rotation, encoded in the "rot" field. It can have the following values:

<rotate>

90

when rot = 0

270

when rot = 1

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element3;
for e = 0 to (elements DIV 2)-1
case rot of
when '0'
element1 = FPNeg(Elem[operand2, e*2+1, esize]);
element3 = Elem[operand2, e*2, esize];
when '1'
element1 = Elem[operand2, e*2+1, esize];
element3 = FPNeg(Elem[operand2, e*2, esize]);
Elem[result, e*2, esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);
Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);
V[d] = result;

C7-1504

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.54

FCCMP
Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&FP source register
values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N,
Z, C, V} flags are set to the flag bit specifier.
It raises an Invalid Operation exception only if either operand is a signaling NaN.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15
Rm

12 11 10 9
cond

0 1

5 4 3
Rn

0
op

0
nzcv

Half-precision variant
Applies when ftype == 11.
FCCMP <Hn>, <Hm>, #<nzcv>, <cond>

Single-precision variant
Applies when ftype == 00.
FCCMP <Sn>, <Sm>, #<nzcv>, <cond>

Double-precision variant
Applies when ftype == 01.
FCCMP <Dn>, <Dm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
bits(4) flags = nzcv;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1505

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

NaNs
The IEEE 754 standard specifies that the result of a comparison is precisely one of <, ==, > or unordered. If either
or both of the operands are NaNs, they are unordered, and all three of (Operand1 < Operand2), (Operand1 ==
Operand2) and (Operand1 > Operand2) are false. This case results in the FPSCR flags being set to N=0, Z=0, C=1,
and V=1.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2;
operand2 = V[m];
if ConditionHolds(cond) then
flags = FPCompare(operand1, operand2, FALSE, FPCR);
PSTATE.<N,Z,C,V> = flags;

C7-1506

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.55

FCCMPE
Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&FP source
register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the
PSTATE.{N, Z, C, V} flags are set to the flag bit specifier.
If either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid
Operation exception.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15
Rm

12 11 10 9
cond

0 1

5 4 3
Rn

1
op

0
nzcv

Half-precision variant
Applies when ftype == 11.
FCCMPE <Hn>, <Hm>, #<nzcv>, <cond>

Single-precision variant
Applies when ftype == 00.
FCCMPE <Sn>, <Sm>, #<nzcv>, <cond>

Double-precision variant
Applies when ftype == 01.
FCCMPE <Dn>, <Dm>, #<nzcv>, <cond>

Decode for all variants of this encoding
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
bits(4) flags = nzcv;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1507

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<nzcv>

Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit
NZCV condition flags, encoded in the "nzcv" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

NaNs
The IEEE 754 standard specifies that the result of a comparison is precisely one of <, ==, > or unordered. If either
or both of the operands are NaNs, they are unordered, and all three of (Operand1 < Operand2), (Operand1 ==
Operand2) and (Operand1 > Operand2) are false. This case results in the FPSCR flags being set to N=0, Z=0, C=1,
and V=1.
FCCMPE raises an Invalid Operation exception if either operand is any type of NaN, and is suitable for testing for <,
<=, >, >=, and other predicates that raise an exception when the operands are unordered.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2;
operand2 = V[m];
if ConditionHolds(cond) then
flags = FPCompare(operand1, operand2, TRUE, FPCR);
PSTATE.<N,Z,C,V> = flags;

C7-1508

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.56

FCMEQ (register)
Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source
SIMD&FP register, with the corresponding floating-point value from the second source SIMD&FP register, and if
the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&FP register to
one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar half precision variant
FCMEQ <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMEQ <V><d>, <V><n>, <V><m>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1509

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Vector half precision variant
FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

C7-1510

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1511

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if abs then
element1 = FPAbs(element1);
element2 = FPAbs(element2);
case cmp of
when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1512

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.57

FCMEQ (zero)
Floating-point Compare Equal to zero (vector). This instruction reads each floating-point value in the source
SIMD&FP register and if the value is equal to zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar half precision variant
FCMEQ <Hd>, <Hn>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMEQ <V><d>, <V><n>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1513

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector half precision variant
FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

C7-1514

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;
for e = 0 to elements-1
element = Elem[operand, e, esize];
case comparison of
when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1515

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.58

FCMGE (register)
Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first
source SIMD&FP register and if the value is greater than or equal to the corresponding floating-point value in the
second source SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP
register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register
to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar half precision variant
FCMGE <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMGE <V><d>, <V><n>, <V><m>

C7-1516

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Vector half precision variant
FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1517

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

C7-1518

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if abs then
element1 = FPAbs(element1);
element2 = FPAbs(element2);
case cmp of
when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1519

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.59

FCMGE (zero)
Floating-point Compare Greater than or Equal to zero (vector). This instruction reads each floating-point value in
the source SIMD&FP register and if the value is greater than or equal to zero sets every bit of the corresponding
vector element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector
element in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar half precision variant
FCMGE <Hd>, <Hn>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMGE <V><d>, <V><n>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;

C7-1520

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector half precision variant
FCMGE <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMGE <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1521

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;
for e = 0 to elements-1
element = Elem[operand, e, esize];
case comparison of
when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1522

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.60

FCMGT (register)
Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source
SIMD&FP register and if the value is greater than the corresponding floating-point value in the second source
SIMD&FP register sets every bit of the corresponding vector element in the destination SIMD&FP register to one,
otherwise sets every bit of the corresponding vector element in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar half precision variant
FCMGT <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 1 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMGT <V><d>, <V><n>, <V><m>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1523

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0
U
E

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1
ac

5 4
Rn

0
Rd

Vector half precision variant
FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 sz 1
U
E

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 1
ac

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

C7-1524

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;
case E:U:ac of
when '000' cmp = CompareOp_EQ;
when '010' cmp = CompareOp_GE;
when '011' cmp = CompareOp_GE;
when '110' cmp = CompareOp_GT;
when '111' cmp = CompareOp_GT;
otherwise UNDEFINED;

abs
abs
abs
abs
abs

=
=
=
=
=

FALSE;
FALSE;
TRUE;
FALSE;
TRUE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1525

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2;
boolean test_passed;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if abs then
element1 = FPAbs(element1);
element2 = FPAbs(element2);
case cmp of
when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1526

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.61

FCMGT (zero)
Floating-point Compare Greater than zero (vector). This instruction reads each floating-point value in the source
SIMD&FP register and if the value is greater than zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar half precision variant
FCMGT <Hd>, <Hn>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMGT <V><d>, <V><n>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1527

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector half precision variant
FCMGT <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 0 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMGT <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

C7-1528

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;
for e = 0 to elements-1
element = Elem[operand, e, esize];
case comparison of
when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1529

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.62

FCMLA (by element)
Floating-point Complex Multiply Accumulate (by element).
This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with
the more significant element holding the imaginary part of the number and the less significant element holding the
real part of the number. Each element holds a floating-point value. It performs the following computation on
complex numbers from the first source register and the destination register with the specified complex number from
the second source register:
•

Considering the complex number from the second source register on an Argand diagram, the number is
rotated counterclockwise by 0, 90, 180, or 270 degrees.

•

The two elements of the transformed complex number are multiplied by:

•

—

The real element of the complex number from the first source register, if the transformation was a
rotation by 0 or 180 degrees.

—

The imaginary element of the complex number from the first source register, if the transformation was
a rotation by 90 or 270 degrees.

The complex number resulting from that multiplication is added to the complex number from the destination
register.

The multiplication and addition operations are performed as a fused multiply-add, without any intermediate
rounding.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0

rot

1 H 0

5 4
Rn

0
Rd

Encoding
Applies when size == 01.
FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>

Encoding
Applies when size == 10.
FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>

Decode for all variants of this encoding
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(M:Rm);
if size == '00' || size == '11' then UNDEFINED;
if size == '01' then index = UInt(H:L);
if size == '10' then index = UInt(H);
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;

C7-1530

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer
integer
if size
if size

datasize =
elements =
== '10' &&
== '01' &&

if Q == '1' then 128 else 64;
datasize DIV esize;
(L == '1' || Q == '0') then UNDEFINED;
H == '1' && Q == '0' then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 10, Q = 0.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:H:L" field. It can have the following values:

<index>

H:L

when size = 01

H

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the rotation, encoded in the "rot" field. It can have the following values:

<rotate>

0

when rot = 00

90

when rot = 01

180

when rot = 10

270

when rot = 11

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
for e = 0 to (elements DIV 2)-1
case rot of
when '00'
element1 = Elem[operand2, index*2, esize];
element2 = Elem[operand1, e*2, esize];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1531

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element3
element4
when '01'
element1
element2
element3
element4
when '10'
element1
element2
element3
element4
when '11'
element1
element2
element3
element4

= Elem[operand2, index*2+1, esize];
= Elem[operand1, e*2, esize];
=
=
=
=

FPNeg(Elem[operand2, index*2+1, esize]);
Elem[operand1, e*2+1, esize];
Elem[operand2, index*2, esize];
Elem[operand1, e*2+1, esize];

=
=
=
=

FPNeg(Elem[operand2, index*2, esize]);
Elem[operand1, e*2, esize];
FPNeg(Elem[operand2, index*2+1, esize]);
Elem[operand1, e*2, esize];

=
=
=
=

Elem[operand2, index*2+1, esize];
Elem[operand1, e*2+1, esize];
FPNeg(Elem[operand2, index*2, esize]);
Elem[operand1, e*2+1, esize];

Elem[result, e*2, esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);
Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);
V[d] = result;

C7-1532

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.63

FCMLA
Floating-point Complex Multiply Accumulate.
This instruction operates on complex numbers that are represented in SIMD&FP registers as pairs of elements, with
the more significant element holding the imaginary part of the number and the less significant element holding the
real part of the number. Each element holds a floating-point value. It performs the following computation on the
corresponding complex number element pairs from the two source registers and the destination register:
•

Considering the complex number from the second source register on an Argand diagram, the number is
rotated counterclockwise by 0, 90, 180, or 270 degrees.

•

The two elements of the transformed complex number are multiplied by:

•

—

The real element of the complex number from the first source register, if the transformation was a
rotation by 0 or 180 degrees.

—

The imaginary element of the complex number from the first source register, if the transformation was
a rotation by 90 or 270 degrees.

The complex number resulting from that multiplication is added to the complex number from the destination
register.

The multiplication and addition operations are performed as a fused multiply-add, without any intermediate
rounding.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 1 0

rot

1

5 4
Rn

0
Rd

Vector variant
FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>

Decode for this encoding
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '00' then UNDEFINED;
if Q == '0' && size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

ARM DDI 0487F.c
ID072120

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1533

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = 0.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<rotate>

Is the rotation, encoded in the "rot" field. It can have the following values:
0

when rot = 00

90

when rot = 01

180

when rot = 10

270

when rot = 11

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) element3;
bits(esize) element4;
for e = 0 to (elements
case rot of
when '00'
element1 =
element2 =
element3 =
element4 =
when '01'
element1 =
element2 =
element3 =
element4 =
when '10'
element1 =
element2 =
element3 =
element4 =
when '11'
element1 =
element2 =
element3 =
element4 =

DIV 2)-1

Elem[operand2,
Elem[operand1,
Elem[operand2,
Elem[operand1,

e*2, esize];
e*2, esize];
e*2+1, esize];
e*2, esize];

FPNeg(Elem[operand2, e*2+1, esize]);
Elem[operand1, e*2+1, esize];
Elem[operand2, e*2, esize];
Elem[operand1, e*2+1, esize];
FPNeg(Elem[operand2, e*2, esize]);
Elem[operand1, e*2, esize];
FPNeg(Elem[operand2, e*2+1, esize]);
Elem[operand1, e*2, esize];
Elem[operand2, e*2+1, esize];
Elem[operand1, e*2+1, esize];
FPNeg(Elem[operand2, e*2, esize]);
Elem[operand1, e*2+1, esize];

Elem[result, e*2, esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);
Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);
V[d] = result;

C7-1534

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.64

FCMLE (zero)
Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the
source SIMD&FP register and if the value is less than or equal to zero sets every bit of the corresponding vector
element in the destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element
in the destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar half precision variant
FCMLE <Hd>, <Hn>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMLE <V><d>, <V><n>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1535

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = 1;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector half precision variant
FCMLE <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison;
case op:U of
when '00' comparison
when '01' comparison
when '10' comparison
when '11' comparison

=
=
=
=

CompareOp_GT;
CompareOp_GE;
CompareOp_EQ;
CompareOp_LE;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 0 1 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMLE <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CompareOp comparison;
case op:U of
when '00' comparison = CompareOp_GT;

C7-1536

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' comparison = CompareOp_GE;
when '10' comparison = CompareOp_EQ;
when '11' comparison = CompareOp_LE;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;
for e = 0 to elements-1
element = Elem[operand, e, esize];
case comparison of
when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1537

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.65

FCMLT (zero)
Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source
SIMD&FP register and if the value is less than zero sets every bit of the corresponding vector element in the
destination SIMD&FP register to one, otherwise sets every bit of the corresponding vector element in the
destination SIMD&FP register to zero.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 0 1 1 1 0 1 0

5 4
Rn

0
Rd

Scalar half precision variant
FCMLT <Hd>, <Hn>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp comparison = CompareOp_LT;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 0 1 0

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCMLT <V><d>, <V><n>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp comparison = CompareOp_LT;

C7-1538

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 1 0 1 0

5 4
Rn

0
Rd

Vector half precision variant
FCMLT <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp comparison = CompareOp_LT;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 0 1 0

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCMLT <Vd>.<T>, <Vn>.<T>, #0.0

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

CompareOp comparison = CompareOp_LT;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1539

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;
for e = 0 to elements-1
element = Elem[operand, e, esize];
case comparison of
when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
Elem[result, e, esize] = if test_passed then Ones() else Zeros();
V[d] = result;

C7-1540

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.66

FCMP
Floating-point quiet Compare (scalar). This instruction compares the two SIMD&FP source register values, or the
first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.
It raises an Invalid Operation exception only if either operand is a signaling NaN.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0

5 4 3 2 1 0
Rn

0 x 0 0 0
opc

Half-precision variant
Applies when ftype == 11 && opc == 00.
FCMP <Hn>, <Hm>

Half-precision, zero variant
Applies when ftype == 11 && Rm == (00000) && opc == 01.
FCMP <Hn>, #0.0

Single-precision variant
Applies when ftype == 00 && opc == 00.
FCMP <Sn>, <Sm>

Single-precision, zero variant
Applies when ftype == 00 && Rm == (00000) && opc == 01.
FCMP <Sn>, #0.0

Double-precision variant
Applies when ftype == 01 && opc == 00.
FCMP <Dn>, <Dm>

Double-precision, zero variant
Applies when ftype == 01 && Rm == (00000) && opc == 01.
FCMP <Dn>, #0.0

Decode for all variants of this encoding
integer n = UInt(Rn);
integer m = UInt(Rm);

// ignored when opc<0> == '1'

integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1541

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
boolean signal_all_nans = (opc<1> == '1');
boolean cmp_with_zero = (opc<0> == '1');

Assembler symbols
For the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded
in the "Rn" field.

<Dn>

For the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded
in the "Rn" field.
<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hn>

For the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in
the "Rn" field.
For the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in
the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sn>

For the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded
in the "Rn" field.
For the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded
in the "Rn" field.
Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sm>

NaNs
The IEEE 754 standard specifies that the result of a comparison is precisely one of <, ==, > or unordered. If either
or both of the operands are NaNs, they are unordered, and all three of (Operand1 < Operand2), (Operand1 ==
Operand2) and (Operand1 > Operand2) are false. This case results in the FPSCR flags being set to N=0, Z=0, C=1,
and V=1.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2;
operand2 = if cmp_with_zero then FPZero('0') else V[m];
PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);

C7-1542

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.67

FCMPE
Floating-point signaling Compare (scalar). This instruction compares the two SIMD&FP source register values, or
the first SIMD&FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags.
If either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid
Operation exception.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0

5 4 3 2 1 0
Rn

1 x 0 0 0
opc

Half-precision variant
Applies when ftype == 11 && opc == 10.
FCMPE <Hn>, <Hm>

Half-precision, zero variant
Applies when ftype == 11 && Rm == (00000) && opc == 11.
FCMPE <Hn>, #0.0

Single-precision variant
Applies when ftype == 00 && opc == 10.
FCMPE <Sn>, <Sm>

Single-precision, zero variant
Applies when ftype == 00 && Rm == (00000) && opc == 11.
FCMPE <Sn>, #0.0

Double-precision variant
Applies when ftype == 01 && opc == 10.
FCMPE <Dn>, <Dm>

Double-precision, zero variant
Applies when ftype == 01 && Rm == (00000) && opc == 11.
FCMPE <Dn>, #0.0

Decode for all variants of this encoding
integer n = UInt(Rn);
integer m = UInt(Rm);

// ignored when opc<0> == '1'

integer datasize;
case ftype of
when '00' datasize = 32;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1543

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
boolean signal_all_nans = (opc<1> == '1');
boolean cmp_with_zero = (opc<0> == '1');

Assembler symbols
For the double-precision variant: is the 64-bit name of the first SIMD&FP source register, encoded
in the "Rn" field.

<Dn>

For the double-precision, zero variant: is the 64-bit name of the SIMD&FP source register, encoded
in the "Rn" field.
<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hn>

For the half-precision variant: is the 16-bit name of the first SIMD&FP source register, encoded in
the "Rn" field.
For the half-precision, zero variant: is the 16-bit name of the SIMD&FP source register, encoded in
the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sn>

For the single-precision variant: is the 32-bit name of the first SIMD&FP source register, encoded
in the "Rn" field.
For the single-precision, zero variant: is the 32-bit name of the SIMD&FP source register, encoded
in the "Rn" field.
Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sm>

NaNs
The IEEE 754 standard specifies that the result of a comparison is precisely one of <, ==, > or unordered. If either
or both of the operands are NaNs, they are unordered, and all three of (Operand1 < Operand2), (Operand1 ==
Operand2) and (Operand1 > Operand2) are false. This case results in the FPSCR flags being set to N=0, Z=0, C=1,
and V=1.
FCMPE raises an Invalid Operation exception if either operand is any type of NaN, and is suitable for testing for <,

<=, >, >=, and other predicates that raise an exception when the operands are unordered.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2;
operand2 = if cmp_with_zero then FPZero('0') else V[m];
PSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);

C7-1544

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.68

FCSEL
Floating-point Conditional Select (scalar). This instruction allows the SIMD&FP destination register to take the
value from either one or the other of two SIMD&FP source registers. If the condition passes, the first SIMD&FP
source register value is taken, otherwise the second SIMD&FP source register value is taken.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15
Rm

12 11 10 9
cond

1 1

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FCSEL <Hd>, <Hn>, <Hm>, <cond>

Single-precision variant
Applies when ftype == 00.
FCSEL <Sd>, <Sn>, <Sm>, <cond>

Double-precision variant
Applies when ftype == 01.
FCSEL <Dd>, <Dn>, <Dm>, <cond>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1545

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<cond>

Is one of the standard conditions, encoded in the "cond" field in the standard way.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
result = if ConditionHolds(cond) then V[n] else V[m];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1546

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.69

FCVT
Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&FP source
register to the precision for the destination register data type using the rounding mode that is determined by the
FPCR and writes the result to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 ftype 1 0 0 0 1

opc

1 0 0 0 0

5 4
Rn

0
Rd

Half-precision to single-precision variant
Applies when ftype == 11 && opc == 00.
FCVT <Sd>, <Hn>

Half-precision to double-precision variant
Applies when ftype == 11 && opc == 01.
FCVT <Dd>, <Hn>

Single-precision to half-precision variant
Applies when ftype == 00 && opc == 11.
FCVT <Hd>, <Sn>

Single-precision to double-precision variant
Applies when ftype == 00 && opc == 01.
FCVT <Dd>, <Sn>

Double-precision to half-precision variant
Applies when ftype == 01 && opc == 11.
FCVT <Hd>, <Dn>

Double-precision to single-precision variant
Applies when ftype == 01 && opc == 00.
FCVT <Sd>, <Dn>

Decode for all variants of this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
srcsize;
dstsize;

if ftype == opc then UNDEFINED;
case ftype of
when '00'
when '01'
when '10'
when '11'

ARM DDI 0487F.c
ID072120

srcsize = 32;
srcsize = 64;
UNDEFINED;
srcsize = 16;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1547

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case opc
when
when
when
when

of
'00'
'01'
'10'
'11'

dstsize = 32;
dstsize = 64;
UNDEFINED;
dstsize = 16;

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(dstsize) result;
bits(srcsize) operand = V[n];
result = FPConvert(operand, FPCR);
V[d] = result;

C7-1548

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.70

FCVTAS (vector)
Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts
each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties
to Away rounding mode and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar half precision variant
FCVTAS <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTAS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1549

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector half precision variant
FCVTAS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTAS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

C7-1550

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1551

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.71

FCVTAS (scalar)
Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar). This instruction converts
the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to
Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 1 0 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTAS <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTAS <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTAS <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTAS <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTAS <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTAS <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
case ftype of

C7-1552

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, FALSE, FPCR, FPRounding_TIEAWAY);
X[d] = intval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1553

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.72

FCVTAU (vector)
Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts
each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with
Ties to Away rounding mode and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar half precision variant
FCVTAU <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTAU <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

C7-1554

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector half precision variant
FCVTAU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTAU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1555

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1556

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.73

FCVTAU (scalar)
Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar). This instruction converts
the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to
Nearest with Ties to Away rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 1 0 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTAU <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTAU <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTAU <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTAU <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTAU <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTAU <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
case ftype of

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1557

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, TRUE, FPCR, FPRounding_TIEAWAY);
X[d] = intval;

C7-1558

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.74

FCVTL, FCVTL2
Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the
SIMD&FP source register, converts each value to double the precision of the source element using the rounding
mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the
SIMD&FP destination register.
Where the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 variant operates on the elements in the
top 64 bits of the source register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 1 1 0

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTL{2} <Vd>.<Ta>, <Vn>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
integer

esize = 16 << UInt(sz);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "sz" field. It can have the following values:
4S

when sz = 0

2D

when sz = 1

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
4H

when sz = 0, Q = 0

8H

when sz = 0, Q = 1

2S

when sz = 1, Q = 0

4S

when sz = 1, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1559

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;
for e = 0 to elements-1
Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);
V[d] = result;

C7-1560

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.75

FCVTMS (vector)
Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar
or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus
Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTMS <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTMS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1561

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTMS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTMS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

C7-1562

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1563

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.76

FCVTMS (scalar)
Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards
Minus Infinity rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 1 0 0 0 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTMS <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTMS <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTMS <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTMS <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTMS <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTMS <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

C7-1564

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, FALSE, FPCR, rounding);
X[d] = intval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1565

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.77

FCVTMU (vector)
Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a
scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards
Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTMU <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTMU <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

C7-1566

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTMU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTMU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1567

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1568

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.78

FCVTMU (scalar)
Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards
Minus Infinity rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 1 0 0 0 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTMU <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTMU <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTMU <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTMU <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTMU <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTMU <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1569

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, TRUE, FPCR, rounding);
X[d] = intval;

C7-1570

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.79

FCVTN, FCVTN2
Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the
SIMD&FP source register, converts each result to half the precision of the source element, writes the final result to
a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The destination
vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR.
The FCVTN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the FCVTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTN{2} <Vd>.<Tb>, <Vn>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
integer

esize = 16 << UInt(sz);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
4H

when sz = 0, Q = 0

8H

when sz = 0, Q = 1

2S

when sz = 1, Q = 0

4S

when sz = 1, Q = 1

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "sz" field. It can have the following values:
4S

ARM DDI 0487F.c
ID072120

when sz = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1571

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2D

when sz = 1

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
for e = 0 to elements-1
Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);
Vpart[d, part] = result;

C7-1572

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.80

FCVTNS (vector)
Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a
scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest
rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTNS <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTNS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1573

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTNS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTNS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

C7-1574

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1575

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.81

FCVTNS (scalar)
Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round to Nearest
rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 0 0 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTNS <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTNS <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTNS <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTNS <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTNS <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTNS <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

C7-1576

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, FALSE, FPCR, rounding);
X[d] = intval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1577

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.82

FCVTNU (vector)
Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts
a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to
Nearest rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTNU <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTNU <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

C7-1578

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTNU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTNU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1579

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1580

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.83

FCVTNU (scalar)
Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar). This instruction converts
the floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round to
Nearest rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 0 0 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTNU <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTNU <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTNU <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTNU <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTNU <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTNU <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1581

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, TRUE, FPCR, rounding);
X[d] = intval;

C7-1582

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.84

FCVTPS (vector)
Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar
or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus
Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTPS <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTPS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1583

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTPS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTPS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

C7-1584

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1585

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.85

FCVTPS (scalar)
Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards
Plus Infinity rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 1 0 0 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTPS <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTPS <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTPS <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTPS <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTPS <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTPS <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

C7-1586

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, FALSE, FPCR, rounding);
X[d] = intval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1587

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.86

FCVTPU (vector)
Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a
scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards
Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTPU <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTPU <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

C7-1588

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTPU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTPU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1589

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1590

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.87

FCVTPU (scalar)
Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards
Plus Infinity rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 1 0 0 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTPU <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTPU <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTPU <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTPU <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTPU <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTPU <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1591

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, TRUE, FPCR, rounding);
X[d] = intval;

C7-1592

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.88

FCVTXN, FCVTXN2
Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector
element in the source SIMD&FP register, narrows each value to half the precision of the source element using the
Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&FP
register.

Note
This instruction uses the Round to Odd rounding mode which is not defined by the IEEE 754-2008 standard. This
rounding mode ensures that if the result of the conversion is inexact the least significant bit of the mantissa is forced
to 1. This rounding mode enables a floating-point value to be converted to a lower precision format via an
intermediate precision format while avoiding double rounding errors. For example, a 64-bit floating-point value can
be converted to a correctly rounded 16-bit floating-point value by first using this instruction to produce a 32-bit
value and then using another instruction with the wanted rounding mode to convert the 32-bit value to the final
16-bit floating-point value.
The FCVTXN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the FCVTXN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0

5 4
Rn

0
Rd

Scalar variant
FCVTXN <Vb><d>, <Va><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz == '0' then UNDEFINED;
integer esize = 32;
integer datasize = esize;
integer elements = 1;
integer part = 0;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 0 1 1 0 1 0

5 4
Rn

0
Rd

Vector variant
FCVTXN{2} <Vd>.<Tb>, <Vn>.<Ta>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1593

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz == '0' then UNDEFINED;
integer esize = 32;
integer datasize = 64;
integer elements = 2;
integer part = UInt(Q);

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
2S

when sz = 1, Q = 0

4S

when sz = 1, Q = 1

The encoding sz = 0, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "sz" field. It can have the following values:
2D

when sz = 1

The encoding sz = 0 is reserved.
<Vb>

Is the destination width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 1

The encoding sz = 0 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "sz" field. It can have the following values:
D

when sz = 1

The encoding sz = 0 is reserved.
<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
for e = 0 to elements-1
Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);
Vpart[d, part] = result;

C7-1594

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.89

FCVTZS (vector, fixed-point)
Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or
each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding
mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 1 1 1

5 4
Rn

0
Rd

Scalar variant
FCVTZS <V><d>, <V><n>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
datasize = esize;
elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector variant
FCVTZS <Vd>.<T>, <Vn>.<T>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh<3>:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1595

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 000x is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The following encodings are reserved:
•

immh = 0001, Q = x.

•

immh = 1xxx, Q = 0.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 000x is reserved.
For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 0001 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1

C7-1596

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1597

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.90

FCVTZS (vector, integer)
Floating-point Convert to Signed integer, rounding toward Zero (vector). This instruction converts a scalar or each
element in a vector from a floating-point value to a signed integer value using the Round towards Zero rounding
mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTZS <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTZS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

C7-1598

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTZS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTZS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1599

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1600

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.91

FCVTZS (scalar, fixed-point)
Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point signed integer using the Round
towards Zero rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

sf 0 0 1 1 1 1 0 ftype 0 1 1 0 0 0
rmode opcode

10 9
scale

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTZS <Wd>, <Hn>, #<fbits>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTZS <Xd>, <Hn>, #<fbits>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTZS <Wd>, <Sn>, #<fbits>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTZS <Xd>, <Sn>, #<fbits>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTZS <Wd>, <Dn>, #<fbits>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTZS <Xd>, <Dn>, #<fbits>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
case ftype of

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1601

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '00' fltsize = 32;
when '01' fltsize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
if sf == '0' && scale<5> == '0' then UNDEFINED;
integer fracbits = 64 - UInt(scale);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is
the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded
as 64 minus "scale".
For the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is
the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded
as 64 minus "scale".

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, fracbits, FALSE, FPCR, FPRounding_ZERO);
X[d] = intval;

C7-1602

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.92

FCVTZS (scalar, integer)
Floating-point Convert to Signed integer, rounding toward Zero (scalar). This instruction converts the floating-point
value in the SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round towards Zero rounding
mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 1 1 0 0 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTZS <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTZS <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTZS <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTZS <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTZS <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTZS <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1603

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, FALSE, FPCR, rounding);
X[d] = intval;

C7-1604

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.93

FCVTZU (vector, fixed-point)
Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar
or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero
rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 1 1 1

5 4
Rn

0
Rd

Scalar variant
FCVTZU <V><d>, <V><n>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
datasize = esize;
elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector variant
FCVTZU <Vd>.<T>, <Vn>.<T>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh<3>:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1605

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 000x is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The following encodings are reserved:
•

immh = 0001, Q = x.

•

immh = 1xxx, Q = 0.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 000x is reserved.
For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 0001 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1

C7-1606

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1607

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.94

FCVTZU (vector, integer)
Floating-point Convert to Unsigned integer, rounding toward Zero (vector). This instruction converts a scalar or
each element in a vector from a floating-point value to an unsigned integer value using the Round towards Zero
rounding mode, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar half precision variant
FCVTZU <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FCVTZU <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

C7-1608

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Vector half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector half precision variant
FCVTZU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 1 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FCVTZU <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:

<d>

ARM DDI 0487F.c
ID072120

S

when sz = 0

D

when sz = 1

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1609

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1610

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.95

FCVTZU (scalar, fixed-point)
Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit fixed-point unsigned integer using the
Round towards Zero rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

sf 0 0 1 1 1 1 0 ftype 0 1 1 0 0 1
rmode opcode

10 9
scale

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTZU <Wd>, <Hn>, #<fbits>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTZU <Xd>, <Hn>, #<fbits>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTZU <Wd>, <Sn>, #<fbits>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTZU <Xd>, <Sn>, #<fbits>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTZU <Wd>, <Dn>, #<fbits>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTZU <Xd>, <Dn>, #<fbits>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
case ftype of

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1611

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '00' fltsize = 32;
when '01' fltsize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
if sf == '0' && scale<5> == '0' then UNDEFINED;
integer fracbits = 64 - UInt(scale);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the double-precision to 32-bit, half-precision to 32-bit and single-precision to 32-bit variant: is
the number of bits after the binary point in the fixed-point destination, in the range 1 to 32, encoded
as 64 minus "scale".
For the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is
the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded
as 64 minus "scale".

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, fracbits, TRUE, FPCR, FPRounding_ZERO);
X[d] = intval;

C7-1612

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.96

FCVTZU (scalar, integer)
Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). This instruction converts the
floating-point value in the SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round towards
Zero rounding mode, and writes the result to the general-purpose destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 1 1 0 0 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11.
FCVTZU <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11.
FCVTZU <Xd>, <Hn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00.
FCVTZU <Wd>, <Sn>

Single-precision to 64-bit variant
Applies when sf == 1 && ftype == 00.
FCVTZU <Xd>, <Sn>

Double-precision to 32-bit variant
Applies when sf == 0 && ftype == 01.
FCVTZU <Wd>, <Dn>

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01.
FCVTZU <Xd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1613

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPDecodeRounding(rmode);

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
fltval = V[n];
intval = FPToFixed(fltval, 0, TRUE, FPCR, rounding);
X[d] = intval;

C7-1614

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.97

FDIV (vector)
Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source
SIMD&FP register, by the floating-point values in the corresponding elements in the second source SIMD&FP
register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1

5 4
Rn

0
Rd

Half-precision variant
FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Vd>

ARM DDI 0487F.c
ID072120

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1615

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPDiv(element1, element2, FPCR);
V[d] = result;

C7-1616

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.98

FDIV (scalar)
Floating-point Divide (scalar). This instruction divides the floating-point value of the first source SIMD&FP
register by the floating-point value of the second source SIMD&FP register, and writes the result to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 0

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FDIV <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FDIV <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FDIV <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1617

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPDiv(operand1, operand2, FPCR);
V[d] = result;

C7-1618

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.99

FJCVTZS
Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. This instruction converts the
double-precision floating-point value in the SIMD&FP source register to a 32-bit signed integer using the Round
towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too
large to be accommodated as a signed 32-bit integer, then the result is the integer modulo 232, as held in a 32-bit
signed integer.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.3
31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0
sf
ftype
rmode opcode

5 4
Rn

0
Rd

Double-precision to 32-bit variant
FJCVTZS <Wd>, <Dn>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveFJCVTZSExt() then UNDEFINED;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(64) fltval;
bits(32) intval;
bit Z;
fltval = V[n];
(intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);
PSTATE.<N,Z,C,V> = '0':Z:'00';
X[d] = intval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1619

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.100

FMADD
Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&FP source
registers, adds the product to the value of the third SIMD&FP source register, and writes the result to the SIMD&FP
destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 1 ftype 0
o1

16 15 14
Rm

0
o0

10 9
Ra

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMADD <Hd>, <Hn>, <Hm>, <Ha>

Single-precision variant
Applies when ftype == 00.
FMADD <Sd>, <Sn>, <Sm>, <Sa>

Double-precision variant
Applies when ftype == 01.
FMADD <Dd>, <Dn>, <Dm>, <Da>

Decode for all variants of this encoding
integer
integer
integer
integer

d
a
n
m

=
=
=
=

UInt(Rd);
UInt(Ra);
UInt(Rn);
UInt(Rm);

integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1620

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Dm>

Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Da>

Is the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Ha>

Is the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Sa>

Is the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operanda = V[a];
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMulAdd(operanda, operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1621

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.101

FMAX (vector)
Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source
SIMD&FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to
the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0
U
o1

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

C7-1622

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMin(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMax(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1623

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.102

FMAX (scalar)
Floating-point Maximum (scalar). This instruction compares the two source SIMD&FP registers, and writes the
larger of the two floating-point values to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 1 0 0 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMAX <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FMAX <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FMAX <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1624

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMax(operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1625

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.103

FMAXNM (vector)
Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two
source SIMD&FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to
the destination SIMD&FP register.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0
U
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Half-precision variant
FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

C7-1626

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1627

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.104

FMAXNM (scalar)
Floating-point Maximum Number (scalar). This instruction compares the first and second source SIMD&FP
register values, and writes the larger of the two floating-point values to the destination SIMD&FP register.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 1 1 0 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMAXNM <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FMAXNM <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FMAXNM <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1628

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMaxNum(operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1629

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.105

FMAXNMP (scalar)
Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the
source SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP
register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 1 1 0 0 1 0
o1 sz

5 4
Rn

0
Rd

Half-precision variant
FMAXNMP <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = 32;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXNMP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32;
integer datasize = 64;

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, encoded in the "sz" field. It can have
the following values:
H

when sz = 0

The encoding sz = 1 is reserved.

C7-1630

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is the source arrangement specifier, encoded in the "sz" field. It can
have the following values:
2H

when sz = 0

The encoding sz = 1 is reserved.
For the single-precision and double-precision variant: is the source arrangement specifier, encoded
in the "sz" field. It can have the following values:
2S

when sz = 0

2D

when sz = 1

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMAXNUM, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1631

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.106

FMAXNMP (vector)
Floating-point Maximum Number Pairwise (vector). This instruction creates a vector by concatenating the vector
elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register,
reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of
values into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are
floating-point values.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result is the numerical value, otherwise the result is identical to FMAX (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0
U
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Half-precision variant
FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer

C7-1632

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1633

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.107

FMAXNMV
Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source
SIMD&FP register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the
values in this instruction are floating-point values.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMAX (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Half-precision variant
FMAXNMV <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXNMV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q != '01' then UNDEFINED;

// .4S only

integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;

C7-1634

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, H.
For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

The encoding sz = 1 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"Q:sz" field. It can have the following values:
4S

when Q = 1, sz = 0

The following encodings are reserved:
•

Q = 0, sz = x.

•

Q = 1, sz = 1.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMAXNUM, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1635

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.108

FMAXP (scalar)
Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source
SIMD&FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&FP
register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 0
o1 sz

5 4
Rn

0
Rd

Half-precision variant
FMAXP <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = 32;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32;
integer datasize = 64;

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, encoded in the "sz" field. It can have
the following values:
H

when sz = 0

The encoding sz = 1 is reserved.

C7-1636

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is the source arrangement specifier, encoded in the "sz" field. It can
have the following values:
2H

when sz = 0

The encoding sz = 1 is reserved.
For the single-precision and double-precision variant: is the source arrangement specifier, encoded
in the "sz" field. It can have the following values:
2S

when sz = 0

2D

when sz = 1

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMAX, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1637

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.109

FMAXP (vector)
Floating-point Maximum Pairwise (vector). This instruction creates a vector by concatenating the vector elements
of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each
pair of adjacent vector elements from the concatenated vector, writes the larger of each pair of values into a vector,
and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point
values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0
U
o1

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

C7-1638

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMin(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMax(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1639

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.110

FMAXV
Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP
register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Half-precision variant
FMAXV <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMAXV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q != '01' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;

Assembler symbols
<V>

C7-1640

For the half-precision variant: is the destination width specifier, H.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

The encoding sz = 1 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"Q:sz" field. It can have the following values:
4S

when Q = 1, sz = 0

The following encodings are reserved:
•

Q = 0, sz = x.

•

Q = 1, sz = 1.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMAX, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1641

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.111

FMIN (vector)
Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two
source SIMD&FP registers, places the smaller of each of the two floating-point values into a vector, and writes the
vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 0
U
o1

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

C7-1642

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMin(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMax(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1643

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.112

FMIN (scalar)
Floating-point Minimum (scalar). This instruction compares the first and second source SIMD&FP register values,
and writes the smaller of the two floating-point values to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMIN <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FMIN <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FMIN <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1644

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMin(operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1645

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.113

FMINNM (vector)
Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two
source SIMD&FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector
to the destination SIMD&FP register.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 0
U
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Half-precision variant
FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

C7-1646

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1647

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.114

FMINNM (scalar)
Floating-point Minimum Number (scalar). This instruction compares the first and second source SIMD&FP register
values, and writes the smaller of the two floating-point values to the destination SIMD&FP register.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 1 1 1 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMINNM <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FMINNM <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FMINNM <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1648

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMinNum(operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1649

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.115

FMINNMP (scalar)
Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the
source SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 0 1 1 0 0 0 0 1 1 0 0 1 0
o1 sz

5 4
Rn

0
Rd

Half-precision variant
FMINNMP <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = 32;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINNMP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32;
integer datasize = 64;

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, encoded in the "sz" field. It can have
the following values:
H

when sz = 0

The encoding sz = 1 is reserved.

C7-1650

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is the source arrangement specifier, encoded in the "sz" field. It can
have the following values:
2H

when sz = 0

The encoding sz = 1 is reserved.
For the single-precision and double-precision variant: is the source arrangement specifier, encoded
in the "sz" field. It can have the following values:
2S

when sz = 0

2D

when sz = 1

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMINNUM, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1651

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.116

FMINNMP (vector)
Floating-point Minimum Number Pairwise (vector). This instruction creates a vector by concatenating the vector
elements of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register,
reads each pair of adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair
of floating-point values into a vector, and writes the vector to the destination SIMD&FP register. All the values in
this instruction are floating-point values.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result is the numerical value, otherwise the result is identical to FMIN (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0
U
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Half-precision variant
FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer

C7-1652

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1653

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.117

FMINNMV
Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source
SIMD&FP register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the
values in this instruction are floating-point values.
NaNs are handled according to the IEEE 754-2008 standard. If one vector element is numeric and the other is a quiet
NaN, the result of the comparison is the numerical value, otherwise the result is identical to FMIN (scalar).
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 0 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Half-precision variant
FMINNMV <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 0 0 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINNMV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q != '01' then UNDEFINED;

// .4S only

integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;

C7-1654

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, H.
For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

The encoding sz = 1 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"Q:sz" field. It can have the following values:
4S

when Q = 1, sz = 0

The following encodings are reserved:
•

Q = 0, sz = x.

•

Q = 1, sz = 1.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMINNUM, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1655

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.118

FMINP (scalar)
Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source
SIMD&FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&FP
register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 0 1 1 0 0 0 0 1 1 1 1 1 0
o1 sz

5 4
Rn

0
Rd

Half-precision variant
FMINP <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = 32;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINP <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32;
integer datasize = 64;

Assembler symbols
<V>

For the half-precision variant: is the destination width specifier, encoded in the "sz" field. It can have
the following values:
H

when sz = 0

The encoding sz = 1 is reserved.

C7-1656

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is the source arrangement specifier, encoded in the "sz" field. It can
have the following values:
2H

when sz = 0

The encoding sz = 1 is reserved.
For the single-precision and double-precision variant: is the source arrangement specifier, encoded
in the "sz" field. It can have the following values:
2S

when sz = 0

2D

when sz = 1

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMIN, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1657

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.119

FMINP (vector)
Floating-point Minimum Pairwise (vector). This instruction creates a vector by concatenating the vector elements
of the first source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each
pair of adjacent vector elements from the concatenated vector, writes the smaller of each pair of values into a vector,
and writes the vector to the destination SIMD&FP register. All the values in this instruction are floating-point
values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 1 0
U
o1

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 sz 1
U
o1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

C7-1658

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
if pair then
element1 = Elem[concat, 2*e, esize];
element2 = Elem[concat, (2*e)+1, esize];
else
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if minimum then
Elem[result, e, esize] = FPMin(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMax(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1659

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.120

FMINV
Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP
register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this
instruction are floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 0 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Half-precision variant
FMINV <V><d>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 1 0 0 0 0 1 1 1 1 1 0
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMINV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q != '01' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;

Assembler symbols
<V>

C7-1660

For the half-precision variant: is the destination width specifier, H.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single-precision and double-precision variant: is the destination width specifier, encoded in
the "sz" field. It can have the following values:
S

when sz = 0

The encoding sz = 1 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"Q:sz" field. It can have the following values:
4S

when Q = 1, sz = 0

The following encodings are reserved:
•

Q = 0, sz = x.

•

Q = 1, sz = 1.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(ReduceOp_FMIN, operand, esize);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1661

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.121

FMLA (by element)
Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in
the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates
the results in the vector elements of the destination SIMD&FP register. All the values in this instruction are
floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 0 0 L M

16 15 14 13 12 11 10 9
Rm

0 0 0 1 H 0
o2

5 4
Rn

0
Rd

Scalar, half-precision variant
FMLA <Hd>, <Hn>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
sub_op = (o2 == '1');

Scalar, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 1 sz L M

16 15 14 13 12 11 10 9
Rm

0 0 0 1 H 0
o2

5 4
Rn

0
Rd

Scalar, single-precision and double-precision variant
FMLA <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;

C7-1662

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
boolean

esize = 32 << UInt(sz);
datasize = esize;
elements = 1;
sub_op = (o2 == '1');

Vector, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 0 0 L M

16 15 14 13 12 11 10 9
Rm

0 0 0 1 H 0
o2

5 4
Rn

0
Rd

Vector, half-precision variant
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
sub_op = (o2 == '1');

Vector, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 sz L M

16 15 14 13 12 11 10 9
Rm

0 0 0 1 H 0
o2

5 4
Rn

0
Rd

Vector, single-precision and double-precision variant
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1663

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector, half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector, single-precision and double-precision variant: is an arrangement specifier, encoded
in the "Q:sz" field. It can have the following values:
2S

when Q = 0, sz = 0

4S

when Q = 1, sz = 0

2D

when Q = 1, sz = 1

The encoding Q = 0, sz = 1 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

For the half-precision variant: is the name of the second SIMD&FP source register, in the range V0
to V15, encoded in the "Rm" field.
For the single-precision and double-precision variant: is the name of the second SIMD&FP source
register, encoded in the "M:Rm" fields.

<Ts>

<index>

Is an element size specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

For the half-precision variant: is the element index, in the range 0 to 7, encoded in the "H:L:M"
fields.
For the single-precision and double-precision variant: is the element index, encoded in the "sz:L:H"
field. It can have the following values:
H:L

when sz = 0, L = x

H

when sz = 1, L = 0

The encoding sz = 1, L = 1 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

C7-1664

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2 = Elem[operand2, index, esize];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1665

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.122

FMLA (vector)
Floating-point fused Multiply-Add to accumulator (vector). This instruction multiplies corresponding
floating-point values in the vectors in the two source SIMD&FP registers, adds the product to the corresponding
vector element of the destination SIMD&FP register, and writes the result to the destination SIMD&FP register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Half-precision variant
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1
op

16 15 14 13 12 11 10 9
Rm

1 1 0 0 1 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (op == '1');

C7-1666

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1667

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.123

FMLAL, FMLAL2 (by element)
Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector
elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and
accumulates the product to the corresponding vector element of the destination SIMD&FP register. The instruction
does not round the result of the multiply before the accumulation.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.

FMLAL
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 0 L M
sz

16 15 14 13 12 11 10 9
Rm

0 0 0 0 H 0
S

5 4
Rn

0
Rd

FMLAL variant
FMLAL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);
// Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M);
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 0;

FMLAL2
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 1 0 L M
sz

16 15 14 13 12 11 10 9
Rm

1 0 0 0 H 0
S

5 4
Rn

0
Rd

FMLAL2 variant
FMLAL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]

C7-1668

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);
// Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M);
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 1;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2H

when Q = 0

4H

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<index>

Is the element index, encoded in the "H:L:M" fields.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n, part];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize DIV 2];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1669

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.124

FMLAL, FMLAL2 (vector)
Floating-point fused Multiply-Add Long to accumulator (vector). This instruction multiplies corresponding
half-precision floating-point values in the vectors in the two source SIMD&FP registers, and accumulates the
product to the corresponding vector element of the destination SIMD&FP register. The instruction does not round
the result of the multiply before the accumulation.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.

FMLAL
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 1
S sz

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1

5 4
Rn

0
Rd

FMLAL variant
FMLAL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 0;

FMLAL2
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 0 1
S sz

16 15 14 13 12 11 10 9
Rm

1 1 0 0 1 1

5 4
Rn

0
Rd

FMLAL2 variant
FMLAL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

C7-1670

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 1;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<Vm>

2H

when Q = 0

4H

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n, part];
bits(datasize DIV 2) operand2 = Vpart[m, part];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize DIV 2];
element2 = Elem[operand2, e, esize DIV 2];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1671

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.125

FMLS (by element)
Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector
elements in the first source SIMD&FP register by the specified value in the second source SIMD&FP register, and
subtracts the results from the vector elements of the destination SIMD&FP register. All the values in this instruction
are floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 0 0 L M

16 15 14 13 12 11 10 9
Rm

0 1 0 1 H 0
o2

5 4
Rn

0
Rd

Scalar, half-precision variant
FMLS <Hd>, <Hn>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
sub_op = (o2 == '1');

Scalar, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 1 sz L M

16 15 14 13 12 11 10 9
Rm

0 1 0 1 H 0
o2

5 4
Rn

0
Rd

Scalar, single-precision and double-precision variant
FMLS <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;

C7-1672

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
boolean

esize = 32 << UInt(sz);
datasize = esize;
elements = 1;
sub_op = (o2 == '1');

Vector, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 0 0 L M

16 15 14 13 12 11 10 9
Rm

0 1 0 1 H 0
o2

5 4
Rn

0
Rd

Vector, half-precision variant
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
sub_op = (o2 == '1');

Vector, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 sz L M

16 15 14 13 12 11 10 9
Rm

0 1 0 1 H 0
o2

5 4
Rn

0
Rd

Vector, single-precision and double-precision variant
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1673

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector, half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector, single-precision and double-precision variant: is an arrangement specifier, encoded
in the "Q:sz" field. It can have the following values:
2S

when Q = 0, sz = 0

4S

when Q = 1, sz = 0

2D

when Q = 1, sz = 1

The encoding Q = 0, sz = 1 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

For the half-precision variant: is the name of the second SIMD&FP source register, in the range V0
to V15, encoded in the "Rm" field.
For the single-precision and double-precision variant: is the name of the second SIMD&FP source
register, encoded in the "M:Rm" fields.

<Ts>

<index>

Is an element size specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

For the half-precision variant: is the element index, in the range 0 to 7, encoded in the "H:L:M"
fields.
For the single-precision and double-precision variant: is the element index, encoded in the "sz:L:H"
field. It can have the following values:
H:L

when sz = 0, L = x

H

when sz = 1, L = 0

The encoding sz = 1, L = 1 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

C7-1674

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element1;
bits(esize) element2 = Elem[operand2, index, esize];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1675

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.126

FMLS (vector)
Floating-point fused Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding
floating-point values in the vectors in the two source SIMD&FP registers, negates the product, adds the result to the
corresponding vector element of the destination SIMD&FP register, and writes the result to the destination
SIMD&FP register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 0
a

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Half-precision variant
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (a == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 sz 1
op

16 15 14 13 12 11 10 9
Rm

1 1 0 0 1 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (op == '1');

C7-1676

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1677

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.127

FMLSL, FMLSL2 (by element)
Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the
negated vector elements in the first source SIMD&FP register by the specified value in the second source
SIMD&FP register, and accumulates the product to the corresponding vector element of the destination SIMD&FP
register. The instruction does not round the result of the multiply before the accumulation.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.

FMLSL
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 0 L M
sz

16 15 14 13 12 11 10 9
Rm

0 1 0 0 H 0
S

5 4
Rn

0
Rd

FMLSL variant
FMLSL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);
// Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M);
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 0;

FMLSL2
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 1 0 L M
sz

16 15 14 13 12 11 10 9
Rm

1 1 0 0 H 0
S

5 4
Rn

0
Rd

FMLSL2 variant
FMLSL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]

C7-1678

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);
// Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M);
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 1;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2H

when Q = 0

4H

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<index>

Is the element index, encoded in the "H:L:M" fields.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n, part];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize DIV 2];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1679

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.128

FMLSL, FMLSL2 (vector)
Floating-point fused Multiply-Subtract Long from accumulator (vector). This instruction negates the values in the
vector of one SIMD&FP register, multiplies these with the corresponding values in another vector, and accumulates
the product to the corresponding vector element of the destination SIMD&FP register. The instruction does not
round the result of the multiply before the accumulation.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported.

FMLSL
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 0 1
S sz

16 15 14 13 12 11 10 9
Rm

1 1 1 0 1 1

5 4
Rn

0
Rd

FMLSL variant
FMLSL <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 0;

FMLSL2
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 1 0 1
S sz

16 15 14 13 12 11 10 9
Rm

1 1 0 0 1 1

5 4
Rn

0
Rd

FMLSL2 variant
FMLSL2 <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

C7-1680

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 1;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<Vm>

2H

when Q = 0

4H

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n, part];
bits(datasize DIV 2) operand2 = Vpart[m, part];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize DIV 2];
element2 = Elem[operand2, e, esize DIV 2];
if sub_op then element1 = FPNeg(element1);
Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1681

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.129

FMOV (vector, immediate)
Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every
element of the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4
0 Q 0 0 1 1 1 1 0 0 0 0 0 a b c 1 1 1 1 1 1 d e

f

g h

0
Rd

Half-precision variant
FMOV <Vd>.<T>, #<imm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
imm8 = a:b:c:d:e:f:g:h;
imm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>, 2):imm8<5:0>:Zeros(6);
imm = Replicate(imm16, datasize DIV 16);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9 8 7 6 5 4

0 Q op 0 1 1 1 1 0 0 0 0 0 a b c 1 1 1 1 0 1 d e
cmode

f

g h

0
Rd

Single-precision variant
Applies when op == 0.
FMOV <Vd>.<T>, #<imm>

Double-precision variant
Applies when Q == 1 && op == 1.
FMOV <Vd>.2D, #<imm>

Decode for all variants of this encoding
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;
if cmode:op == '11111' then
// FMOV Dn,#imm is in main FP instruction set

C7-1682

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if Q == '0' then UNDEFINED;
imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have
the following values:
2S

when Q = 0

4S

when Q = 1

Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded
in "a:b:c:d:e:f:g:h". For details of the range of constants available and the encoding of <imm>, see
Modified immediate constants in A64 floating-point instructions on page C2-196.

<imm>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
V[rd] = imm;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1683

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.130

FMOV (register)
Floating-point Move register without conversion. This instruction copies the floating-point value in the SIMD&FP
source register to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 ftype 1 0 0 0 0 0 0 1 0 0 0 0
opc

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMOV <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FMOV <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FMOV <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1684

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = operand;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1685

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.131

FMOV (general)
Floating-point Move to or from general-purpose register without conversion. This instruction transfers the contents
of a SIMD&FP register to a general-purpose register, or the contents of a general-purpose register to a SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 x 1 1 x 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

Half-precision to 32-bit variant
Applies when sf == 0 && ftype == 11 && rmode == 00 && opcode == 110.
FMOV <Wd>, <Hn>

Half-precision to 64-bit variant
Applies when sf == 1 && ftype == 11 && rmode == 00 && opcode == 110.
FMOV <Xd>, <Hn>

32-bit to half-precision variant
Applies when sf == 0 && ftype == 11 && rmode == 00 && opcode == 111.
FMOV <Hd>, <Wn>

32-bit to single-precision variant
Applies when sf == 0 && ftype == 00 && rmode == 00 && opcode == 111.
FMOV <Sd>, <Wn>

Single-precision to 32-bit variant
Applies when sf == 0 && ftype == 00 && rmode == 00 && opcode == 110.
FMOV <Wd>, <Sn>

64-bit to half-precision variant
Applies when sf == 1 && ftype == 11 && rmode == 00 && opcode == 111.
FMOV <Hd>, <Xn>

64-bit to double-precision variant
Applies when sf == 1 && ftype == 01 && rmode == 00 && opcode == 111.
FMOV <Dd>, <Xn>

64-bit to top half of 128-bit variant
Applies when sf == 1 && ftype == 10 && rmode == 01 && opcode == 111.
FMOV <Vd>.D[1], <Xn>

C7-1686

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Double-precision to 64-bit variant
Applies when sf == 1 && ftype == 01 && rmode == 00 && opcode == 110.
FMOV <Xd>, <Dn>

Top half of 128-bit to 64-bit variant
Applies when sf == 1 && ftype == 10 && rmode == 01 && opcode == 110.
FMOV <Xd>, <Vn>.D[1]

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPConvOp op;
FPRounding rounding;
boolean unsigned;
integer part;
case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
if opcode<2:1>:rmode != '11 01' then UNDEFINED;
fltsize = 128;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
case opcode<2:1>:rmode of
when '00 xx'
// FCVT[NPMZ][US]
rounding = FPDecodeRounding(rmode);
unsigned = (opcode<0> == '1');
op = FPConvOp_CVT_FtoI;
when '01 00'
// [US]CVTF
rounding = FPRoundingMode(FPCR);
unsigned = (opcode<0> == '1');
op = FPConvOp_CVT_ItoF;
when '10 00'
// FCVTA[US]
rounding = FPRounding_TIEAWAY;
unsigned = (opcode<0> == '1');
op = FPConvOp_CVT_FtoI;
when '11 00'
// FMOV
if fltsize != 16 && fltsize != intsize then UNDEFINED;
op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
part = 0;
when '11 01'
// FMOV D[1]
if intsize != 64 || fltsize != 128 then UNDEFINED;
op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
part = 1;
fltsize = 64;
// size of D[1] is 64
when '11 11'
// FJCVTZS
if !HaveFJCVTZSExt() then UNDEFINED;
rounding = FPRounding_ZERO;
unsigned = (opcode<0> == '1');
op = FPConvOp_CVT_FtoI_JS;
otherwise
UNDEFINED;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1687

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
case op of
when FPConvOp_CVT_FtoI
fltval = V[n];
intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
X[d] = intval;
when FPConvOp_CVT_ItoF
intval = X[n];
fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
V[d] = fltval;
when FPConvOp_MOV_FtoI
fltval = Vpart[n, part];
intval = ZeroExtend(fltval, intsize);
X[d] = intval;
when FPConvOp_MOV_ItoF
intval = X[n];
fltval = intval<fltsize-1:0>;
Vpart[d, part] = fltval;
when FPConvOp_CVT_FtoI_JS
bit Z;
fltval = V[n];
(intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);
PSTATE.<N,Z,C,V> = '0':Z:'00';
X[d] = intval;

C7-1688

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.132

FMOV (scalar, immediate)
Floating-point move immediate (scalar). This instruction copies a floating-point immediate constant into the
SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

13 12 11 10 9 8 7 6 5 4
imm8

1 0 0 0 0 0 0 0

0
Rd

Half-precision variant
Applies when ftype == 11.
FMOV <Hd>, #<imm>

Single-precision variant
Applies when ftype == 00.
FMOV <Sd>, #<imm>

Double-precision variant
Applies when ftype == 01.
FMOV <Dd>, #<imm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
bits(datasize) imm = VFPExpandImm(imm8);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<imm>

Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded
in the "imm8" field. For details of the range of constants available and the encoding of <imm>, see
Modified immediate constants in A64 floating-point instructions on page C2-196.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1689

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
V[d] = imm;

C7-1690

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.133

FMSUB
Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&FP
source registers, negates the product, adds that to the value of the third SIMD&FP source register, and writes the
result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 1 ftype 0
o1

16 15 14
Rm

1
o0

10 9
Ra

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMSUB <Hd>, <Hn>, <Hm>, <Ha>

Single-precision variant
Applies when ftype == 00.
FMSUB <Sd>, <Sn>, <Sm>, <Sa>

Double-precision variant
Applies when ftype == 01.
FMSUB <Dd>, <Dn>, <Dm>, <Da>

Decode for all variants of this encoding
integer
integer
integer
integer

d
a
n
m

=
=
=
=

UInt(Rd);
UInt(Ra);
UInt(Rn);
UInt(Rm);

integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1691

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Dm>

Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Da>

Is the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Ha>

Is the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Sa>

Is the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operanda = V[a];
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
operand1 = FPNeg(operand1);
result = FPMulAdd(operanda, operand1, operand2, FPCR);
V[d] = result;

C7-1692

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.134

FMUL (by element)
Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&FP
register by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the
vector to the destination SIMD&FP register. All the values in this instruction are floating-point values.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 0 0 L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Scalar, half-precision variant
FMUL <Hd>, <Hn>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
mulx_op = (U == '1');

Scalar, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 1 sz L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Scalar, single-precision and double-precision variant
FMUL <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;
integer d = UInt(Rd);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1693

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
boolean

esize = 32 << UInt(sz);
datasize = esize;
elements = 1;
mulx_op = (U == '1');

Vector, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 0 0 L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Vector, half-precision variant
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
mulx_op = (U == '1');

Vector, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 sz L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Vector, single-precision and double-precision variant
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);

C7-1694

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean mulx_op = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector, half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector, single-precision and double-precision variant: is an arrangement specifier, encoded
in the "Q:sz" field. It can have the following values:
2S

when Q = 0, sz = 0

4S

when Q = 1, sz = 0

2D

when Q = 1, sz = 1

The encoding Q = 0, sz = 1 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

For the half-precision variant: is the name of the second SIMD&FP source register, in the range V0
to V15, encoded in the "Rm" field.
For the single-precision and double-precision variant: is the name of the second SIMD&FP source
register, encoded in the "M:Rm" fields.

<Ts>

<index>

Is an element size specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

For the half-precision variant: is the element index, in the range 0 to 7, encoded in the "H:L:M"
fields.
For the single-precision and double-precision variant: is the element index, encoded in the "sz:L:H"
field. It can have the following values:
H:L

when sz = 0, L = x

H

when sz = 1, L = 0

The encoding sz = 1, L = 1 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1695

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element2 = Elem[operand2, index, esize];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
if mulx_op then
Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMul(element1, element2, FPCR);
V[d] = result;

C7-1696

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.135

FMUL (vector)
Floating-point Multiply (vector). This instruction multiplies corresponding floating-point values in the vectors in
the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination SIMD&FP
register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Half-precision variant
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 1 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Vd>

ARM DDI 0487F.c
ID072120

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1697

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPMul(element1, element2, FPCR);
V[d] = result;

C7-1698

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.136

FMUL (scalar)
Floating-point Multiply (scalar). This instruction multiplies the floating-point values of the two source SIMD&FP
registers, and writes the result to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FMUL <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FMUL <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FMUL <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1699

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMul(operand1, operand2, FPCR);
V[d] = result;

C7-1700

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.137

FMULX (by element)
Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector
elements in the first source SIMD&FP register by the specified floating-point value in the second source SIMD&FP
register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of
the values is negative, otherwise the result is positive.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 1 1 1 1 1 1 0 0 L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Scalar, half-precision variant
FMULX <Hd>, <Hn>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
mulx_op = (U == '1');

Scalar, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 1 1 1 1 1 1 1 sz L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Scalar, single-precision and double-precision variant
FMULX <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1701

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '11' UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
boolean

esize = 32 << UInt(sz);
datasize = esize;
elements = 1;
mulx_op = (U == '1');

Vector, half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 0 0 L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Vector, half-precision variant
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer

idxdsize = if H == '1' then 128 else 64;
n = UInt(Rn);
m = UInt(Rm);
d = UInt(Rd);
index = UInt(H:L:M);

integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
mulx_op = (U == '1');

Vector, single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 1 sz L M
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 H 0

5 4
Rn

0
Rd

Vector, single-precision and double-precision variant
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi = M;
case sz:L of
when '0x' index = UInt(H:L);
when '10' index = UInt(H);
when '11' UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

C7-1702

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if sz:Q
integer
integer
integer
boolean

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
mulx_op = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector, half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector, single-precision and double-precision variant: is an arrangement specifier, encoded
in the "Q:sz" field. It can have the following values:
2S

when Q = 0, sz = 0

4S

when Q = 1, sz = 0

2D

when Q = 1, sz = 1

The encoding Q = 0, sz = 1 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

For the half-precision variant: is the name of the second SIMD&FP source register, in the range V0
to V15, encoded in the "Rm" field.
For the single-precision and double-precision variant: is the name of the second SIMD&FP source
register, encoded in the "M:Rm" fields.

<Ts>

<index>

Is an element size specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

For the half-precision variant: is the element index, in the range 0 to 7, encoded in the "H:L:M"
fields.
For the single-precision and double-precision variant: is the element index, encoded in the "sz:L:H"
field. It can have the following values:
H:L

when sz = 0, L = x

H

when sz = 1, L = 0

The encoding sz = 1, L = 1 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1703

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(datasize) result;
bits(esize) element1;
bits(esize) element2 = Elem[operand2, index, esize];
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
if mulx_op then
Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
else
Elem[result, e, esize] = FPMul(element1, element2, FPCR);
V[d] = result;

C7-1704

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.138

FMULX
Floating-point Multiply extended. This instruction multiplies corresponding floating-point values in the vectors of
the two source SIMD&FP registers, places the resulting floating-point values in a vector, and writes the vector to
the destination SIMD&FP register.
If one value is zero and the other value is infinite, the result is 2.0. In this case, the result is negative if only one of
the values is negative, otherwise the result is positive.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Scalar half precision variant
FMULX <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = esize;
elements = 1;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 1 1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FMULX <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 32 << UInt(sz);
datasize = esize;
elements = 1;

Vector half precision
ARMv8.2
ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1705

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Vector half precision variant
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 1 1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols

C7-1706

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1707

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.139

FNEG (vector)
Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&FP
register, writes the result to a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 0 1 1 1 1 1 0
U

5 4
Rn

0
Rd

Half-precision variant
FNEG <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
neg = (U == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 0 1 1 1 1 1 0
U

5 4
Rn

0
Rd

Single-precision and double-precision variant
FNEG <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer
boolean

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
neg = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

C7-1708

when Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
if neg then
element = FPNeg(element);
else
element = FPAbs(element);
Elem[result, e, esize] = element;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1709

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.140

FNEG (scalar)
Floating-point Negate (scalar). This instruction negates the value in the SIMD&FP source register and writes the
result to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 ftype 1 0 0 0 0 1 0 1 0 0 0 0
opc

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FNEG <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FNEG <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FNEG <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1710

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPNeg(operand);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1711

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.141

FNMADD
Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two
SIMD&FP source registers, negates the product, subtracts the value of the third SIMD&FP source register, and
writes the result to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 1 ftype 1
o1

16 15 14
Rm

0
o0

10 9
Ra

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FNMADD <Hd>, <Hn>, <Hm>, <Ha>

Single-precision variant
Applies when ftype == 00.
FNMADD <Sd>, <Sn>, <Sm>, <Sa>

Double-precision variant
Applies when ftype == 01.
FNMADD <Dd>, <Dn>, <Dm>, <Da>

Decode for all variants of this encoding
integer
integer
integer
integer

d
a
n
m

=
=
=
=

UInt(Rd);
UInt(Ra);
UInt(Rn);
UInt(Rm);

integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1712

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Dm>

Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Da>

Is the 64-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Ha>

Is the 16-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Sa>

Is the 32-bit name of the third SIMD&FP source register holding the addend, encoded in the "Ra"
field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operanda = V[a];
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
operanda = FPNeg(operanda);
operand1 = FPNeg(operand1);
result = FPMulAdd(operanda, operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1713

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.142

FNMSUB
Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two
SIMD&FP source registers, subtracts the value of the third SIMD&FP source register, and writes the result to the
destination SIMD&FP register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 1 ftype 1
o1

16 15 14
Rm

1
o0

10 9
Ra

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FNMSUB <Hd>, <Hn>, <Hm>, <Ha>

Single-precision variant
Applies when ftype == 00.
FNMSUB <Sd>, <Sn>, <Sm>, <Sa>

Double-precision variant
Applies when ftype == 01.
FNMSUB <Dd>, <Dn>, <Dm>, <Da>

Decode for all variants of this encoding
integer
integer
integer
integer

d
a
n
m

=
=
=
=

UInt(Rd);
UInt(Ra);
UInt(Rn);
UInt(Rm);

integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1714

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Dm>

Is the 64-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Da>

Is the 64-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Ha>

Is the 16-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register holding the multiplicand, encoded in the
"Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register holding the multiplier, encoded in the
"Rm" field.

<Sa>

Is the 32-bit name of the third SIMD&FP source register holding the minuend, encoded in the "Ra"
field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operanda = V[a];
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
operanda = FPNeg(operanda);
result = FPMulAdd(operanda, operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1715

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.143

FNMUL (scalar)
Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source
SIMD&FP registers, and writes the negation of the result to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FNMUL <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FNMUL <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FNMUL <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1716

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPMul(operand1, operand2, FPCR);
result = FPNeg(result);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1717

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.144

FRECPE
Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector
element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Scalar half precision variant
FRECPE <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FRECPE <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

Vector half precision
ARMv8.2

C7-1718

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Vector half precision variant
FRECPE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRECPE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

ARM DDI 0487F.c
ID072120

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1719

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRecipEstimate(element, FPCR);
V[d] = result;

C7-1720

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.145

FRECPS
Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of
the two source SIMD&FP registers, subtracts each of the products from 2.0, places the resulting floating-point
values in a vector, and writes the vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1

5 4
Rn

0
Rd

Scalar half precision variant
FRECPS <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = esize;
elements = 1;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FRECPS <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 32 << UInt(sz);
datasize = esize;
elements = 1;

Vector half precision
ARMv8.2

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1721

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1

5 4
Rn

0
Rd

Vector half precision variant
FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols

C7-1722

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPRecipStepFused(element1, element2);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1723

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.146

FRECPX
Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for each
vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0

5 4
Rn

0
Rd

Half-precision variant
FRECPX <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 1 1 1 0

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRECPX <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

Assembler symbols

C7-1724

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRecpX(element, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1725

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.147

FRINT32X (vector)
Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer
size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination
register.
A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the
corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative integer representable in the destination size,
and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRINT32X <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer intsize = if op == '0' then 32 else 64;
FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

C7-1726

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1727

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.148

FRINT32X (scalar)
Floating-point Round to 32-bit Integer, using current rounding mode (scalar). This instruction rounds a
floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer
size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination
register.
A zero input returns a zero result with the same sign. When the result value is not numerically equal to the input
value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for
the corresponding result value} the most negative integer representable in the destination size, and an Invalid
Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 0 x 1 0 1 0 0 0 1 1 0 0 0 0
ftype
op

5 4
Rn

0
Rd

Single-precision variant
Applies when ftype == 00.
FRINT32X <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINT32X <Dd>, <Dn>

Decode for all variants of this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '1x' UNDEFINED;
FPRounding rounding = FPRoundingMode(FPCR);

Assembler symbols

C7-1728

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundIntN(operand, FPCR, rounding, 32);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1729

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.149

FRINT32Z (vector)
Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point
values in the SIMD&FP source register to integral floating-point values that fit into a 32-bit integer size using the
Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the
corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative integer representable in the destination size,
and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRINT32Z <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer intsize = if op == '0' then 32 else 64;
FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

C7-1730

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1731

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.150

FRINT32Z (scalar)
Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the
SIMD&FP source register to an integral floating-point value that fits into a 32-bit integer size using the Round
towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
A zero input returns a zero result with the same sign. When the result value is not numerically equal to the
{corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the
instruction returns {for the corresponding result value} the most negative integer representable in the destination
size, and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 0 x 1 0 1 0 0 0 0 1 0 0 0 0
ftype
op

5 4
Rn

0
Rd

Single-precision variant
Applies when ftype == 00.
FRINT32Z <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINT32Z <Dd>, <Dn>

Decode for all variants of this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '1x' UNDEFINED;

Assembler symbols

C7-1732

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundIntN(operand, FPCR, FPRounding_ZERO, 32);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1733

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.151

FRINT64X (vector)
Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer
size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination
register.
A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the
corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative integer representable in the destination size,
and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 1 1 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRINT64X <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer intsize = if op == '0' then 32 else 64;
FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

C7-1734

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1735

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.152

FRINT64X (scalar)
Floating-point Round to 64-bit Integer, using current rounding mode (scalar). This instruction rounds a
floating-point value in the SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer
size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination
register.
A zero input returns a zero result with the same sign. When the result value is not numerically equal to the input
value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the instruction returns {for
the corresponding result value} the most negative integer representable in the destination size, and an Invalid
Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 0 x 1 0 1 0 0 1 1 1 0 0 0 0
ftype
op

5 4
Rn

0
Rd

Single-precision variant
Applies when ftype == 00.
FRINT64X <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINT64X <Dd>, <Dn>

Decode for all variants of this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '1x' UNDEFINED;
FPRounding rounding = FPRoundingMode(FPCR);

Assembler symbols

C7-1736

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundIntN(operand, FPCR, rounding, 64);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1737

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.153

FRINT64Z (vector)
Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point
values in the SIMD&FP source register to integral floating-point values that fit into a 64-bit integer size using the
Round towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
A zero input returns a zero result with the same sign. When one of the result values is not numerically equal to the
corresponding input value, an Inexact exception is raised. When an input is infinite, NaN or out-of-range, the
instruction returns for the corresponding result value the most negative integer representable in the destination size,
and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 1 1 1 0
U
op

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRINT64Z <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer intsize = if op == '0' then 32 else 64;
FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

C7-1738

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1739

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.154

FRINT64Z (scalar)
Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction rounds a floating-point value in the
SIMD&FP source register to an integral floating-point value that fits into a 64-bit integer size using the Round
towards Zero rounding mode, and writes the result to the SIMD&FP destination register.
A zero input returns a zero result with the same sign. When the result value is not numerically equal to the
{corresponding} input value, an Inexact exception is raised. When the input is infinite, NaN or out-of-range, the
instruction returns {for the corresponding result value} the most negative integer representable in the destination
size, and an Invalid Operation floating-point exception is raised.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

ARMv8.5
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 0 x 1 0 1 0 0 1 0 1 0 0 0 0
ftype
op

5 4
Rn

0
Rd

Single-precision variant
Applies when ftype == 00.
FRINT64Z <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINT64Z <Dd>, <Dn>

Decode for all variants of this encoding
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '1x' UNDEFINED;

Assembler symbols

C7-1740

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundIntN(operand, FPCR, FPRounding_ZERO, 64);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1741

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.155

FRINTA (vector)
Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the
Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTA <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTA <Vd>.<T>, <Vn>.<T>

C7-1742

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1743

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.156

FRINTA (scalar)
Floating-point Round to Integral, to nearest with ties to Away (scalar). This instruction rounds a floating-point value
in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest with
Ties to Away rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 1 0 0 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTA <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTA <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTA <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1744

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, FPRounding_TIEAWAY, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1745

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.157

FRINTI (vector)
Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the
rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTI <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTI <Vd>.<T>, <Vn>.<T>

C7-1746

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1747

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.158

FRINTI (scalar)
Floating-point Round to Integral, using current rounding mode (scalar). This instruction rounds a floating-point
value in the SIMD&FP source register to an integral floating-point value of the same size using the rounding mode
that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 1 1 1 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTI <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTI <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTI <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPRoundingMode(FPCR);

Assembler symbols

C7-1748

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1749

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.159

FRINTM (vector)
Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point
values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards
Minus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTM <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTM <Vd>.<T>, <Vn>.<T>

C7-1750

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1751

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.160

FRINTM (scalar)
Floating-point Round to Integral, toward Minus infinity (scalar). This instruction rounds a floating-point value in
the SIMD&FP source register to an integral floating-point value of the same size using the Round towards Minus
Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 0 1 0 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTM <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTM <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTM <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPDecodeRounding('10');

Assembler symbols

C7-1752

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1753

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.161

FRINTN (vector)
Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the
Round to Nearest rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTN <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTN <Vd>.<T>, <Vn>.<T>

C7-1754

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1755

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.162

FRINTN (scalar)
Floating-point Round to Integral, to nearest with ties to even (scalar). This instruction rounds a floating-point value
in the SIMD&FP source register to an integral floating-point value of the same size using the Round to Nearest
rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 0 0 0 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTN <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTN <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTN <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPDecodeRounding('00');

Assembler symbols

C7-1756

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1757

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.163

FRINTP (vector)
Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point
values in the SIMD&FP source register to integral floating-point values of the same size using the Round towards
Plus Infinity rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTP <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 0 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTP <Vd>.<T>, <Vn>.<T>

C7-1758

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1759

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.164

FRINTP (scalar)
Floating-point Round to Integral, toward Plus infinity (scalar). This instruction rounds a floating-point value in the
SIMD&FP source register to an integral floating-point value of the same size using the Round towards Plus Infinity
rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 0 0 1 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTP <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTP <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTP <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPDecodeRounding('01');

Assembler symbols

C7-1760

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1761

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.165

FRINTX (vector)
Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of
floating-point values in the SIMD&FP source register to integral floating-point values of the same size using the
rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
When a result value is not numerically equal to the corresponding input value, an Inexact exception is raised. A zero
input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN
is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTX <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTX <Vd>.<T>, <Vn>.<T>

C7-1762

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1763

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.166

FRINTX (scalar)
Floating-point Round to Integral exact, using current rounding mode (scalar). This instruction rounds a
floating-point value in the SIMD&FP source register to an integral floating-point value of the same size using the
rounding mode that is determined by the FPCR, and writes the result to the SIMD&FP destination register.
When the result value is not numerically equal to the input value, an Inexact exception is raised. A zero input gives
a zero result with the same sign, an infinite input gives an infinite result with the same sign, and a NaN is propagated
as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 1 1 0 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTX <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTX <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTX <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPRoundingMode(FPCR);

Assembler symbols
<Dd>

C7-1764

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, TRUE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1765

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.167

FRINTZ (vector)
Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in
the SIMD&FP source register to integral floating-point values of the same size using the Round towards Zero
rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 1 1 1 1 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Half-precision variant
FRINTZ <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 0 0 1 1 0
U
o2
o1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FRINTZ <Vd>.<T>, <Vn>.<T>

C7-1766

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
when '0xx' rounding =
when '100' rounding =
when '101' UNDEFINED;
when '110' rounding =
when '111' rounding =

FPDecodeRounding(o1:o2);
FPRounding_TIEAWAY;
FPRoundingMode(FPCR); exact = TRUE;
FPRoundingMode(FPCR);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1767

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.168

FRINTZ (scalar)
Floating-point Round to Integral, toward Zero (scalar). This instruction rounds a floating-point value in the
SIMD&FP source register to an integral floating-point value of the same size using the Round towards Zero
rounding mode, and writes the result to the SIMD&FP destination register.
A zero input gives a zero result with the same sign, an infinite input gives an infinite result with the same sign, and
a NaN is propagated as for normal arithmetic.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17

15 14 13 12 11 10 9

0 0 0 1 1 1 1 0 ftype 1 0 0 1 0 1 1 1 0 0 0 0
rmode

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FRINTZ <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FRINTZ <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FRINTZ <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;
FPRounding rounding;
rounding = FPDecodeRounding('11');

Assembler symbols

C7-1768

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPRoundInt(operand, FPCR, rounding, FALSE);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1769

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.169

FRSQRTE
Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each
vector element in the source SIMD&FP register, places the result in a vector, and writes the vector to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Scalar half precision variant
FRSQRTE <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FRSQRTE <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

Vector half precision
ARMv8.2

C7-1770

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Vector half precision variant
FRSQRTE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 1 1 0

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRSQRTE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

ARM DDI 0487F.c
ID072120

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1771

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);
V[d] = result;

C7-1772

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.170

FRSQRTS
Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the
vectors of the two source SIMD&FP registers, subtracts each of the products from 3.0, divides these results by 2.0,
places the results into a vector, and writes the vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1

5 4
Rn

0
Rd

Scalar half precision variant
FRSQRTS <Hd>, <Hn>, <Hm>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = esize;
elements = 1;

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 1 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
FRSQRTS <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 32 << UInt(sz);
datasize = esize;
elements = 1;

Vector half precision
ARMv8.2

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1773

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 1

5 4
Rn

0
Rd

Vector half precision variant
FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 sz 1

16 15 14 13 12 11 10 9
Rm

1 1 1 1 1 1

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols

C7-1774

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

when Q = 0

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1775

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.171

FSQRT (vector)
Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source
SIMD&FP register, places the result in a vector, and writes the vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 1 1 1 1 0 0 1 1 1 1 1 1 0

5 4
Rn

0
Rd

Half-precision variant
FSQRT <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 1 1 1 0

5 4
Rn

0
Rd

Single-precision and double-precision variant
FSQRT <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

Assembler symbols
<Vd>

C7-1776

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FPSqrt(element, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1777

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.172

FSQRT (scalar)
Floating-point Square Root (scalar). This instruction calculates the square root of the value in the SIMD&FP source
register and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 0 0 1 1 1 1 0 ftype 1 0 0 0 0 1 1 1 0 0 0 0
opc

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FSQRT <Hd>, <Hn>

Single-precision variant
Applies when ftype == 00.
FSQRT <Sd>, <Sn>

Double-precision variant
Applies when ftype == 01.
FSQRT <Dd>, <Dn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1778

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<Sn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand = V[n];
result = FPSqrt(operand, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1779

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.173

FSUB (vector)
Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source
SIMD&FP register, from the corresponding elements in the vector in the first source SIMD&FP register, places each
result into elements of a vector, and writes the vector to the destination SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Half-precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 0
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Half-precision variant
FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
abs = (U == '1');

Single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 sz 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 1

5 4
Rn

0
Rd

Single-precision and double-precision variant
FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if sz:Q
integer
integer
integer
boolean

C7-1780

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
abs = (U == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the half-precision variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the single-precision and double-precision variant: is an arrangement specifier, encoded in the
"sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) diff;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
diff = FPSub(element1, element2, FPCR);
Elem[result, e, esize] = if abs then FPAbs(diff) else diff;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1781

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.174

FSUB (scalar)
Floating-point Subtract (scalar). This instruction subtracts the floating-point value of the second source SIMD&FP
register from the floating-point value of the first source SIMD&FP register, and writes the result to the destination
SIMD&FP register.
This instruction can generate a floating-point exception. Depending on the settings in FPCR, the exception results
in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 0 0 1 1 1 1 0 ftype 1

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 0
op

5 4
Rn

0
Rd

Half-precision variant
Applies when ftype == 11.
FSUB <Hd>, <Hn>, <Hm>

Single-precision variant
Applies when ftype == 00.
FSUB <Sd>, <Sn>, <Sm>

Double-precision variant
Applies when ftype == 01.
FSUB <Dd>, <Dn>, <Dm>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize;
case ftype of
when '00' datasize = 32;
when '01' datasize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
datasize = 16;
else
UNDEFINED;

Assembler symbols

C7-1782

<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Dn>

Is the 64-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Dm>

Is the 64-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Hn>

Is the 16-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Hm>

Is the 16-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the first SIMD&FP source register, encoded in the "Rn" field.

<Sm>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
result = FPSub(operand1, operand2, FPCR);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1783

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.175

INS (element)
Insert vector element from another vector element. This instruction copies the vector element of the source
SIMD&FP register to the specified vector element of the destination SIMD&FP register.
This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining
bits to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MOV (element). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 0 1 1 1 0 0 0 0

16 15 14
imm5

0

11 10 9
imm4

1

5 4
Rn

0
Rd

Advanced SIMD variant
INS <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;
integer dst_index = UInt(imm5<4:size+1>);
integer src_index = UInt(imm4<3:size>);
integer idxdsize = if imm4<3> == '1' then 128 else 64;
// imm4<size-1:0> is IGNORED
integer esize = 8 << size;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ts>

Is an element size specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<index1>

Is the destination element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<Vn>

C7-1784

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is the source element index encoded in the "imm5:imm4" field. It can have the following values:

<index2>

imm4<3:0> when imm5 = xxxx1
imm4<3:1> when imm5 = xxx10
imm4<3:2> when imm5 = xx100
imm4<3>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
Unspecified bits in "imm4" are ignored but should be set to zero by an assembler.

Operation
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(128) result;
result = V[d];
Elem[result, dst_index, esize] = Elem[operand, src_index, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1785

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.176

INS (general)
Insert vector element from general-purpose register. This instruction copies the contents of the source
general-purpose register to the specified vector element in the destination SIMD&FP register.
This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining
bits to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MOV (from general). The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 1 1 1

5 4
Rn

0
Rd

Advanced SIMD variant
INS <Vd>.<Ts>[<index>], <R><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;
integer index = UInt(imm5<4:size+1>);
integer esize = 8 << size;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ts>

Is an element size specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<index>

Is the element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<R>

C7-1786

Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
have the following values:
W

when imm5 = xxxx1

W

when imm5 = xxx10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

W

when imm5 = xx100

X

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.

<n>

Operation
CheckFPAdvSIMDEnabled64();
bits(esize) element = X[n];
bits(128) result;
result = V[d];
Elem[result, index, esize] = element;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1787

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.177

LD1 (multiple structures)
Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple
single-element structures from memory and writes the result to one, two, three, or four SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 x x 1 x size
L
opcode

5 4
Rn

0
Rt

One register variant
Applies when opcode == 0111.
LD1 { <Vt>.<T> }, [<Xn|SP>]

Two registers variant
Applies when opcode == 1010.
LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]

Three registers variant
Applies when opcode == 0110.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]

Four registers variant
Applies when opcode == 0010.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 1 0
L

16 15
Rm

12 11 10 9

x x 1 x size
opcode

5 4
Rn

0
Rt

One register, immediate offset variant
Applies when Rm == 11111 && opcode == 0111.
LD1 { <Vt>.<T> }, [<Xn|SP>], <imm>

One register, register offset variant
Applies when Rm != 11111 && opcode == 0111.

C7-1788

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD1 { <Vt>.<T> }, [<Xn|SP>], <Xm>

Two registers, immediate offset variant
Applies when Rm == 11111 && opcode == 1010.
LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>

Two registers, register offset variant
Applies when Rm != 11111 && opcode == 1010.
LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>

Three registers, immediate offset variant
Applies when Rm == 11111 && opcode == 0110.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>

Three registers, register offset variant
Applies when Rm != 11111 && opcode == 0110.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>

Four registers, immediate offset variant
Applies when Rm == 11111 && opcode == 0010.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>

Four registers, register offset variant
Applies when Rm != 11111 && opcode == 0010.
LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1789

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the one register, immediate offset variant: is the post-index immediate offset, encoded in the "Q"
field. It can have the following values:
#8

when Q = 0

#16

when Q = 1

For the two registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:
#16

when Q = 0

#32

when Q = 1

For the three registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:
#24

when Q = 0

#48

when Q = 1

For the four registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:

<Xm>

#32

when Q = 0

#64

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);

C7-1790

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1791

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.178

LD1 (single structure)
Load one single-element structure to one lane of one register. This instruction loads a single-element structure from
memory and writes the result to the specified lane of the SIMD&FP register without affecting the other bits of the
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 x x 0 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 000.
LD1 { <Vt>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 010 && size == x0.
LD1 { <Vt>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 100 && size == 00.
LD1 { <Vt>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 100 && S == 0 && size == 01.
LD1 { <Vt>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 0
L R

16 15
Rm

13 12 11 10 9

x x 0 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 000.
LD1 { <Vt>.B }[<index>], [<Xn|SP>], #1

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 000.
C7-1792

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 010 && size == x0.
LD1 { <Vt>.H }[<index>], [<Xn|SP>], #2

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 010 && size == x0.
LD1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && size == 00.
LD1 { <Vt>.S }[<index>], [<Xn|SP>], #4

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && size == 00.
LD1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && S == 0 && size == 01.
LD1 { <Vt>.D }[<index>], [<Xn|SP>], #8

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && S == 0 && size == 01.
LD1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer scale = UInt(opcode<2:1>);
integer selem = UInt(opcode<0>:R) + 1;
boolean replicate = FALSE;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1793

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer index;
case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;

C7-1794

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1795

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.179

LD1R
Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element
structure from memory and replicates the structure to all the lanes of the SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 1 1 0 0 size
L R
opcode S

5 4
Rn

0
Rt

No offset variant
LD1R { <Vt>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 0
L R

16 15
Rm

13 12 11 10 9

1 1 0 0 size
opcode S

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD1R { <Vt>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD1R { <Vt>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-1796

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

<Xm>

#1

when size = 00

#2

when size = 01

#4

when size = 10

#8

when size = 11

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1797

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1798

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.180

LD2 (multiple structures)
Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from
memory and writes the result to the two SIMD&FP registers, with de-interleaving.
For an example of de-interleaving, see LD3 (multiple structures).
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 1 0
L

16 15
Rm

12 11 10 9

1 0 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1799

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#16

when Q = 0

#32

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();

C7-1800

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1801

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.181

LD2 (single structure)
Load single 2-element structure to one lane of two registers. This instruction loads a 2-element structure from
memory and writes the result to the corresponding elements of the two SIMD&FP registers without affecting the
other bits of the registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 x x 0 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 000.
LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 010 && size == x0.
LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 100 && size == 00.
LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 100 && S == 0 && size == 01.
LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 1
L R

16 15
Rm

13 12 11 10 9

x x 0 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 000.
LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 000.
C7-1802

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 010 && size == x0.
LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 010 && size == x0.
LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && size == 00.
LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && size == 00.
LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && S == 0 && size == 01.
LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && S == 0 && size == 01.
LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

ARM DDI 0487F.c
ID072120

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1803

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

C7-1804

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1805

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.182

LD2R
Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element
structure from memory and replicates the structure to all the lanes of the two SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 0 0 size
L R
opcode S

5 4
Rn

0
Rt

No offset variant
LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 1
L R

16 15
Rm

13 12 11 10 9

1 1 0 0 size
opcode S

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-1806

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

<Xm>

#2

when size = 00

#4

when size = 01

#8

when size = 10

#16

when size = 11

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1807

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1808

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.183

LD3 (multiple structures)
Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from
memory and writes the result to the three SIMD&FP registers, with de-interleaving.
The following figure shows the operation of de-interleaving of a LD3.16 (multiple 3-element structures)
instruction:.
Memory

A is a packed array of
3-element structures.
Each element is a 16-bit
halfword.

A[0].x
A[0].y
A[0].z
A[1].x
A[1].y
A[1].z
A[2].x
A[2].y
A[2].z
A[3].x
A[3].y
A[3].z

X3 X2 X1 X0 D0
Registers

Y3 Y2 Y1 Y0 D1
Z3 Z2 Z1 Z0 D2

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 1 0
L

16 15
Rm

12 11 10 9

0 1 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1809

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#24

when Q = 0

#48

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

C7-1810

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1811

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.184

LD3 (single structure)
Load single 3-element structure to one lane of three registers). This instruction loads a 3-element structure from
memory and writes the result to the corresponding elements of the three SIMD&FP registers without affecting the
other bits of the registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 x x 1 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 001.
LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 011 && size == x0.
LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 101 && size == 00.
LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 101 && S == 0 && size == 01.
LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 0
L R

16 15
Rm

13 12 11 10 9

x x 1 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 001.
LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 001.
C7-1812

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 011 && size == x0.
LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 011 && size == x0.
LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && size == 00.
LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && size == 00.
LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && S == 0 && size == 01.
LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && S == 0 && size == 01.
LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

ARM DDI 0487F.c
ID072120

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1813

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

C7-1814

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1815

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.185

LD3R
Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element
structure from memory and replicates the structure to all the lanes of the three SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 0 0 0 0 0 0 1 1 1 0 size
L R
opcode S

5 4
Rn

0
Rt

No offset variant
LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 0
L R

16 15
Rm

13 12 11 10 9

1 1 1 0 size
opcode S

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-1816

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

<Xm>

#3

when size = 00

#6

when size = 01

#12

when size = 10

#24

when size = 11

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1817

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1818

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.186

LD4 (multiple structures)
Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from
memory and writes the result to the four SIMD&FP registers, with de-interleaving.
For an example of de-interleaving, see LD3 (multiple structures).
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 1 0
L

16 15
Rm

12 11 10 9

0 0 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1819

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#32

when Q = 0

#64

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];

C7-1820

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else
address = X[n];
offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1821

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.187

LD4 (single structure)
Load single 4-element structure to one lane of four registers. This instruction loads a 4-element structure from
memory and writes the result to the corresponding elements of the four SIMD&FP registers without affecting the
other bits of the registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 x x 1 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 001.
LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 011 && size == x0.
LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 101 && size == 00.
LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 101 && S == 0 && size == 01.
LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 1
L R

16 15
Rm

13 12 11 10 9

x x 1 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 001.
LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 001.
C7-1822

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 011 && size == x0.
LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 011 && size == x0.
LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && size == 00.
LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && size == 00.
LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && S == 0 && size == 01.
LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && S == 0 && size == 01.
LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

ARM DDI 0487F.c
ID072120

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1823

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

C7-1824

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1825

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.188

LD4R
Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element
structure from memory and replicates the structure to all the lanes of the four SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 1 0 size
L R
opcode S

5 4
Rn

0
Rt

No offset variant
LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 1 1
L R

16 15
Rm

13 12 11 10 9

1 1 1 0 size
opcode S

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-1826

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "size" field. It can have the following values:

<Xm>

#4

when size = 00

#8

when size = 01

#16

when size = 10

#32

when size = 11

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1827

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1828

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.189

LDNP (SIMD&FP)
Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&FP registers from
memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load
is calculated from a base register value and an optional immediate offset.
For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair
on page C3-216.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 0 0 1
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 01.
LDNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]

128-bit variant
Applies when opc == 10.
LDNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
// Empty.

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see Appendix K1
Architectural Constraints on UNPREDICTABLE Behaviors, and particularly LDNP (SIMD&FP) on page K1-7973.

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dt1>

Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt2>

Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Qt1>

Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt2>

Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<St1>

Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<St2>

Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1829

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.
For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range
-1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = n != 31;

Operation
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data1 = Mem[address, dbytes, AccType_VECSTREAM];
data2 = Mem[address+dbytes, dbytes, AccType_VECSTREAM];
if rt_unknown then
data1 = bits(datasize) UNKNOWN;
data2 = bits(datasize) UNKNOWN;
V[t] = data1;
V[t2] = data2;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1830

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.190

LDP (SIMD&FP)
Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP registers from memory. The address
that is used for the load is calculated from a base register value and an optional immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Post-index
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 0 1 1
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDP <St1>, <St2>, [<Xn|SP>], #<imm>

64-bit variant
Applies when opc == 01.
LDP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>

128-bit variant
Applies when opc == 10.
LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;

Pre-index
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 1 1 1
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDP <St1>, <St2>, [<Xn|SP>, #<imm>]!

64-bit variant
Applies when opc == 01.
LDP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!

128-bit variant
Applies when opc == 10.
LDP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1831

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;

Signed offset
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 1 0 1
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
LDP <St1>, <St2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 01.
LDP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]

128-bit variant
Applies when opc == 10.
LDP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;

Notes for all encodings
For information about the CONSTRAINED UNPREDICTABLE behavior of this instruction, see LDP (SIMD&FP) on
page K1-7973, and particularly LDNP (SIMD&FP) on page K1-7973.

Assembler symbols
<Dt1>

Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt2>

Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Qt1>

Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt2>

Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<St1>

Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<St2>

Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.
For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.

C7-1832

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.
For the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a
multiple of 16 in the range -1024 to 1008, encoded in the "imm7" field as <imm>/16.
For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16
in the range -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if t == t2 then
Constraint c = ConstrainUnpredictable();
assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
case c of
when Constraint_UNKNOWN rt_unknown = TRUE;
// result is UNKNOWN
when Constraint_UNDEF
UNDEFINED;
when Constraint_NOP
EndOfInstruction();
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data1 = Mem[address, dbytes, AccType_VEC];
data2 = Mem[address+dbytes, dbytes, AccType_VEC];
if rt_unknown then
data1 = bits(datasize) UNKNOWN;
data2 = bits(datasize) UNKNOWN;
V[t] = data1;
V[t2] = data2;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1833

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1834

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.191

LDR (immediate, SIMD&FP)
Load SIMD&FP Register (immediate offset). This instruction loads an element from memory, and writes the result
as a scalar to the SIMD&FP register. The address that is used for the load is calculated from a base register value,
a signed immediate offset, and an optional offset that is a multiple of the element size.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 1 0
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 01.
LDR <Bt>, [<Xn|SP>], #<simm>

16-bit variant
Applies when size == 01 && opc == 01.
LDR <Ht>, [<Xn|SP>], #<simm>

32-bit variant
Applies when size == 10 && opc == 01.
LDR <St>, [<Xn|SP>], #<simm>

64-bit variant
Applies when size == 11 && opc == 01.
LDR <Dt>, [<Xn|SP>], #<simm>

128-bit variant
Applies when size == 00 && opc == 11.
LDR <Qt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 1 0
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 01.
ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1835

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

LDR <Bt>, [<Xn|SP>, #<simm>]!

16-bit variant
Applies when size == 01 && opc == 01.
LDR <Ht>, [<Xn|SP>, #<simm>]!

32-bit variant
Applies when size == 10 && opc == 01.
LDR <St>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when size == 11 && opc == 01.
LDR <Dt>, [<Xn|SP>, #<simm>]!

128-bit variant
Applies when size == 00 && opc == 11.
LDR <Qt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
size 1 1 1 1 0 1 x 1
opc

10 9
imm12

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 01.
LDR <Bt>, [<Xn|SP>{, #<pimm>}]

16-bit variant
Applies when size == 01 && opc == 01.
LDR <Ht>, [<Xn|SP>{, #<pimm>}]

32-bit variant
Applies when size == 10 && opc == 01.
LDR <St>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when size == 11 && opc == 01.
LDR <Dt>, [<Xn|SP>{, #<pimm>}]

C7-1836

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

128-bit variant
Applies when size == 00 && opc == 11.
LDR <Qt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

Assembler symbols
<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

For the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting
to 0 and encoded in the "imm12" field.
For the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0
to 8190, defaulting to 0 and encoded in the "imm12" field as <pimm>/2.
For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.
For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.
For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range
0 to 65520, defaulting to 0 and encoded in the "imm12" field as <pimm>/16.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1837

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if !postindex then
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1838

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.192

LDR (literal, SIMD&FP)
Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP register from memory. The
address that is used for the load is calculated from the PC value and an immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23
opc

0 1 1 1 0 0

5 4
imm19

0
Rt

32-bit variant
Applies when opc == 00.
LDR <St>, <label>

64-bit variant
Applies when opc == 01.
LDR <Dt>, <label>

128-bit variant
Applies when opc == 10.
LDR <Qt>, <label>

Decode for all variants of this encoding
integer t = UInt(Rt);
integer size;
bits(64) offset;
case opc of
when '00'
size = 4;
when '01'
size = 8;
when '10'
size = 16;
when '11'
UNDEFINED;
offset = SignExtend(imm19:'00', 64);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Dt>

Is the 64-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be loaded, encoded in the "Rt" field.

<label>

Is the program label from which the data is to be loaded. Its offset from the address of this
instruction, in the range +/-1MB, is encoded as "imm19" times 4.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1839

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
bits(64) address = PC[] + offset;
bits(size*8) data;
if HaveMTEExt() then
SetTagCheckedInstruction(FALSE);
CheckFPAdvSIMDEnabled64();
data = Mem[address, size, AccType_VEC];
V[t] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-1840

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.193

LDR (register, SIMD&FP)
Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP register from memory. The address
that is used for the load is calculated from a base register value and an offset register value. The offset can be
optionally shifted and extended.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 1 1
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

8-fsreg,LDR-8-fsreg variant
Applies when size == 00 && opc == 01 && option != 011.
LDR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

8-fsreg,LDR-8-fsreg variant
Applies when size == 00 && opc == 01 && option == 011.
LDR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

16-fsreg,LDR-16-fsreg variant
Applies when size == 01 && opc == 01.
LDR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

32-fsreg,LDR-32-fsreg variant
Applies when size == 10 && opc == 01.
LDR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

64-fsreg,LDR-64-fsreg variant
Applies when size == 11 && opc == 01.
LDR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

128-fsreg,LDR-128-fsreg variant
Applies when size == 00 && opc == 11.
LDR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for all variants of this encoding
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1841

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

For the 8-bit variant: is the index extend specifier, encoded in the "option" field. It can have the
following values:
UXTW

when option = 010

SXTW

when option = 110

SXTX

when option = 111

For the 128-bit, 16-bit, 32-bit and 64-bit variant: is the index extend/shift specifier, defaulting to
LSL, and which must be omitted for the LSL option when <amount> is omitted. encoded in the
"option" field. It can have the following values:

<amount>

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

For the 8-bit variant: is the index shift amount, it must be #0, encoded in "S" as 0 if omitted, or as 1
if present.
For the 16-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#1

when S = 1

For the 32-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#2

when S = 1

For the 64-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#3

when S = 1

For the 128-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where
it is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:

C7-1842

#0

when S = 0

#4

when S = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH;

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1843

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.194

LDUR (SIMD&FP)
Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP register from memory. The address
that is used for the load is calculated from a base register value and an optional immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 1 0
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 01.
LDUR <Bt>, [<Xn|SP>{, #<simm>}]

16-bit variant
Applies when size == 01 && opc == 01.
LDUR <Ht>, [<Xn|SP>{, #<simm>}]

32-bit variant
Applies when size == 10 && opc == 01.
LDUR <St>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11 && opc == 01.
LDUR <Dt>, [<Xn|SP>{, #<simm>}]

128-bit variant
Applies when size == 00 && opc == 11.
LDUR <Qt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols

C7-1844

<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

<simm>

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1845

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.195

MLA (by element)
Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source
SIMD&FP register by the specified value in the second source SIMD&FP register, and accumulates the results with
the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer
values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 0 0 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

Assembler symbols
<Vd>
<T>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.
Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

C7-1846

when size = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) product;
element2 = UInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = UInt(Elem[operand1, e, esize]);
product = (element1*element2)<esize-1:0>;
if sub_op then
Elem[result, e, esize] = Elem[operand3, e, esize] - product;
else
Elem[result, e, esize] = Elem[operand3, e, esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1847

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.196

MLA (vector)
Multiply-Add to accumulator (vector). This instruction multiplies corresponding elements in the vectors of the two
source SIMD&FP registers, and accumulates the results with the vector elements of the destination SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (U == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

C7-1848

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
product = (UInt(element1)*UInt(element2))<esize-1:0>;
if sub_op then
Elem[result, e, esize] = Elem[operand3, e, esize] - product;
else
Elem[result, e, esize] = Elem[operand3, e, esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1849

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.197

MLS (by element)
Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first
source SIMD&FP register by the specified value in the second source SIMD&FP register, and subtracts the results
from the vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer
values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 1 0 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

Assembler symbols
<Vd>
<T>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.
Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

C7-1850

when size = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) product;
element2 = UInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = UInt(Elem[operand1, e, esize]);
product = (element1*element2)<esize-1:0>;
if sub_op then
Elem[result, e, esize] = Elem[operand3, e, esize] - product;
else
Elem[result, e, esize] = Elem[operand3, e, esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1851

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.198

MLS (vector)
Multiply-Subtract from accumulator (vector). This instruction multiplies corresponding elements in the vectors of
the two source SIMD&FP registers, and subtracts the results from the vector elements of the destination SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean sub_op = (U == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

C7-1852

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
product = (UInt(element1)*UInt(element2))<esize-1:0>;
if sub_op then
Elem[result, e, esize] = Elem[operand3, e, esize] - product;
else
Elem[result, e, esize] = Elem[operand3, e, esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1853

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.199

MOV (scalar)
Move vector element to scalar. This instruction duplicates the specified vector element in the SIMD&FP source
register into a scalar, and writes the result to the SIMD&FP destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the DUP (element) instruction. This means that:
•

The encodings in this description are named to match the encodings of DUP (element).

•

The description of DUP (element) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 0 0 1

5 4
Rn

0
Rd

Scalar variant
MOV <V><d>, <Vn>.<T>[<index>]

is equivalent to
DUP

<V><d>, <Vn>.<T>[<index>]

and is always the preferred disassembly.

Assembler symbols
<V>

Is the destination width specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is the element width specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<index>

Is the element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.

C7-1854

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
The description of DUP (element) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1855

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.200

MOV (element)
Move vector element to another vector element. This instruction copies the vector element of the source SIMD&FP
register to the specified vector element of the destination SIMD&FP register.
This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining
bits to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the INS (element) instruction. This means that:
•

The encodings in this description are named to match the encodings of INS (element).

•

The description of INS (element) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 0 1 1 1 0 0 0 0

16 15 14
imm5

0

11 10 9
imm4

1

5 4
Rn

0
Rd

Advanced SIMD variant
MOV <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]

is equivalent to
INS

<Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]

and is always the preferred disassembly.

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ts>

Is an element size specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<index1>

Is the destination element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<index2>

Is the source element index encoded in the "imm5:imm4" field. It can have the following values:
imm4<3:0> when imm5 = xxxx1
imm4<3:1> when imm5 = xxx10
imm4<3:2> when imm5 = xx100

C7-1856

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

imm4<3>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
Unspecified bits in "imm4" are ignored but should be set to zero by an assembler.

Operation
The description of INS (element) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1857

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.201

MOV (from general)
Move general-purpose register to a vector element. This instruction copies the contents of the source
general-purpose register to the specified vector element in the destination SIMD&FP register.
This instruction can insert data into individual elements within a SIMD&FP register without clearing the remaining
bits to zero.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the INS (general) instruction. This means that:
•

The encodings in this description are named to match the encodings of INS (general).

•

The description of INS (general) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 0 1 1 1

5 4
Rn

0
Rd

Advanced SIMD variant
MOV <Vd>.<Ts>[<index>], <R><n>

is equivalent to
INS

<Vd>.<Ts>[<index>], <R><n>

and is always the preferred disassembly.

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ts>

Is an element size specifier, encoded in the "imm5" field. It can have the following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

D

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<index>

Is the element index encoded in the "imm5" field. It can have the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100
imm5<4>

when imm5 = x1000

The encoding imm5 = x0000 is reserved.
<R>

C7-1858

Is the width specifier for the general-purpose source register, encoded in the "imm5" field. It can
have the following values:
W

when imm5 = xxxx1

W

when imm5 = xxx10

W

when imm5 = xx100

X

when imm5 = x1000

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding imm5 = x0000 is reserved.
Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the "Rn" field.

<n>

Operation
The description of INS (general) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1859

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.202

MOV (vector)
Move vector. This instruction copies the vector in the source SIMD&FP register into the destination SIMD&FP
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the ORR (vector, register) instruction. This means that:
•

The encodings in this description are named to match the encodings of ORR (vector, register).

•

The description of ORR (vector, register) gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 0 1
size

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
MOV <Vd>.<T>, <Vn>.<T>

is equivalent to
ORR

<Vd>.<T>, <Vn>.<T>, <Vn>.<T>

and is the preferred disassembly when Rm == Rn.

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
The description of ORR (vector, register) gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C7-1860

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.203

MOV (to general)
Move vector element to general-purpose register. This instruction reads the unsigned integer from the source
SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination
general-purpose register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the UMOV instruction. This means that:
•

The encodings in this description are named to match the encodings of UMOV.

•

The description of UMOV gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20

16 15 14 13 12 11 10 9

0 Q 0 0 1 1 1 0 0 0 0 x x x 0 0 0 0 1 1 1 1
imm5

5 4
Rn

0
Rd

32-bit variant
Applies when Q == 0 && imm5 == xx100.
MOV <Wd>, <Vn>.S[<index>]

is equivalent to
UMOV <Wd>, <Vn>.S[<index>]

and is always the preferred disassembly.
64-reg,UMOV-64-reg variant
Applies when Q == 1 && imm5 == x1000.
MOV <Xd>, <Vn>.D[<index>]

is equivalent to
UMOV <Xd>, <Vn>.D[<index>]

and is always the preferred disassembly.

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<index>

For the 32-bit variant: is the element index encoded in "imm5<4:3>".
For the 64-reg,UMOV-64-reg variant: is the element index encoded in "imm5<4>".

Operation
The description of UMOV gives the operational pseudocode for this instruction.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1861

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-1862

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.204

MOVI
Move Immediate (vector). This instruction places an immediate constant into every vector element of the
destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15
0 Q op 0 1 1 1 1 0 0 0 0 0 a b c

12 11 10 9 8 7 6 5 4
cmode

0 1 d e

f

g h

0
Rd

8-bit variant
Applies when op == 0 && cmode == 1110.
MOVI <Vd>.<T>, #<imm8>{, LSL #0}

16-bit shifted immediate variant
Applies when op == 0 && cmode == 10x0.
MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit shifted immediate variant
Applies when op == 0 && cmode == 0xx0.
MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit shifting ones variant
Applies when op == 0 && cmode == 110x.
MOVI <Vd>.<T>, #<imm8>, MSL #<amount>

64-bit scalar variant
Applies when Q == 0 && op == 1 && cmode == 1110.
MOVI <Dd>, #<imm>

64-bit vector variant
Applies when Q == 1 && op == 1 && cmode == 1110.
MOVI <Vd>.2D, #<imm>

Decode for all variants of this encoding
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;
ImmediateOp operation;
case cmode:op of
when '0xx00' operation
when '0xx01' operation
when '0xx10' operation
when '0xx11' operation
when '10x00' operation

ARM DDI 0487F.c
ID072120

=
=
=
=
=

ImmediateOp_MOVI;
ImmediateOp_MVNI;
ImmediateOp_ORR;
ImmediateOp_BIC;
ImmediateOp_MOVI;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1863

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '10x01' operation = ImmediateOp_MVNI;
when '10x10' operation = ImmediateOp_ORR;
when '10x11' operation = ImmediateOp_BIC;
when '110x0' operation = ImmediateOp_MOVI;
when '110x1' operation = ImmediateOp_MVNI;
when '1110x' operation = ImmediateOp_MOVI;
when '11110' operation = ImmediateOp_MOVI;
when '11111'
// FMOV Dn,#imm is in main FP instruction set
if Q == '0' then UNDEFINED;
operation = ImmediateOp_MOVI;
imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<imm>

Is a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh',
encoded in "a:b:c:d:e:f:g:h".

<T>

For the 8-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the following
values:
8B

when Q = 0

16B

when Q = 1

For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
2S

when Q = 0

4S

when Q = 1

<imm8>

Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

<amount>

For the 16-bit shifted immediate variant: is the shift amount encoded in the "cmode<1>" field. It can
have the following values:
0

when cmode<1> = 0

8

when cmode<1> = 1

defaulting to 0 if LSL is omitted.
For the 32-bit shifted immediate variant: is the shift amount encoded in the "cmode<2:1>" field. It
can have the following values:
0

when cmode<2:1> = 00

8

when cmode<2:1> = 01

16

when cmode<2:1> = 10

24

when cmode<2:1> = 11

defaulting to 0 if LSL is omitted.
For the 32-bit shifting ones variant: is the shift amount encoded in the "cmode<0>" field. It can have
the following values:

C7-1864

8

when cmode<0> = 0

16

when cmode<0> = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand;
bits(datasize) result;
case operation of
when ImmediateOp_MOVI
result = imm;
when ImmediateOp_MVNI
result = NOT(imm);
when ImmediateOp_ORR
operand = V[rd];
result = operand OR imm;
when ImmediateOp_BIC
operand = V[rd];
result = operand AND NOT(imm);
V[rd] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1865

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.205

MUL (by element)
Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&FP register
by the specified value in the second source SIMD&FP register, places the results in a vector, and writes the vector
to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 0 0 0 H 0

5 4
Rn

0
Rd

Vector variant
MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:

C7-1866

•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) product;
element2 = UInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = UInt(Elem[operand1, e, esize]);
product = (element1*element2)<esize-1:0>;
Elem[result, e, esize] = product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1867

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.206

MUL (vector)
Multiply (vector). This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP
registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if U ==
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
'1' && size != '00' then UNDEFINED;
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean poly = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;
for e = 0 to elements-1

C7-1868

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
if poly then
product = PolynomialMult(element1, element2)<esize-1:0>;
else
product = (UInt(element1)*UInt(element2))<esize-1:0>;
Elem[result, e, esize] = product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1869

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.207

MVN
Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the
inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the NOT instruction. This means that:
•

The encodings in this description are named to match the encodings of NOT.

•

The description of NOT gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0

5 4
Rn

0
Rd

Vector variant
MVN <Vd>.<T>, <Vn>.<T>

is equivalent to
NOT

<Vd>.<T>, <Vn>.<T>

and is always the preferred disassembly.

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
The description of NOT gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C7-1870

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.208

MVNI
Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector
element of the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15
0 Q 1 0 1 1 1 1 0 0 0 0 0 a b c
op

12 11 10 9 8 7 6 5 4
cmode

0 1 d e

f

g h

0
Rd

16-bit shifted immediate variant
Applies when cmode == 10x0.
MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit shifted immediate variant
Applies when cmode == 0xx0.
MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit shifting ones variant
Applies when cmode == 110x.
MVNI <Vd>.<T>, #<imm8>, MSL #<amount>

Decode for all variants of this encoding
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;
ImmediateOp operation;
case cmode:op of
when '0xx01' operation = ImmediateOp_MVNI;
when '0xx11' operation = ImmediateOp_BIC;
when '10x01' operation = ImmediateOp_MVNI;
when '10x11' operation = ImmediateOp_BIC;
when '110x1' operation = ImmediateOp_MVNI;
when '1110x' operation = ImmediateOp_MOVI;
when '11111'
// FMOV Dn,#imm is in main FP instruction set
if Q == '0' then UNDEFINED;
operation = ImmediateOp_MOVI;
imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

ARM DDI 0487F.c
ID072120

when Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1871

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when Q = 1

For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
2S

when Q = 0

4S

when Q = 1

<imm8>

Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".

<amount>

For the 16-bit shifted immediate variant: is the shift amount encoded in the "cmode<1>" field. It can
have the following values:
0

when cmode<1> = 0

8

when cmode<1> = 1

defaulting to 0 if LSL is omitted.
For the 32-bit shifted immediate variant: is the shift amount encoded in the "cmode<2:1>" field. It
can have the following values:
0

when cmode<2:1> = 00

8

when cmode<2:1> = 01

16

when cmode<2:1> = 10

24

when cmode<2:1> = 11

defaulting to 0 if LSL is omitted.
For the 32-bit shifting ones variant: is the shift amount encoded in the "cmode<0>" field. It can have
the following values:
8

when cmode<0> = 0

16

when cmode<0> = 1

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand;
bits(datasize) result;
case operation of
when ImmediateOp_MOVI
result = imm;
when ImmediateOp_MVNI
result = NOT(imm);
when ImmediateOp_ORR
operand = V[rd];
result = operand OR imm;
when ImmediateOp_BIC
operand = V[rd];
result = operand AND NOT(imm);
V[rd] = result;

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

C7-1872

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1873

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.209

NEG (vector)
Negate (vector). This instruction reads each vector element from the source SIMD&FP register, negates each value,
puts the result into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
NEG <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean

!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
neg = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 1 0 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
NEG <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:

C7-1874

•

size = 0x.

•

size = 10.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
if neg then
element = -element;
else
element = Abs(element);
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1875

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.210

NOT
Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&FP register, places the
inverse of each value into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MVN. The alias is always the preferred disassembly.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0

5 4
Rn

0
Rd

Vector variant
NOT <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = NOT(element);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1876

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1877

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.211

ORN (vector)
Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source
SIMD&FP registers, and writes the result to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 1 1
size

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
ORN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<T>

8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
operand2 = NOT(operand2);
result = operand1 OR operand2;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

C7-1878

The values of the data supplied in any of its registers.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1879

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.212

ORR (vector, immediate)
Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination
SIMD&FP register, performs a bitwise OR between each result and an immediate constant, places the result into a
vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9 8 7 6 5 4

0 Q 0 0 1 1 1 1 0 0 0 0 0 a b c x x x 1 0 1 d e
op
cmode

f

g h

0
Rd

16-bit variant
Applies when cmode == 10x1.
ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}

32-bit variant
Applies when cmode == 0xx1.
ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}

Decode for all variants of this encoding
integer rd = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;
ImmediateOp operation;
case cmode:op of
when '0xx00' operation = ImmediateOp_MOVI;
when '0xx10' operation = ImmediateOp_ORR;
when '10x00' operation = ImmediateOp_MOVI;
when '10x10' operation = ImmediateOp_ORR;
when '110x0' operation = ImmediateOp_MOVI;
when '1110x' operation = ImmediateOp_MOVI;
when '11110' operation = ImmediateOp_MOVI;
imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

Assembler symbols
<Vd>

Is the name of the SIMD&FP register, encoded in the "Rd" field.

<T>

For the 16-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:
4H

when Q = 0

8H

when Q = 1

For the 32-bit variant: is an arrangement specifier, encoded in the "Q" field. It can have the
following values:

<imm8>

C7-1880

2S

when Q = 0

4S

when Q = 1

Is an 8-bit immediate encoded in "a:b:c:d:e:f:g:h".
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the 16-bit variant: is the shift amount encoded in the "cmode<1>" field. It can have the
following values:

<amount>

0

when cmode<1> = 0

8

when cmode<1> = 1

defaulting to 0 if LSL is omitted.
For the 32-bit variant: is the shift amount encoded in the "cmode<2:1>" field. It can have the
following values:
0

when cmode<2:1> = 00

8

when cmode<2:1> = 01

16

when cmode<2:1> = 10

24

when cmode<2:1> = 11

defaulting to 0 if LSL is omitted.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand;
bits(datasize) result;
case operation of
when ImmediateOp_MOVI
result = imm;
when ImmediateOp_MVNI
result = NOT(imm);
when ImmediateOp_ORR
operand = V[rd];
result = operand OR imm;
when ImmediateOp_BIC
operand = V[rd];
result = operand AND NOT(imm);
V[rd] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1881

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.213

ORR (vector, register)
Bitwise inclusive OR (vector, register). This instruction performs a bitwise OR between the two source SIMD&FP
registers, and writes the result to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MOV (vector). See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 0 1
size

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 1

5 4

0

Rn

Rd

Three registers of the same type variant
ORR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
datasize = if Q == '1' then 128 else 64;

Alias conditions
Alias

is preferred when

MOV (vector)

Rm == Rn

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<T>

8B

when Q = 0

16B

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
result = operand1 OR operand2;
V[d] = result;

C7-1882

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1883

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.214

PMUL
Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&FP
registers, places the results in a vector, and writes the vector to the destination SIMD&FP register.
For information about multiplying polynomials see Polynomial arithmetic over {0, 1} on page A1-50.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 1 1

5 4
Rn

0
Rd

Three registers of the same type variant
PMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if U ==
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
'1' && size != '00' then UNDEFINED;
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean poly = (U == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

The following encodings are reserved:
•

size = 01, Q = x.

•

size = 1x, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];

C7-1884

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element2 = Elem[operand2, e, esize];
if poly then
product = PolynomialMult(element1, element2)<esize-1:0>;
else
product = (UInt(element1)*UInt(element2))<esize-1:0>;
Elem[result, e, esize] = product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1885

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.215

PMULL, PMULL2
Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the
vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the destination
SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
For information about multiplying polynomials see Polynomial arithmetic over {0, 1} on page A1-50.
The PMULL instruction extracts each source vector from the lower half of each source register, while the PMULL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 1 1 0 0 0

5 4
Rn

0
Rd

Three registers, not all the same type variant
PMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
if size
integer
integer
integer
integer

== '01' || size == '10' then UNDEFINED;
== '11' && !HaveBit128PMULLExt() then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

1Q

when size = 11

The following encodings are reserved:
•

size = 01.

•

size = 10.

The '1Q' arrangement is only allocated in an implementation that includes the Cryptographic
Extension, and is otherwise RESERVED.
<Vn>

C7-1886

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<Tb>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

The following encodings are reserved:
•

size = 01, Q = x.

•

size = 10, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e, esize];
element2 = Elem[operand2, e, esize];
Elem[result, e, 2*esize] = PolynomialMult(element1, element2);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1887

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.216

RADDHN, RADDHN2
Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&FP
register to the corresponding vector element in the second source SIMD&FP register, places the most significant
half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
The results are rounded. For truncated results, see ADDHN, ADDHN2.
The RADDHN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the RADDHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
RADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean round = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

C7-1888

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;
for e = 0 to elements-1
element1 = Elem[operand1, e, 2*esize];
element2 = Elem[operand2, e, 2*esize];
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
sum = sum + round_const;
Elem[result, e, esize] = sum<2*esize-1:esize>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1889

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.217

RAX1
Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a source SIMD&FP register left by 1,
performs a bitwise exclusive OR of the resulting 128-bit vector and the vector in another source SIMD&FP register,
and writes the result to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1

5 4
Rn

0
Rd

Advanced SIMD variant
RAX1 <Vd>.2D, <Vn>.2D, <Vm>.2D

Decode for this encoding
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
V[d] = Vn EOR (ROL(Vm<127:64>, 1):ROL(Vm<63:0>, 1));

Operational information
If PSTATE.DIT is 1:
•

•

C7-1890

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.218

RBIT (vector)
Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&FP register, reverses
the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 0 0 0 0 0 0 1 0 1 1 0

5 4
Rn

0
Rd

Vector variant
RBIT <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<T>

8B

when Q = 0

16B

when Q = 1

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
bits(esize) rev;
for e = 0 to elements-1
element = Elem[operand, e, esize];
for i = 0 to esize-1
rev<esize-1-i> = element<i>;
Elem[result, e, esize] = rev;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1891

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

C7-1892

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.219

REV16 (vector)
Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword
of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the destination
SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 1 1 0
U
o0

5 4
Rn

0
Rd

Vector variant
REV16 <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
// size=esize:
B(0), H(1), S(1), D(S)
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
// op=REVx: 64(0), 32(1), 16(2)
bits(2) op = o0:U;
// => op+size:
//
64+B = 0, 64+H = 1, 64+S =
//
32+B = 1, 32+H = 2, 32+S =
//
16+B = 2, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =
// => 3-(op+size) (index bits in
//
64/B = 3, 64+H = 2, 64+S =
//
32+B = 2, 32+H = 1, 32+S =
//
16+B = 1, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =

2, 64+D
X, 32+D
X, 16+D
X, 8+D
group)
1, 64+D
X, 32+D
X, 16+D
X, 8+D

=
=
=
=

X
X
X
X

=
=
=
=

X
X
X
X

// index bits within group: 1, 2, 3
if UInt(op) + UInt(size) >= 3 then UNDEFINED;
integer container_size;
case op of
when '10' container_size = 16;
when '01' container_size = 32;
when '00' container_size = 64;
integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV esize;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1893

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 01, Q = x.

•

size = 1x, Q = x.

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element = 0;
integer rev_element;
for c = 0 to containers-1
rev_element = element + elements_per_container - 1;
for e = 0 to elements_per_container-1
Elem[result, rev_element, esize] = Elem[operand, element, esize];
element = element + 1;
rev_element = rev_element - 1;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1894

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.220

REV32 (vector)
Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each
word of the vector in the source SIMD&FP register, places the results into a vector, and writes the vector to the
destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 0 1 0
U
o0

5 4
Rn

0
Rd

Vector variant
REV32 <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
// size=esize:
B(0), H(1), S(1), D(S)
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
// op=REVx: 64(0), 32(1), 16(2)
bits(2) op = o0:U;
// => op+size:
//
64+B = 0, 64+H = 1, 64+S =
//
32+B = 1, 32+H = 2, 32+S =
//
16+B = 2, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =
// => 3-(op+size) (index bits in
//
64/B = 3, 64+H = 2, 64+S =
//
32+B = 2, 32+H = 1, 32+S =
//
16+B = 1, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =

2, 64+D
X, 32+D
X, 16+D
X, 8+D
group)
1, 64+D
X, 32+D
X, 16+D
X, 8+D

=
=
=
=

X
X
X
X

=
=
=
=

X
X
X
X

// index bits within group: 1, 2, 3
if UInt(op) + UInt(size) >= 3 then UNDEFINED;
integer container_size;
case op of
when '10' container_size = 16;
when '01' container_size = 32;
when '00' container_size = 64;
integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV esize;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1895

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when size = 01, Q = 1

The encoding size = 1x, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element = 0;
integer rev_element;
for c = 0 to containers-1
rev_element = element + elements_per_container - 1;
for e = 0 to elements_per_container-1
Elem[result, rev_element, esize] = Elem[operand, element, esize];
element = element + 1;
rev_element = rev_element - 1;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1896

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.221

REV64
Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit
elements in each doubleword of the vector in the source SIMD&FP register, places the results into a vector, and
writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 0 0 1 0
U
o0

5 4
Rn

0
Rd

Vector variant
REV64 <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
// size=esize:
B(0), H(1), S(1), D(S)
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
// op=REVx: 64(0), 32(1), 16(2)
bits(2) op = o0:U;
// => op+size:
//
64+B = 0, 64+H = 1, 64+S =
//
32+B = 1, 32+H = 2, 32+S =
//
16+B = 2, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =
// => 3-(op+size) (index bits in
//
64/B = 3, 64+H = 2, 64+S =
//
32+B = 2, 32+H = 1, 32+S =
//
16+B = 1, 16+H = X, 16+S =
//
8+B = X, 8+H = X, 8+S =

2, 64+D
X, 32+D
X, 16+D
X, 8+D
group)
1, 64+D
X, 32+D
X, 16+D
X, 8+D

=
=
=
=

X
X
X
X

=
=
=
=

X
X
X
X

// index bits within group: 1, 2, 3
if UInt(op) + UInt(size) >= 3 then UNDEFINED;
integer container_size;
case op of
when '10' container_size = 16;
when '01' container_size = 32;
when '00' container_size = 64;
integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV esize;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1897

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element = 0;
integer rev_element;
for c = 0 to containers-1
rev_element = element + elements_per_container - 1;
for e = 0 to elements_per_container-1
Elem[result, rev_element, esize] = Elem[operand, element, esize];
element = element + 1;
rev_element = rev_element - 1;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1898

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.222

RSHRN, RSHRN2
Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in
the source SIMD&FP register, right shifts each result by an immediate value, writes the final result to a vector, and
writes the vector to the lower or upper half of the destination SIMD&FP register. The destination vector elements
are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN, SHRN2.
The RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 1 1
op

5 4
Rn

0
Rd

Vector variant
RSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1899

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
Is the right shift amount, in the range 1 to the destination element width in bits, encoded in the
"immh:immb" field. It can have the following values:

<shift>

(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
for e = 0 to elements-1
element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
Elem[result, e, esize] = element<esize-1:0>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1900

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.223

RSUBHN, RSUBHN2
Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source
SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the most
significant half of the result into a vector, and writes the vector to the lower or upper half of the destination
SIMD&FP register.
The results are rounded. For truncated results, see SUBHN, SUBHN2.
The RSUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the RSUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
RSUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean round = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1901

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;
for e = 0 to elements-1
element1 = Elem[operand1, e, 2*esize];
element2 = Elem[operand2, e, 2*esize];
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
sum = sum + round_const;
Elem[result, e, esize] = sum<2*esize-1:esize>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1902

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.224

SABA
Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second
source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates
the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 1 1
ac

5 4
Rn

0
Rd

Three registers of the same type variant
SABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean accumulate = (ac == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1903

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<esize-1:0>;
Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1904

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.225

SABAL, SABAL2
Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or
upper half of the second source SIMD&FP register from the corresponding vector elements of the first source
SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
The SABAL instruction extracts each source vector from the lower half of each source register, while the SABAL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 0
op

5 4
Rn

0
Rd

Three registers, not all the same type variant
SABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean accumulate = (op == '0');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1905

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;
result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1906

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.226

SABD
Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&FP
register from the corresponding elements of the first source SIMD&FP register, places the the absolute values of the
results into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 0 1
ac

5 4
Rn

0
Rd

Three registers of the same type variant
SABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean accumulate = (ac == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1907

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<esize-1:0>;
Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1908

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.227

SABDL, SABDL2
Signed Absolute Difference Long. This instruction subtracts the vector elements of the second source SIMD&FP
register from the corresponding vector elements of the first source SIMD&FP register, places the absolute value of
the results into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements.
The SABDL instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SABDL2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 0 0
op

5 4
Rn

0
Rd

Three registers, not all the same type variant
SABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean accumulate = (op == '0');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1909

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;
result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1910

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.228

SADALP
Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the
vector in the source SIMD&FP register and accumulates the results into the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
SADALP <Vd>.<Ta>, <Vn>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV (2 * esize);
acc = (op == '1');
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 00, Q = 0

8H

when size = 00, Q = 1

2S

when size = 01, Q = 0

4S

when size = 01, Q = 1

1D

when size = 10, Q = 0

2D

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1911

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) sum;
integer op1;
integer op2;
if acc then result = V[d];
for e = 0 to elements-1
op1 = Int(Elem[operand, 2*e+0,
op2 = Int(Elem[operand, 2*e+1,
sum = (op1+op2)<2*esize-1:0>;
if acc then
Elem[result, e, 2*esize] =
else
Elem[result, e, 2*esize] =

esize], unsigned);
esize], unsigned);

Elem[result, e, 2*esize] + sum;
sum;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1912

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.229

SADDL, SADDL2
Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source
SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the results
into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice
as long as the source vector elements. All the values in this instruction are signed integer values.
The SADDL instruction extracts each source vector from the lower half of each source register, while the SADDL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1913

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1914

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.230

SADDLP
Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the
source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
The destination vector elements are twice as long as the source vector elements.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
SADDLP <Vd>.<Ta>, <Vn>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV (2 * esize);
acc = (op == '1');
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 00, Q = 0

8H

when size = 00, Q = 1

2S

when size = 01, Q = 0

4S

when size = 01, Q = 1

1D

when size = 10, Q = 0

2D

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1915

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) sum;
integer op1;
integer op2;
if acc then result = V[d];
for e = 0 to elements-1
op1 = Int(Elem[operand, 2*e+0,
op2 = Int(Elem[operand, 2*e+1,
sum = (op1+op2)<2*esize-1:0>;
if acc then
Elem[result, e, 2*esize] =
else
Elem[result, e, 2*esize] =

esize], unsigned);
esize], unsigned);

Elem[result, e, 2*esize] + sum;
sum;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1916

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.231

SADDLV
Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&FP register
together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as
the source vector elements. All the values in this instruction are signed integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 1 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Advanced SIMD variant
SADDLV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
H

when size = 00

S

when size = 01

D

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1917

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer sum;
sum = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
sum = sum + Int(Elem[operand, e, esize], unsigned);
V[d] = sum<2*esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1918

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.232

SADDW, SADDW2
Signed Add Wide. This instruction adds vector elements of the first source SIMD&FP register to the corresponding
vector elements in the lower or upper half of the second source SIMD&FP register, places the results in a vector,
and writes the vector to the SIMD&FP destination register.
The SADDW instruction extracts the second source vector from the lower half of the second source register, while the
SADDW2 instruction extracts the second source vector from the upper half of the second source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1919

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, 2*esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1920

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.233

SCVTF (vector, fixed-point)
Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from
fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the
SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 0 0 1

5 4
Rn

0
Rd

Scalar variant
SCVTF <V><d>, <V><n>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
datasize = esize;
elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 0 0 1

5 4
Rn

0
Rd

Vector variant
SCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh<3>:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1921

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 000x is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The following encodings are reserved:
•

immh = 0001, Q = x.

•

immh = 1xxx, Q = 0.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 000x is reserved.
For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 0001 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1

C7-1922

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element = Elem[operand, e, esize];
Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1923

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.234

SCVTF (vector, integer)
Signed integer Convert to Floating-point (vector). This instruction converts each element in a vector from signed
integer to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the
SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Scalar half precision variant
SCVTF <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
SCVTF <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 32
datasize =
elements =
unsigned =

<< UInt(sz);
esize;
1;
(U == '1');

Vector half precision
ARMv8.2

C7-1924

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Vector half precision variant
SCVTF <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
SCVTF <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer
boolean

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

ARM DDI 0487F.c
ID072120

when Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1925

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
FPRounding rounding = FPRoundingMode(FPCR);
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-1926

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.235

SCVTF (scalar, fixed-point)
Signed fixed-point Convert to Floating-point (scalar). This instruction converts the signed value in the 32-bit or
64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the
FPCR, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

sf 0 0 1 1 1 1 0 ftype 0 0 0 0 1 0
rmode opcode

10 9
scale

5 4
Rn

0
Rd

32-bit to half-precision variant
Applies when sf == 0 && ftype == 11.
SCVTF <Hd>, <Wn>, #<fbits>

32-bit to single-precision variant
Applies when sf == 0 && ftype == 00.
SCVTF <Sd>, <Wn>, #<fbits>

32-bit to double-precision variant
Applies when sf == 0 && ftype == 01.
SCVTF <Dd>, <Wn>, #<fbits>

64-bit to half-precision variant
Applies when sf == 1 && ftype == 11.
SCVTF <Hd>, <Xn>, #<fbits>

64-bit to single-precision variant
Applies when sf == 1 && ftype == 00.
SCVTF <Sd>, <Xn>, #<fbits>

64-bit to double-precision variant
Applies when sf == 1 && ftype == 01.
SCVTF <Dd>, <Xn>, #<fbits>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1927

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00' fltsize = 32;
when '01' fltsize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
if sf == '0' && scale<5> == '0' then UNDEFINED;
integer fracbits = 64 - UInt(scale);
rounding = FPRoundingMode(FPCR);

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<fbits>

For the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is
the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as
64 minus "scale".
For the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is
the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as
64 minus "scale".

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
intval = X[n];
fltval = FixedToFP(intval, fracbits, FALSE, FPCR, rounding);
V[d] = fltval;

C7-1928

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.236

SCVTF (scalar, integer)
Signed integer Convert to Floating-point (scalar). This instruction converts the signed integer value in the
general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and
writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 0 1 0 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

32-bit to half-precision variant
Applies when sf == 0 && ftype == 11.
SCVTF <Hd>, <Wn>

32-bit to single-precision variant
Applies when sf == 0 && ftype == 00.
SCVTF <Sd>, <Wn>

32-bit to double-precision variant
Applies when sf == 0 && ftype == 01.
SCVTF <Dd>, <Wn>

64-bit to half-precision variant
Applies when sf == 1 && ftype == 11.
SCVTF <Hd>, <Xn>

64-bit to single-precision variant
Applies when sf == 1 && ftype == 00.
SCVTF <Sd>, <Xn>

64-bit to double-precision variant
Applies when sf == 1 && ftype == 01.
SCVTF <Dd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1929

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPRoundingMode(FPCR);

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
intval = X[n];
fltval = FixedToFP(intval, 0, FALSE, FPCR, rounding);
V[d] = fltval;

C7-1930

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.237

SDOT (by element)
Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit
elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element
in the second source register, accumulating the result into the corresponding 32-bit element of the destination
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

1 1 1 0 H 0

5 4
Rn

0
Rd

Vector variant
SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]

Decode for this encoding
if !HaveDOTPExt() then UNDEFINED;
if size != '10' then UNDEFINED;
boolean signed = (U == '0');
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(M:Rm);
index = UInt(H:L);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<index>

Is the element index, encoded in the "H:L" fields.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1931

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) result = V[d];
for e = 0 to elements-1
integer res = 0;
integer element1, element2;
for i = 0 to 3
if signed then
element1 = SInt(Elem[operand1, 4*e+i, esize DIV
element2 = SInt(Elem[operand2, 4*index+i, esize
else
element1 = UInt(Elem[operand1, 4*e+i, esize DIV
element2 = UInt(Elem[operand2, 4*index+i, esize
res = res + element1 * element2;
Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;

C7-1932

4]);
DIV 4]);
4]);
DIV 4]);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.238

SDOT (vector)
Dot Product signed arithmetic (vector). This instruction performs the dot product of the four signed 8-bit elements
in each 32-bit element of the first source register with the four signed 8-bit elements of the corresponding 32-bit
element in the second source register, accumulating the result into the corresponding 32-bit element of the
destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 1

5 4
Rn

0
Rd

Vector variant
SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveDOTPExt() then UNDEFINED;
if size != '10' then UNDEFINED;
boolean signed = (U == '0');
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<Vm>

ARM DDI 0487F.c
ID072120

2S

8B

when Q = 0

16B

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1933

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
result = V[d];
for e = 0 to elements-1
integer res = 0;
integer element1, element2;
for i = 0 to 3
if signed then
element1 = SInt(Elem[operand1, 4*e+i, esize DIV
element2 = SInt(Elem[operand2, 4*e+i, esize DIV
else
element1 = UInt(Elem[operand1, 4*e+i, esize DIV
element2 = UInt(Elem[operand2, 4*e+i, esize DIV
res = res + element1 * element2;
Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;

C7-1934

4]);
4]);
4]);
4]);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.239

SHA1C
SHA1 hash update (choose).

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1C <Qd>, <Sn>, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) X = V[d];
bits(32) Y = V[n];
bits(128) W = V[m];
bits(32) t;

// Note: 32 not 128 bits wide

for e = 0 to 3
t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);
Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
X<63:32> = ROL(X<63:32>, 30);
<Y, X> = ROL(Y:X, 32);
V[d] = X;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1935

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.240

SHA1H
SHA1 fixed rotate.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1H <Sd>, <Sn>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(32) operand = V[n];
V[d] = ROL(operand, 30);

// read element [0] only,

[1-3] zeroed

Operational information
If PSTATE.DIT is 1:
•

•

C7-1936

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.241

SHA1M
SHA1 hash update (majority).

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1M <Qd>, <Sn>, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) X = V[d];
bits(32) Y = V[n];
bits(128) W = V[m];
bits(32) t;

// Note: 32 not 128 bits wide

for e = 0 to 3
t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);
Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
X<63:32> = ROL(X<63:32>, 30);
<Y, X> = ROL(Y:X, 32);
V[d] = X;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1937

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.242

SHA1P
SHA1 hash update (parity).

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1P <Qd>, <Sn>, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

<Sn>

Is the 32-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) X = V[d];
bits(32) Y = V[n];
bits(128) W = V[m];
bits(32) t;

// Note: 32 not 128 bits wide

for e = 0 to 3
t = SHAparity(X<63:32>, X<95:64>, X<127:96>);
Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];
X<63:32> = ROL(X<63:32>, 30);
<Y, X> = ROL(Y:X, 32);
V[d] = X;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1938

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.243

SHA1SU0
SHA1 schedule update 0.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1SU0 <Vd>.4S, <Vn>.4S, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128)
bits(128)
bits(128)
bits(128)

operand1 = V[d];
operand2 = V[n];
operand3 = V[m];
result;

result = operand2<63:0>:operand1<127:64>;
result = result EOR operand1 EOR operand3;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1939

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.244

SHA1SU1
SHA1 schedule update 1.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA1SU1 <Vd>.4S, <Vn>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA1Ext() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand1 EOR LSR(operand2, 32);
result<31:0> = ROL(T<31:0>, 1);
result<63:32> = ROL(T<63:32>, 1);
result<95:64> = ROL(T<95:64>, 1);
result<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1940

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.245

SHA256H2
SHA256 hash update (part 2).

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 0
P

5 4
Rn

0
Rd

Advanced SIMD variant
SHA256H2 <Qd>, <Qn>, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA256Ext() then UNDEFINED;

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

<Qn>

Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) result;
result = SHA256hash(V[n], V[d], V[m], FALSE);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1941

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.246

SHA256H
SHA256 hash update (part 1).

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 0
P

5 4
Rn

0
Rd

Advanced SIMD variant
SHA256H <Qd>, <Qn>, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA256Ext() then UNDEFINED;

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination, encoded in the "Rd" field.

<Qn>

Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) result;
result = SHA256hash(V[d], V[n], V[m], TRUE);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1942

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.247

SHA256SU0
SHA256 schedule update 0.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA256SU0 <Vd>.4S, <Vn>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA256Ext() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand2<31:0>:operand1<127:32>;
bits(32) elt;
for e = 0 to 3
elt = Elem[T, e, 32];
elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
Elem[result, e, 32] = elt + Elem[operand1, e, 32];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1943

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.248

SHA256SU1
SHA256 schedule update 1.

31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0 1 1 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA256SU1 <Vd>.4S, <Vn>.4S, <Vm>.4S

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA256Ext() then UNDEFINED;

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) operand3 = V[m];
bits(128) result;
bits(128) T0 = operand3<31:0>:operand2<127:32>;
bits(64) T1;
bits(32) elt;
T1 = operand3<127:64>;
for e = 0 to 1
elt = Elem[T1, e, 32];
elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
Elem[result, e, 32] = elt;
T1 = result<63:0>;
for e = 2 to 3
elt = Elem[T1, e-2, 32];
elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
Elem[result, e, 32] = elt;
V[d] = result;

C7-1944

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1945

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.249

SHA512H
SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&FP registers and produces a
128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It
returns this value to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA512 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA512H <Qd>, <Qn>, <Vm>.2D

Decode for this encoding
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Qn>

Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vtmp;
bits(64) MSigma1;
bits(64) tmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];
MSigma1 = ROR(Y<127:64>, 14) EOR ROR(Y<127:64>, 18) EOR ROR(Y<127:64>, 41);
Vtmp<127:64> = (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);
Vtmp<127:64> = (Vtmp<127:64> + MSigma1 + W<127:64>);
tmp = Vtmp<127:64> + Y<63:0>;
MSigma1 = ROR(tmp, 14) EOR ROR(tmp, 18) EOR ROR(tmp, 41);
Vtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);
Vtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);
V[d] = Vtmp;

Operational information
If PSTATE.DIT is 1:
•

The execution time of this instruction is independent of:
—

C7-1946

The values of the data supplied in any of its registers.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—
•

ARM DDI 0487F.c
ID072120

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1947

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.250

SHA512H2
SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&FP registers and produces a
128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation.
It returns this value to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA512 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1

5 4
Rn

0
Rd

Advanced SIMD variant
SHA512H2 <Qd>, <Qn>, <Vm>.2D

Decode for this encoding
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Qd>

Is the 128-bit name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Qn>

Is the 128-bit name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vtmp;
bits(64) NSigma0;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];
NSigma0 = ROR(Y<63:0>, 28) EOR ROR(Y<63:0>, 34) EOR ROR(Y<63:0>, 39);
Vtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);
Vtmp<127:64> = (Vtmp<127:64> + NSigma0 + W<127:64>);
NSigma0 = ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>, 34) EOR ROR(Vtmp<127:64>, 39);
Vtmp<63:0> = (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);
Vtmp<63:0> = (Vtmp<63:0> + NSigma0 + W<63:0>);
V[d] = Vtmp;

Operational information
If PSTATE.DIT is 1:
•

C7-1948

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1949

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.251

SHA512SU0
SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP registers and produces a
128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are
performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA512 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 0 1 1 1 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA512SU0 <Vd>.2D, <Vn>.2D

Decode for this encoding
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(64) sig0;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) W = V[d];
sig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR ('0000000':W<127:71>);
Vtmp<63:0> = W<63:0> + sig0;
sig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR ('0000000':X<63:7>);
Vtmp<127:64> = W<127:64> + sig0;
V[d] = Vtmp;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1950

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.252

SHA512SU1
SHA512 Schedule Update 1 takes the values from the three source SIMD&FP registers and produces a 128-bit
output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are
performed after the first 16 iterations within a block. It returns this value to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA512 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SHA512SU1 <Vd>.2D, <Vn>.2D, <Vm>.2D

Decode for this encoding
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(64) sig1;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];
sig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>, 61) EOR ('000000':X<127:70>);
Vtmp<127:64> = W<127:64> + sig1 + Y<127:64>;
sig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>, 61) EOR ('000000':X<63:6>);
Vtmp<63:0> = W<63:0> + sig1 + Y<63:0>;
V[d] = Vtmp;

Operational information
If PSTATE.DIT is 1:
•

•

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

ARM DDI 0487F.c
ID072120

The values of the data supplied in any of its registers.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1951

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

—

C7-1952

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.253

SHADD
Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&FP
registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination
SIMD&FP register.
The results are truncated. For rounded results, see SRHADD.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
SHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1953

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
sum = element1 + element2;
Elem[result, e, esize] = sum<esize:1>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1954

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.254

SHL
Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value,
writes the final result to a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 1 0 1

5 4
Rn

0
Rd

Scalar variant
SHL <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer shift = UInt(immh:immb) - esize;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 1 0 1

5 4
Rn

0
Rd

Vector variant
SHL <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1955

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the left shift amount, in the range 0 to 63, encoded in the "immh:immb"
field. It can have the following values:
(UInt(immh:immb)-64) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
for e = 0 to elements-1
Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1956

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.255

SHLL, SHLL2
Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source
SIMD&FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector
to the destination SIMD&FP register. The destination vector elements are twice as long as the source vector
elements.
The SHLL instruction extracts vector elements from the lower half of the source register, while the SHLL2 instruction
extracts vector elements from the upper half of the source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 1 1 0

5 4
Rn

0
Rd

Vector variant
SHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

integer shift = esize;
boolean unsigned = FALSE;

// Or TRUE without change of functionality

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1957

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the left shift amount, which must be equal to the source element width in bits, encoded in the
"size" field. It can have the following values:

<shift>

8

when size = 00

16

when size = 01

32

when size = 10

The encoding size = 11 is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;
integer element;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], unsigned) << shift;
Elem[result, e, 2*esize] = element<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1958

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.256

SHRN, SHRN2
Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&FP
register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the
lower or upper half of the destination SIMD&FP register. The destination vector elements are half as long as the
source vector elements. The results are truncated. For rounded results, see RSHRN, RSHRN2.
The RSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the RSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 0 1
op

5 4
Rn

0
Rd

Vector variant
SHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1959

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
Is the right shift amount, in the range 1 to the destination element width in bits, encoded in the
"immh:immb" field. It can have the following values:

<shift>

(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
for e = 0 to elements-1
element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
Elem[result, e, esize] = element<esize-1:0>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1960

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.257

SHSUB
Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&FP
register from the corresponding elements in the vector in the first source SIMD&FP register, shifts each result right
one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
SHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1961

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element2 = Int(Elem[operand2, e, esize], unsigned);
diff = element1 - element2;
Elem[result, e, esize] = diff<esize:1>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1962

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.258

SLI
Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register, left
shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the
destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their
existing value. Bits shifted out of the left of each vector element in the source register are lost.
The following figure shows the operation of shift left by 3 for an 8-bit vector element.
63

56 55

0

63

56 55

0

63

56 55

0

Vn.B[7]

Vd.B[7] after operation

Vd.B[7] before operation
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 1 0 1

5 4
Rn

0
Rd

Scalar variant
SLI <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer shift = UInt(immh:immb) - esize;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 1 0 1

5 4
Rn

0
Rd

Vector variant
SLI <Vd>.<T>, <Vn>.<T>, #<shift>

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1963

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the left shift amount, in the range 0 to 63, encoded in the "immh:immb"
field. It can have the following values:
(UInt(immh:immb)-64) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;

C7-1964

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) mask = LSL(Ones(esize), shift);
bits(esize) shifted;
for e = 0 to elements-1
shifted = LSL(Elem[operand, e, esize], shift);
Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1965

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.259

SM3PARTW1
SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers and returns a 128-bit result in
the destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the
input vectors with some fixed rotations, see the Operation pseudocode for more information.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SM3PARTW1 <Vd>.4S, <Vn>.4S, <Vm>.4S

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128)
bits(128)
bits(128)
bits(128)

Vm = V[m];
Vn = V[n];
Vd = V[d];
result;

result<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>, 15):ROL(Vm<95:64>, 15):ROL(Vm<63:32>, 15));
for i = 0 to 3
if i == 3 then
result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>, 15));
result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>, 15) EOR
ROL(result<(32*i)+31:(32*i)>, 23);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1966

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1967

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.260

SM3PARTW2
SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and returns a 128-bit result in the
destination SIMD&FP register. The result is obtained by a three-way exclusive OR of the elements within the input
vectors with some fixed rotations, see the Operation pseudocode for more information.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 1

5 4
Rn

0
Rd

Advanced SIMD variant
SM3PARTW2 <Vd>.4S, <Vn>.4S, <Vm>.4S

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) result;
bits(128) tmp;
bits(32) tmp2;
tmp<127:0> = Vn EOR (ROL(Vm<127:96>, 7):ROL(Vm<95:64>, 7):ROL(Vm<63:32>, 7):ROL(Vm<31:0>, 7));
result<127:0> = Vd<127:0> EOR tmp<127:0>;
tmp2 = ROL(tmp<31:0>, 15);
tmp2 = tmp2 EOR ROL(tmp2, 15) EOR ROL(tmp2, 23);
result<127:96> = result<127:96> EOR tmp2;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

C7-1968

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1969

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.261

SM3SS1
SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&FP register by 12, and adds that 32-bit
value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third
source SIMD&FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector
in the destination SIMD&FP register, with the bottom 96 bits of the vector being written to 0.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 0

16 15 14
Rm

0

10 9
Ra

5 4
Rn

0
Rd

Advanced SIMD variant
SM3SS1 <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the name of the third SIMD&FP source register, encoded in the "Ra" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) Va = V[a];
Vd<127:96> = ROL((ROL(Vn<127:96>, 12) + Vm<127:96> + Va<127:96>), 7);
Vd<95:0> = Zeros();
V[d] = Vd;

Operational information
If PSTATE.DIT is 1:
•

C7-1970

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

ARM DDI 0487F.c
ID072120

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1971

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.262

SM3TT1A
SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value,
and returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three
32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the
following three other 32-bit values:
•

The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive OR.

•

The result of the exclusive OR of the top 32-bit element of the second source vector, Vn, with a rotation left
by 12 of the top 32-bit element of the first source vector.

•

A 32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The other elements of the result are taken from
elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 0 imm2 0 0

5 4
Rn

0
Rd

Advanced SIMD variant
SM3TT1A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer i = UInt(imm2);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

<imm2>

Is a 32-bit element indexed out of <Vm>, encoded in "imm2".

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result;
bits(32) TT1;
bits(32) SS2;
WjPrime = Elem[Vm, i, 32];

C7-1972

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

SS2 = Vn<127:96> EOR ROL(Vd<127:96>, 12);
TT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);
TT1 = (TT1+Vd<31:0>+SS2+WjPrime)<31:0>;
result<31:0> = Vd<63:32>;
result<63:32> = ROL(Vd<95:64>, 9);
result<95:64> = Vd<127:96>;
result<127:96> = TT1;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1973

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.263

SM3TT1B
SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a 2-bit immediate index value, and
returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the
three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and
the following three other 32-bit values:
•

The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.

•

The result of the exclusive OR of the top 32-bit element of the second source vector, Vn, with a rotation left
by 12 of the top 32-bit element of the first source vector.

•

A 32-bit element indexed out of the third source vector, Vm.

The result of this addition is returned as the top element of the result. The other elements of the result are taken from
elements of the first source vector, with the element returned in bits<63:32> being rotated left by 9.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 0 imm2 0 1

5 4
Rn

0
Rd

Advanced SIMD variant
SM3TT1B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer i = UInt(imm2);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

<imm2>

Is a 32-bit element indexed out of <Vm>, encoded in "imm2".

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result;
bits(32) TT1;
bits(32) SS2;
WjPrime = Elem[Vm, i, 32];

C7-1974

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

SS2 = Vn<127:96> EOR ROL(Vd<127:96>, 12);
TT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>);
TT1 = (TT1+Vd<31:0>+SS2+WjPrime)<31:0>;
result<31:0> = Vd<63:32>;
result<63:32> = ROL(Vd<95:64>, 9);
result<95:64> = Vd<127:96>;
result<127:96> = TT1;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1975

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.264

SM3TT2A
SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a 2-bit immediate index value, and
returns a 128-bit result in the destination SIMD&FP register. It performs a three-way exclusive OR of the three
32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the
following three other 32-bit values:
•

The bottom 32-bit element of the first source vector, Vd, that was used for the three-way exclusive OR.

•

The 32-bit element held in the top 32 bits of the second source vector, Vn.

•

A 32-bit element indexed out of the third source vector, Vm.

A three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and
the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the
returned result. The other elements of this result are taken from elements of the first source vector, with the element
returned in bits<63:32> being rotated left by 19.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 0 imm2 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SM3TT2A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer i = UInt(imm2);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

<imm2>

Is a 32-bit element indexed out of <Vm>, encoded in "imm2".

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result;
bits(32) TT2;
Wj = Elem[Vm, i, 32];

C7-1976

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

TT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);
TT2 = (TT2+Vd<31:0>+Vn<127:96>+Wj)<31:0>;
result<31:0> = Vd<63:32>;
result<63:32> = ROL(Vd<95:64>, 19);
result<95:64> = Vd<127:96>;
result<127:96> = TT2 EOR ROL(TT2, 9) EOR ROL(TT2, 17);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1977

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.265

SM3TT2B
SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a 2-bit immediate index value,
and returns a 128-bit result in the destination SIMD&FP register. It performs a 32-bit majority function between the
three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and
the following three other 32-bit values:
•

The bottom 32-bit element of the first source vector, Vd, that was used for the 32-bit majority function.

•

The 32-bit element held in the top 32 bits of the second source vector, Vn.

•

A 32-bit element indexed out of the third source vector, Vm.

A three-way exclusive OR is performed of the result of this addition, the result of the addition rotated left by 9, and
the result of the addition rotated left by 17. The result of this exclusive OR is returned as the top element of the
returned result. The other elements of this result are taken from elements of the first source vector, with the element
returned in bits<63:32> being rotated left by 19.
This instruction is implemented only when FEAT_SM3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 0

16 15 14 13 12 11 10 9
Rm

1 0 imm2 1 1

5 4
Rn

0
Rd

Advanced SIMD variant
SM3TT2B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]

Decode for this encoding
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer i = UInt(imm2);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the third SIMD&FP source register, encoded in the "Rm" field.

<imm2>

Is a 32-bit element indexed out of <Vm>, encoded in "imm2".

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result;
bits(32) TT2;
Wj = Elem[Vm, i, 32];

C7-1978

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

TT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>);
TT2 = (TT2+Vd<31:0>+Vn<127:96>+Wj)<31:0>;
result<31:0> = Vd<63:32>;
result<63:32> = ROL(Vd<95:64>, 19);
result<95:64> = Vd<127:96>;
result<127:96> = TT2 EOR ROL(TT2, 9) EOR ROL(TT2, 17);
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1979

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.266

SM4E
SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP register, and four iterations of the
round key held as the elements of the 128-bit vector in the second source SIMD&FP register. It encrypts the data
by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&FP
register.
This instruction is implemented only when FEAT_SM4 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
1 1 0 0 1 1 1 0 1 1 0 0 0 0 0 0 1 0 0 0 0 1

5 4
Rn

0
Rd

Advanced SIMD variant
SM4E <Vd>.4S, <Vn>.4S

Decode for this encoding
if !HaveSM4Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

Assembler symbols
<Vd>

Is the name of the SIMD&FP source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the second SIMD&FP source register, encoded in the "Rn" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vn = V[n];
bits(32) intval;
bits(8) sboxout;
bits(128) roundresult;
bits(32) roundkey;
roundresult = V[d];
for index = 0 to 3
roundkey = Elem[Vn, index, 32];
intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey;
for i = 0 to 3
Elem[intval, i, 8] = Sbox(Elem[intval, i, 8]);
intval = intval EOR ROL(intval, 2) EOR ROL(intval, 10) EOR ROL(intval, 18) EOR ROL(intval, 24);
intval = intval EOR roundresult<31:0>;
roundresult<31:0> = roundresult<63:32>;
roundresult<63:32> = roundresult<95:64>;
roundresult<95:64> = roundresult<127:96>;
roundresult<127:96> = intval;
V[d] = roundresult;

C7-1980

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1981

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.267

SM4EKEY
SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP register and a 128-bit constant from the
second SIMD&FP register. It derives four iterations of the output key, in accordance with the SM4 standard,
returning the 128-bit result to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SM4 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 0 1 1

16 15 14 13 12 11 10 9
Rm

1 1 0 0 1 0

5 4
Rn

0
Rd

Advanced SIMD variant
SM4EKEY <Vd>.4S, <Vn>.4S, <Vm>.4S

Decode for this encoding
if !HaveSM4Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(32) intval;
bits(8) sboxout;
bits(128) result;
bits(32) const;
bits(128) roundresult;
roundresult = V[n];
for index = 0 to 3
const = Elem[Vm, index, 32];
intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const;
for i = 0 to 3
Elem[intval, i, 8] = Sbox(Elem[intval, i, 8]);
intval = intval EOR ROL(intval, 13) EOR ROL(intval, 23);
intval = intval EOR roundresult<31:0>;
roundresult<31:0> = roundresult<63:32>;
roundresult<63:32> = roundresult<95:64>;
roundresult<95:64> = roundresult<127:96>;
roundresult<127:96> = intval;
V[d] = roundresult;

C7-1982

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1983

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.268

SMAX
Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source
SIMD&FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the
destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 0 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
SMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

C7-1984

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1985

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.269

SMAXP
Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source
SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the largest of each pair of signed integer values into
a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
SMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;

C7-1986

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer maxmin;
for e = 0 to elements-1
element1 = Int(Elem[concat, 2*e, esize], unsigned);
element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1987

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.270

SMAXV
Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP register,
and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this instruction
are signed integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 1 0 0 0 0 1 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Advanced SIMD variant
SMAXV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean min = (op == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

C7-1988

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;
maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
element = Int(Elem[operand, e, esize], unsigned);
maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
V[d] = maxmin<esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1989

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.271

SMIN
Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source
SIMD&FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector
to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 1 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
SMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

C7-1990

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1991

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.272

SMINP
Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source
SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of adjacent
vector elements in the two source SIMD&FP registers, writes the smallest of each pair of signed integer values into
a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 1 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
SMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;

C7-1992

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer maxmin;
for e = 0 to elements-1
element1 = Int(Elem[concat, 2*e, esize], unsigned);
element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1993

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.273

SMINV
Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP register,
and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this
instruction are signed integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Advanced SIMD variant
SMINV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean min = (op == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

C7-1994

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;
maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
element = Int(Elem[operand, e, esize], unsigned);
maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
V[d] = maxmin<esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1995

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.274

SMLAL, SMLAL2 (by element)
Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or
upper half of the first source SIMD&FP register by the specified vector element in the second source SIMD&FP
register, and accumulates the results with the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed
integer values.
The SMLAL instruction extracts vector elements from the lower half of the first source register, while the SMLAL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

C7-1996

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1997

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if sub_op then
Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
else
Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-1998

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.275

SMLAL, SMLAL2 (vector)
Signed Multiply-Add Long (vector). This instruction multiplies corresponding signed integer values in the lower or
upper half of the vectors of the two source SIMD&FP registers, and accumulates the results with the vector elements
of the destination SIMD&FP register. The destination vector elements are twice as long as the elements that are
multiplied.
The SMLAL instruction extracts each source vector from the lower half of each source register, while the SMLAL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
sub_op = (o1 == '1');
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-1999

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
accum = Elem[operand3, e, 2*esize] - product;
else
accum = Elem[operand3, e, 2*esize] + product;
Elem[result, e, 2*esize] = accum;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2000

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.276

SMLSL, SMLSL2 (by element)
Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or
upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied.
The SMLSL instruction extracts vector elements from the lower half of the first source register, while the SMLSL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•
ARM DDI 0487F.c
ID072120

size = 00.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2001

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
else

C7-2002

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2003

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.277

SMLSL, SMLSL2 (vector)
Signed Multiply-Subtract Long (vector). This instruction multiplies corresponding signed integer values in the
lower or upper half of the vectors of the two source SIMD&FP registers, and subtracts the results from the vector
elements of the destination SIMD&FP register. The destination vector elements are twice as long as the elements
that are multiplied.
The SMLSL instruction extracts each source vector from the lower half of each source register, while the SMLSL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
sub_op = (o1 == '1');
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

C7-2004

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
accum = Elem[operand3, e, 2*esize] - product;
else
accum = Elem[operand3, e, 2*esize] + product;
Elem[result, e, 2*esize] = accum;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2005

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.278

SMMLA (vector)
Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer
values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The
resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the
destination vector. This is equivalent to performing an 8-way dot product per destination element.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 1 1 0 1 0 0
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 1
B

5 4
Rn

0
Rd

Vector variant
SMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) addend = V[d];
V[d] = MatMulAdd(addend, operand1, operand2, FALSE, FALSE);

C7-2006

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.279

SMOV
Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source
SIMD&FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination
general-purpose register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 1 0 1 1

5 4
Rn

0
Rd

32-bit variant
Applies when Q == 0.
SMOV <Wd>, <Vn>.<Ts>[<index>]

64-reg,SMOV-64-reg variant
Applies when Q == 1.
SMOV <Xd>, <Vn>.<Ts>[<index>]

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size;
case Q:imm5 of
when 'xxxxx1' size = 0;
when 'xxxx10' size = 1;
when '1xx100' size = 2;
otherwise UNDEFINED;
integer
integer
integer
integer

// SMOV [WX]d, Vn.B
// SMOV [WX]d, Vn.H
// SMOV Xd, Vn.S

idxdsize = if imm5<4> == '1' then 128 else 64;
index = UInt(imm5<4:size+1>);
esize = 8 << size;
datasize = if Q == '1' then 64 else 32;

Assembler symbols
<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ts>

For the 32-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

The encoding imm5 = xxx00 is reserved.
For the 64-reg,SMOV-64-reg variant: is an element size specifier, encoded in the "imm5" field. It
can have the following values:
B

ARM DDI 0487F.c
ID072120

when imm5 = xxxx1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2007

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

H

when imm5 = xxx10

S

when imm5 = xx100

The encoding imm5 = xx000 is reserved.
For the 32-bit variant: is the element index encoded in the "imm5" field. It can have the following
values:

<index>

imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10

The encoding imm5 = xxx00 is reserved.
For the 64-reg,SMOV-64-reg variant: is the element index encoded in the "imm5" field. It can have
the following values:
imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100

The encoding imm5 = xx000 is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
X[d] = SignExtend(Elem[operand, index, esize], datasize);

Operational information
If PSTATE.DIT is 1:
•

•

C7-2008

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.280

SMULL, SMULL2 (by element)
Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper
half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register,
places the result in a vector, and writes the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.
The SMULL instruction extracts vector elements from the lower half of the first source register, while the SMULL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 H 0

5 4
Rn

0
Rd

Vector variant
SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer
boolean

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2009

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = product;
V[d] = result;

C7-2010

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2011

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.281

SMULL, SMULL2 (vector)
Signed Multiply Long (vector). This instruction multiplies corresponding signed integer values in the lower or upper
half of the vectors of the two source SIMD&FP registers, places the results in a vector, and writes the vector to the
destination SIMD&FP register.
The destination vector elements are twice as long as the elements that are multiplied.
The SMULL instruction extracts each source vector from the lower half of each source register, while the SMULL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 0

5 4
Rn

0
Rd

Three registers, not all the same type variant
SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

C7-2012

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
Elem[result, e, 2*esize] = (element1*element2)<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2013

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.282

SQABS
Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&FP register,
puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. All the
values in this instruction are signed integer values.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
SQABS <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 8 << UInt(size);
datasize = esize;
elements = 1;
neg = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
SQABS <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

Assembler symbols
<V>

C7-2014

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
if neg then
element = -element;
else
element = Abs(element);
(Elem[result, e, esize], sat) = SignedSatQ(element, esize);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2015

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.283

SQADD
Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP
registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Scalar variant
SQADD <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Vector variant
SQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

C7-2016

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;
boolean sat;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
sum = element1 + element2;
(Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2017

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.284

SQDMLAL, SQDMLAL2 (by element)
Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the
lower or upper half of the first source SIMD&FP register by the specified vector element of the second source
SIMD&FP register, doubles the results, and accumulates the final results with the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMLAL instruction extracts vector elements from the lower half of the first source register, while the SQDMLAL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 0 1 1 H 0
o2

5 4
Rn

0
Rd

Scalar variant
SQDMLAL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

boolean sub_op = (o2 == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 0 1 1 H 0
o2

5 4
Rn

0
Rd

Vector variant
SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

C7-2018

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:

<Va>

•

size = 00, Q = x.

•

size = 11, Q = x.

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2019

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

<index>

•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
(product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
if sub_op then
accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
else

C7-2020

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
(Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize);
if sat1 || sat2 then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2021

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.285

SQDMLAL, SQDMLAL2 (vector)
Signed saturating Doubling Multiply-Add Long. This instruction multiplies corresponding signed integer values in
the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and accumulates
the final results with the vector elements of the destination SIMD&FP register. The destination vector elements are
twice as long as the elements that are multiplied.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMLAL instruction extracts each source vector from the lower half of each source register, while the SQDMLAL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 0
o1

5 4
Rn

0
Rd

Scalar variant
SQDMLAL <Va><d>, <Vb><n>, <Vb><m>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

boolean sub_op = (o1 == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 0
o1

5 4
Rn

0
Rd

Vector variant
SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer

C7-2022

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
boolean sub_op = (o1 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2023

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
(product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
if sub_op then
accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
else
accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
(Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize);
if sat1 || sat2 then FPSR.QC = '1';
V[d] = result;

C7-2024

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.286

SQDMLSL, SQDMLSL2 (by element)
Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element
in the lower or upper half of the first source SIMD&FP register by the specified vector element of the second source
SIMD&FP register, doubles the results, and subtracts the final results from the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the
values in this instruction are signed integer values.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMLSL instruction extracts vector elements from the lower half of the first source register, while the SQDMLSL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 1 1 1 H 0
o2

5 4
Rn

0
Rd

Scalar variant
SQDMLSL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

boolean sub_op = (o2 == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

0 1 1 1 H 0
o2

5 4
Rn

0
Rd

Vector variant
SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2025

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:

<Va>

•

size = 00, Q = x.

•

size = 11, Q = x.

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:

C7-2026

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

<index>

•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
(product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
if sub_op then
accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2027

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
(Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize);
if sat1 || sat2 then FPSR.QC = '1';
V[d] = result;

C7-2028

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.287

SQDMLSL, SQDMLSL2 (vector)
Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies corresponding signed integer
values in the lower or upper half of the vectors of the two source SIMD&FP registers, doubles the results, and
subtracts the final results from the vector elements of the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMLSL instruction extracts each source vector from the lower half of each source register, while the SQDMLSL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 0
o1

5 4
Rn

0
Rd

Scalar variant
SQDMLSL <Va><d>, <Vb><n>, <Vb><m>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

boolean sub_op = (o1 == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 0
o1

5 4
Rn

0
Rd

Vector variant
SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer

ARM DDI 0487F.c
ID072120

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2029

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
boolean sub_op = (o1 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

C7-2030

•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
(product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
if sub_op then
accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
else
accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
(Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2 * esize);
if sat1 || sat2 then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2031

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.288

SQDMULH (by element)
Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector
element in the first source SIMD&FP register by the specified vector element of the second source SIMD&FP
register, doubles the results, places the most significant half of the final results into a vector, and writes the vector
to the destination SIMD&FP register.
The results are truncated. For rounded results, see SQRDMULH (by element).
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 0 H 0
op

5 4
Rn

0
Rd

Scalar variant
SQDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean round = (op == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 0 H 0
op

5 4
Rn

0
Rd

Vector variant
SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;

C7-2032

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean round = (op == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2033

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<index>

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
product = (2 * element1 * element2) + round_const;
// The following only saturates if element1 and element2 equal -(2^(esize-1))
(Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2034

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.289

SQDMULH (vector)
Signed saturating Doubling Multiply returning High half. This instruction multiplies the values of corresponding
elements of the two source SIMD&FP registers, doubles the results, places the most significant half of the final
results into a vector, and writes the vector to the destination SIMD&FP register.
The results are truncated. For rounded results, see SQRDMULH (vector).
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 1

5 4
Rn

0
Rd

Scalar variant
SQDMULH <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
rounding = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 1

5 4
Rn

0
Rd

Vector variant
SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
rounding = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

ARM DDI 0487F.c
ID072120

when size = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2035

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
product = (2 * element1 * element2) + round_const;
(Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2036

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.290

SQDMULL, SQDMULL2 (by element)
Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the
lower or upper half of the first source SIMD&FP register by the specified vector element of the second source
SIMD&FP register, doubles the results, places the final results in a vector, and writes the vector to the destination
SIMD&FP register. All the values in this instruction are signed integer values.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMULL instruction extracts the first source vector from the lower half of the first source register, while the
SQDMULL2 instruction extracts the first source vector from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 0 1 1 H 0

5 4
Rn

0
Rd

Scalar variant
SQDMULL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 0 1 1 H 0

5 4
Rn

0
Rd

Vector variant
SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2037

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:

<Va>

•

size = 00, Q = x.

•

size = 11, Q = x.

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:

C7-2038

•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

<index>

•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
boolean sat;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
(product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
Elem[result, e, 2*esize] = product;
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2039

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.291

SQDMULL, SQDMULL2 (vector)
Signed saturating Doubling Multiply Long. This instruction multiplies corresponding vector elements in the lower
or upper half of the two source SIMD&FP registers, doubles the results, places the final results in a vector, and
writes the vector to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQDMULL instruction extracts each source vector from the lower half of each source register, while the SQDMULL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 0

5 4
Rn

0
Rd

Scalar variant
SQDMULL <Va><d>, <Vb><n>, <Vb><m>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
part = 0;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1

16 15 14 13 12 11 10 9
Rm

1 1 0 1 0 0

5 4
Rn

0
Rd

Vector variant
SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

C7-2040

== '00' || size == '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Va>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
S

when size = 01

D

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vb>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 00.

•

size = 11.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2041

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
boolean sat;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
(product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
Elem[result, e, 2*esize] = product;
if sat then FPSR.QC = '1';
V[d] = result;

C7-2042

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.292

SQNEG
Signed saturating Negate. This instruction reads each vector element from the source SIMD&FP register, negates
each value, places the result into a vector, and writes the vector to the destination SIMD&FP register. All the values
in this instruction are signed integer values.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
SQNEG <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 8 << UInt(size);
datasize = esize;
elements = 1;
neg = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
SQNEG <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

Assembler symbols
<V>

ARM DDI 0487F.c
ID072120

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2043

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;
for e = 0 to elements-1
element = SInt(Elem[operand, e, esize]);
if neg then
element = -element;
else
element = Abs(element);
(Elem[result, e, esize], sat) = SignedSatQ(element, esize);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2044

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.293

SQRDMLAH (by element)
Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction
multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second
source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the most
significant half of the final results with the vector elements of the destination SIMD&FP register. The results are
rounded.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 1 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 1 H 0
S

5 4
Rn

0
Rd

Scalar variant
SQRDMLAH <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Vector
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 1 H 0
S

5 4
Rn

0
Rd

Vector variant
SQRDMLAH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2045

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.

C7-2046

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

<index>

•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element3 = SInt(Elem[operand3, e, esize]);
if sub_op then
accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
else
accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
(Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2047

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.294

SQRDMLAH (vector)
Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector). This instruction
multiplies the vector elements of the first source SIMD&FP register with the corresponding vector elements of the
second source SIMD&FP register without saturating the multiply results, doubles the results, and accumulates the
most significant half of the final results with the vector elements of the destination SIMD&FP register. The results
are rounded.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1
S

5 4
Rn

0
Rd

Scalar variant
SQRDMLAH <V><d>, <V><n>, <V><m>

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
rounding = TRUE;
sub_op = (S == '1');

Vector
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1
S

5 4
Rn

0
Rd

Vector variant
SQRDMLAH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer
integer
integer
if size
integer
integer

C7-2048

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
element3 = SInt(Elem[operand3, e, esize]);
if sub_op then
accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
else
accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
(Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2049

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.295

SQRDMLSH (by element)
Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction
multiplies the vector elements of the first source SIMD&FP register with the value of a vector element of the second
source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most
significant half of the final results from the vector elements of the destination SIMD&FP register. The results are
rounded.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 1 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0
S

5 4
Rn

0
Rd

Scalar variant
SQRDMLSH <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Vector
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0
S

5 4
Rn

0
Rd

Vector variant
SQRDMLSH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

C7-2050

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2051

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

<index>

•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element3 = SInt(Elem[operand3, e, esize]);
if sub_op then
accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
else
accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
(Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2052

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.296

SQRDMLSH (vector)
Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector). This instruction multiplies
the vector elements of the first source SIMD&FP register with the corresponding vector elements of the second
source SIMD&FP register without saturating the multiply results, doubles the results, and subtracts the most
significant half of the final results from the vector elements of the destination SIMD&FP register. The results are
rounded.
If any of the results overflow, they are saturated. The cumulative saturation bit, FPSR.QC, is set if saturation occurs.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1
S

5 4
Rn

0
Rd

Scalar variant
SQRDMLSH <V><d>, <V><n>, <V><m>

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer
integer
integer
if size
integer
integer
integer
boolean
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
rounding = TRUE;
sub_op = (S == '1');

Vector
ARMv8.1
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

1 0 0 0 1 1
S

5 4
Rn

0
Rd

Vector variant
SQRDMLSH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
if !HaveQRDMLAHExt() then UNDEFINED;
integer
integer
integer
if size
integer
integer

ARM DDI 0487F.c
ID072120

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2053

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
element3 = SInt(Elem[operand3, e, esize]);
if sub_op then
accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
else
accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
(Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2054

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.297

SQRDMULH (by element)
Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each
vector element in the first source SIMD&FP register by the specified vector element of the second source
SIMD&FP register, doubles the results, places the most significant half of the final results into a vector, and writes
the vector to the destination SIMD&FP register.
The results are rounded. For truncated results, see SQDMULH (by element).
If any of the results overflows, they are saturated. If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19
0 1 0 1 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 1 H 0
op

5 4
Rn

0
Rd

Scalar variant
SQRDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean round = (op == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 size L M

16 15 14 13 12 11 10 9
Rm

1 1 0 1 H 0
op

5 4
Rn

0
Rd

Vector variant
SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2055

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean round = (op == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:
0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
<Ts>

Is an element size specifier, encoded in the "size" field. It can have the following values:
H

when size = 01

S

when size = 10

The following encodings are reserved:

C7-2056

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<index>

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:
H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;
element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
product = (2 * element1 * element2) + round_const;
// The following only saturates if element1 and element2 equal -(2^(esize-1))
(Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2057

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.298

SQRDMULH (vector)
Signed saturating Rounding Doubling Multiply returning High half. This instruction multiplies the values of
corresponding elements of the two source SIMD&FP registers, doubles the results, places the most significant half
of the final results into a vector, and writes the vector to the destination SIMD&FP register.
The results are rounded. For truncated results, see SQDMULH (vector).
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 1

5 4
Rn

0
Rd

Scalar variant
SQRDMULH <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
rounding = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 1 0 1

5 4
Rn

0
Rd

Vector variant
SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' || size == '00' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
rounding = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
H

C7-2058

when size = 01

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;
for e = 0 to elements-1
element1 = SInt(Elem[operand1, e, esize]);
element2 = SInt(Elem[operand2, e, esize]);
product = (2 * element1 * element2) + round_const;
(Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2059

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.299

SQRSHL
Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source
SIMD&FP register, shifts it by a value from the least significant byte of the corresponding vector element of the
second source SIMD&FP register, places the results into a vector, and writes the vector to the destination SIMD&FP
register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For
truncated results, see SQSHL (register).
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 1
R S

5 4
Rn

0
Rd

Scalar variant
SQRSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 1
R S

5 4
Rn

0
Rd

Vector variant
SQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

C7-2060

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2061

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.300

SQRSHRN, SQRSHRN2
Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the
source SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that
is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. All the values in this instruction are signed integer values. The destination vector
elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN,
SQSHRN2.
The SQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 1 1
op

5 4
Rn

0
Rd

Scalar variant
SQRSHRN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 1 1
op

5 4
Rn

0
Rd

Vector variant
SQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;

C7-2062

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer
integer
integer
integer

esize = 8 << HighestSetBit(immh);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2063

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

C7-2064

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.301

SQRSHRUN, SQRSHRUN2
Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer
value in the vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the
result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the
vector to the destination SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN,
SQSHRUN2.
The SQRSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQRSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other
bits of the register.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 1 1
op

5 4
Rn

0
Rd

Scalar variant
SQRSHRUN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 1 1
op

5 4
Rn

0
Rd

Vector variant
SQRSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2065

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

The following encodings are reserved:

C7-2066

•

immh = 0000.

•

immh = 1xxx.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
(Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2067

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.302

SQSHL (immediate)
Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&FP
register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the
destination SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 1 0 1
op

5 4
Rn

0
Rd

Scalar variant
SQSHL <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '0000' then UNDEFINED;
esize = 8 << HighestSetBit(immh);
datasize = esize;
elements = 1;

integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 1 0 1
op

5 4
Rn

0
Rd

Vector variant
SQSHL <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;

C7-2068

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 0000 is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

The encoding immh = 0000 is reserved.
For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2069

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], src_unsigned) << shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2070

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.303

SQSHL (register)
Signed saturating Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP
register, shifts each element by a value from the least significant byte of the corresponding element of the second
source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For
rounded results, see SQRSHL.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 1 1
R S

5 4
Rn

0
Rd

Scalar variant
SQSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 1 1
R S

5 4
Rn

0
Rd

Vector variant
SQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2071

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2072

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.304

SQSHLU
Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of
the source SIMD&FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned
integer value, places the result in a vector, and writes the vector to the destination SIMD&FP register. The results
are truncated. For rounded results, see UQRSHL.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 0 0 1
op

5 4
Rn

0
Rd

Scalar variant
SQSHLU <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '0000' then UNDEFINED;
esize = 8 << HighestSetBit(immh);
datasize = esize;
elements = 1;

integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 0 0 1
op

5 4
Rn

0
Rd

Vector variant
SQSHLU <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2073

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 0000 is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

The encoding immh = 0000 is reserved.
For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

C7-2074

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], src_unsigned) << shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2075

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.305

SQSHRN, SQSHRN2
Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source
SIMD&FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a
value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper
half of the destination SIMD&FP register. All the values in this instruction are signed integer values. The destination
vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN, SQRSHRN2.
The SQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 0 1
op

5 4
Rn

0
Rd

Scalar variant
SQSHRN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 0 1
op

5 4
Rn

0
Rd

Vector variant
SQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);

C7-2076

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2077

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

C7-2078

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.306

SQSHRUN, SQSHRUN2
Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the
vector of the source SIMD&FP register, right shifts each value by an immediate value, saturates the result to an
unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to
the destination SIMD&FP register. The results are truncated. For rounded results, see SQRSHRUN, SQRSHRUN2.
The SQSHRUN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQSHRUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 0 1
op

5 4
Rn

0
Rd

Scalar variant
SQSHRUN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 0 0 1
op

5 4
Rn

0
Rd

Vector variant
SQSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2079

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

The following encodings are reserved:

C7-2080

•

immh = 0000.

•

immh = 1xxx.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
(Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2081

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.307

SQSUB
Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register
from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and
writes the vector to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1

5 4
Rn

0
Rd

Scalar variant
SQSUB <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1

5 4
Rn

0
Rd

Vector variant
SQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

C7-2082

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
boolean sat;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
diff = element1 - element2;
(Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2083

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.308

SQXTN, SQXTN2
Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register,
saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or
upper half of the destination SIMD&FP register. The destination vector elements are half as long as the source
vector elements. All the values in this instruction are signed integer values.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
The SQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar variant
SQXTN <Vb><d>, <Va><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
part = 0;
elements = 1;

boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector variant
SQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer

C7-2084

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vb>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 00

S

when size = 01

D

when size = 10

The encoding size = 11 is reserved.
<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2085

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element = Elem[operand, e, 2*esize];
(Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

C7-2086

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.309

SQXTUN, SQXTUN2
Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the
source SIMD&FP register, saturates the value to an unsigned integer value that is half the original width, places the
result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register. The
destination vector elements are half as long as the source vector elements.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
The SQXTUN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SQXTUN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0

5 4
Rn

0
Rd

Scalar variant
SQXTUN <Vb><d>, <Va><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
part = 0;
elements = 1;

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0

5 4
Rn

0
Rd

Vector variant
SQXTUN{2} <Vd>.<Tb>, <Vn>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

ARM DDI 0487F.c
ID072120

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2087

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vb>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 00

S

when size = 01

D

when size = 10

The encoding size = 11 is reserved.
<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;
for e = 0 to elements-1
element = Elem[operand, e, 2*esize];
(Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);

C7-2088

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if sat then FPSR.QC = '1';
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2089

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.310

SRHADD
Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source
SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.
The results are rounded. For truncated results, see SHADD.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
SRHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;

C7-2090

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
Elem[result, e, esize] = (element1+element2+1)<esize:1>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2091

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.311

SRI
Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&FP register,
right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element
in the destination SIMD&FP register such that the new zero bits created by the shift are not inserted but retain their
existing value. Bits shifted out of the right of each vector element of the source register are lost.
The following figure shows the operation of shift right by 3 for an 8-bit vector element.
63

56 55

0

63

56 55

0

63

56 55

0

Vn.B[7]

Vd.B[7] after operation

Vd.B[7] before operation
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 0 0 1

5 4
Rn

0
Rd

Scalar variant
SRI <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer shift = (esize * 2) - UInt(immh:immb);

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 0 0 0 1

5 4
Rn

0
Rd

Vector variant
SRI <Vd>.<T>, <Vn>.<T>, #<shift>

C7-2092

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer shift = (esize * 2) - UInt(immh:immb);

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2093

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

bits(esize) mask = LSR(Ones(esize), shift);
bits(esize) shifted;
for e = 0 to elements-1
shifted = LSR(Elem[operand, e, esize], shift);
Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2094

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.312

SRSHL
Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first
source SIMD&FP register, shifts it by a value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP
register.
If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift. For
a truncating shift, see SSHL.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 1
R S

5 4
Rn

0
Rd

Scalar variant
SRSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 1
R S

5 4
Rn

0
Rd

Vector variant
SRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2095

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
when size = 11

D

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2096

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.313

SRSHR
Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP
register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to
the destination SIMD&FP register. All the values in this instruction are signed integer values. The results are
rounded. For truncated results, see SSHR.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 0 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
SRSHR <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 0 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
SRSHR <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

ARM DDI 0487F.c
ID072120

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2097

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

C7-2098

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.314

SRSRA
Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source
SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector
elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The
results are rounded. For truncated results, see SSRA.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 1 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
SRSRA <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 1 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
SRSRA <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

ARM DDI 0487F.c
ID072120

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2099

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

C7-2100

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.315

SSHL
Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source
SIMD&FP register, shifts each value by a value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP
register.
If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For
a rounding shift, see SRSHL.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 1
R S

5 4
Rn

0
Rd

Scalar variant
SSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 1
R S

5 4
Rn

0
Rd

Vector variant
SSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2101

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
when size = 11

D

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2102

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2103

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.316

SSHLL, SSHLL2
Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&FP register,
left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to
the destination SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
All the values in this instruction are signed integer values.
The SSHLL instruction extracts vector elements from the lower half of the source register, while the SSHLL2 instruction
extracts vector elements from the upper half of the source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias SXTL, SXTL2. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 1 0 0 1

5 4
Rn

0
Rd

Vector variant
SSHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;
boolean unsigned = (U == '1');

Alias conditions
Alias

is preferred when

SXTL, SXTL2

immb == '000' && BitCount(immh) == 1

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

C7-2104

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in the
"immh:immb" field. It can have the following values:

<shift>

(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(datasize*2) result;
integer element;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], unsigned) << shift;
Elem[result, e, 2*esize] = element<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2105

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.317

SSHR
Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right
shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination
SIMD&FP register. All the values in this instruction are signed integer values. The results are truncated. For
rounded results, see SRSHR.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 0 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
SSHR <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 0 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
SSHR <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

C7-2106

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2107

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-2108

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.318

SSRA
Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source
SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector
elements of the destination SIMD&FP register. All the values in this instruction are signed integer values. The
results are truncated. For rounded results, see SRSRA.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 0 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 1 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
SSRA <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 1 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
SSRA <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

ARM DDI 0487F.c
ID072120

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2109

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

C7-2110

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2111

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.319

SSUBL, SSUBL2
Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source
SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the results
into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are signed
integer values. The destination vector elements are twice as long as the source vector elements.
The SSUBL instruction extracts each source vector from the lower half of each source register, while the SSUBL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SSUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

C7-2112

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2113

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.320

SSUBW, SSUBW2
Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source
SIMD&FP register from the corresponding vector element in the first source SIMD&FP register, places the result
in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are signed
integer values.
The SSUBW instruction extracts the second source vector from the lower half of the second source register, while the
SSUBW2 instruction extracts the second source vector from the upper half of the second source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SSUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

C7-2114

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<Tb>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, 2*esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2115

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.321

ST1 (multiple structures)
Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to
memory from one, two, three, or four SIMD&FP registers, without interleaving. Every element of each register is
stored.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 x x 1 x size
L
opcode

5 4
Rn

0
Rt

One register variant
Applies when opcode == 0111.
ST1 { <Vt>.<T> }, [<Xn|SP>]

Two registers variant
Applies when opcode == 1010.
ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]

Three registers variant
Applies when opcode == 0110.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]

Four registers variant
Applies when opcode == 0010.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 0 0
L

16 15
Rm

12 11 10 9

x x 1 x size
opcode

5 4
Rn

0
Rt

One register, immediate offset variant
Applies when Rm == 11111 && opcode == 0111.
ST1 { <Vt>.<T> }, [<Xn|SP>], <imm>

One register, register offset variant
Applies when Rm != 11111 && opcode == 0111.
C7-2116

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

ST1 { <Vt>.<T> }, [<Xn|SP>], <Xm>

Two registers, immediate offset variant
Applies when Rm == 11111 && opcode == 1010.
ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>

Two registers, register offset variant
Applies when Rm != 11111 && opcode == 1010.
ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>

Three registers, immediate offset variant
Applies when Rm == 11111 && opcode == 0110.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>

Three registers, register offset variant
Applies when Rm != 11111 && opcode == 0110.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>

Four registers, immediate offset variant
Applies when Rm == 11111 && opcode == 0010.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>

Four registers, register offset variant
Applies when Rm != 11111 && opcode == 0010.
ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

1D

when size = 11, Q = 0

2D

when size = 11, Q = 1

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2117

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the one register, immediate offset variant: is the post-index immediate offset, encoded in the "Q"
field. It can have the following values:
#8

when Q = 0

#16

when Q = 1

For the two registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:
#16

when Q = 0

#32

when Q = 1

For the three registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:
#24

when Q = 0

#48

when Q = 1

For the four registers, immediate offset variant: is the post-index immediate offset, encoded in the
"Q" field. It can have the following values:

<Xm>

#32

when Q = 0

#64

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);

C7-2118

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2119

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.322

ST1 (single structure)
Store a single-element structure from one lane of one register. This instruction stores the specified element of a
SIMD&FP register to memory.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 0 0 0 0 0 0 0 x x 0 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 000.
ST1 { <Vt>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 010 && size == x0.
ST1 { <Vt>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 100 && size == 00.
ST1 { <Vt>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 100 && S == 0 && size == 01.
ST1 { <Vt>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 0 0
L R

16 15
Rm

13 12 11 10 9

x x 0 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 000.
ST1 { <Vt>.B }[<index>], [<Xn|SP>], #1

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 000.

C7-2120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

ST1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 010 && size == x0.
ST1 { <Vt>.H }[<index>], [<Xn|SP>], #2

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 010 && size == x0.
ST1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && size == 00.
ST1 { <Vt>.S }[<index>], [<Xn|SP>], #4

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && size == 00.
ST1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && S == 0 && size == 01.
ST1 { <Vt>.D }[<index>], [<Xn|SP>], #8

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && S == 0 && size == 01.
ST1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
integer scale = UInt(opcode<2:1>);
integer selem = UInt(opcode<0>:R) + 1;
boolean replicate = FALSE;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2121

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer index;
case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;
else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;

C7-2122

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2123

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.323

ST2 (multiple structures)
Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from
two SIMD&FP registers to memory, with interleaving. Every element of each register is stored.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 0 0
L

16 15
Rm

12 11 10 9

1 0 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-2124

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#16

when Q = 0

#32

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
for r = 0 to rpt-1

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2125

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2126

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.324

ST2 (single structure)
Store single 2-element structure from one lane of two registers. This instruction stores a 2-element structure to
memory from corresponding elements of two SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 0 1 0 0 0 0 0 x x 0 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 000.
ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 010 && size == x0.
ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 100 && size == 00.
ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 100 && S == 0 && size == 01.
ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 0 1
L R

16 15
Rm

13 12 11 10 9

x x 0 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 000.
ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 000.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2127

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 010 && size == x0.
ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 010 && size == x0.
ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && size == 00.
ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && size == 00.
ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 100 && S == 0 && size == 01.
ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 100 && S == 0 && size == 01.
ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

C7-2128

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2129

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2130

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.325

ST3 (multiple structures)
Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to
memory from three SIMD&FP registers, with interleaving. Every element of each register is stored.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 0 0
L

16 15
Rm

12 11 10 9

0 1 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2131

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#24

when Q = 0

#48

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

C7-2132

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2133

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.326

ST3 (single structure)
Store single 3-element structure from one lane of three registers. This instruction stores a 3-element structure to
memory from corresponding elements of three SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 0 0 0 0 0 0 0 x x 1 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 001.
ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 011 && size == x0.
ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 101 && size == 00.
ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 101 && S == 0 && size == 01.
ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 0 0
L R

16 15
Rm

13 12 11 10 9

x x 1 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 001.
ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 001.

C7-2134

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 011 && size == x0.
ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 011 && size == x0.
ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && size == 00.
ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && size == 00.
ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && S == 0 && size == 01.
ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && S == 0 && size == 01.
ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

ARM DDI 0487F.c
ID072120

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2135

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

C7-2136

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2137

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.327

ST4 (multiple structures)
Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to
memory from four SIMD&FP registers, with interleaving. Every element of each register is stored.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

12 11 10 9

0 Q 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 size
L
opcode

5 4
Rn

0
Rt

No offset variant
ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]

Decode for this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 0 1 0 0
L

16 15
Rm

12 11 10 9

0 0 0 0 size
opcode

5 4
Rn

0
Rt

Immediate offset variant
Applies when Rm == 11111.
ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>

Register offset variant
Applies when Rm != 11111.
ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols

C7-2138

<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

Is the post-index immediate offset, encoded in the "Q" field. It can have the following values:

<Xm>

#32

when Q = 0

#64

when Q = 1

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Shared decode for all encodings
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;
integer rpt;
integer selem;

// number of iterations
// structure elements

case opcode of
when '0000' rpt = 1;
when '0010' rpt = 4;
when '0100' rpt = 1;
when '0110' rpt = 3;
when '0111' rpt = 1;
when '1000' rpt = 1;
when '1010' rpt = 2;
otherwise UNDEFINED;

selem
selem
selem
selem
selem
selem
selem

=
=
=
=
=
=
=

4;
1;
3;
1;
1;
2;
1;

//
//
//
//
//
//
//

LD/ST4
LD/ST1
LD/ST3
LD/ST1
LD/ST1
LD/ST2
LD/ST1

(4
(4
(3
(3
(1
(2
(2

registers)
registers)
registers)
registers)
register)
registers)
registers)

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2139

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

address = X[n];
offs = Zeros();
for r = 0 to rpt-1
for e = 0 to elements-1
tt = (t + r) MOD 32;
for s = 0 to selem-1
rval = V[tt];
if memop == MemOp_LOAD then
Elem[rval, e, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[tt] = rval;
else // memop == MemOp_STORE
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
offs = offs + ebytes;
tt = (tt + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2140

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.328

ST4 (single structure)
Store single 4-element structure from one lane of four registers. This instruction stores a 4-element structure to
memory from corresponding elements of four SIMD&FP registers.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

No offset
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15

13 12 11 10 9

0 Q 0 0 1 1 0 1 0 0 1 0 0 0 0 0 x x 1 S size
L R
opcode

5 4
Rn

0
Rt

8-bit variant
Applies when opcode == 001.
ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]

16-bit variant
Applies when opcode == 011 && size == x0.
ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]

32-bit variant
Applies when opcode == 101 && size == 00.
ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]

64-bit variant
Applies when opcode == 101 && S == 0 && size == 01.
ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = integer UNKNOWN;
wback = FALSE;
tag_checked = wback || n != 31;

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 0 1 1 0 1
L R

16 15
Rm

13 12 11 10 9

x x 1 S size
opcode

5 4
Rn

0
Rt

8-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 001.
ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4

8-bit, register offset variant
Applies when Rm != 11111 && opcode == 001.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2141

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>

16-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 011 && size == x0.
ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8

16-bit, register offset variant
Applies when Rm != 11111 && opcode == 011 && size == x0.
ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>

32-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && size == 00.
ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16

32-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && size == 00.
ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>

64-bit, immediate offset variant
Applies when Rm == 11111 && opcode == 101 && S == 0 && size == 01.
ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32

64-bit, register offset variant
Applies when Rm != 11111 && opcode == 101 && S == 0 && size == 01.
ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>

Decode for all variants of this encoding
integer
integer
integer
boolean
boolean

t = UInt(Rt);
n = UInt(Rn);
m = UInt(Rm);
wback = TRUE;
tag_checked = wback || n != 31;

Assembler symbols
<Vt>

Is the name of the first or only SIMD&FP register to be transferred, encoded in the "Rt" field.

<Vt2>

Is the name of the second SIMD&FP register to be transferred, encoded as "Rt" plus 1 modulo 32.

<Vt3>

Is the name of the third SIMD&FP register to be transferred, encoded as "Rt" plus 2 modulo 32.

<Vt4>

Is the name of the fourth SIMD&FP register to be transferred, encoded as "Rt" plus 3 modulo 32.

<index>

For the 8-bit variant: is the element index, encoded in "Q:S:size".
For the 16-bit variant: is the element index, encoded in "Q:S:size<1>".
For the 32-bit variant: is the element index, encoded in "Q:S".
For the 64-bit variant: is the element index, encoded in "Q".

C7-2142

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Xm>

Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the "Rm"
field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer
integer
boolean
integer

scale = UInt(opcode<2:1>);
selem = UInt(opcode<0>:R) + 1;
replicate = FALSE;
index;

case scale of
when 3
// load and replicate
if L == '0' || S == '1' then UNDEFINED;
scale = UInt(size);
replicate = TRUE;
when 0
index = UInt(Q:S:size);
// B[0-15]
when 1
if size<0> == '1' then UNDEFINED;
index = UInt(Q:S:size<1>);
// H[0-7]
when 2
if size<1> == '1' then UNDEFINED;
if size<0> == '0' then
index = UInt(Q:S);
// S[0-3]
else
if S == '1' then UNDEFINED;
index = UInt(Q);
// D[0-1]
scale = 3;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
offs = Zeros();
if replicate then
// load and replicate to all elements
for s = 0 to selem-1
element = Mem[address+offs, ebytes, AccType_VEC];
// replicate to fill 128- or 64-bit register
V[t] = Replicate(element, datasize DIV esize);
offs = offs + ebytes;
t = (t + 1) MOD 32;
else
// load/store one element per register
for s = 0 to selem-1
rval = V[t];
if memop == MemOp_LOAD then
// insert into one lane of 128-bit register
Elem[rval, index, esize] = Mem[address+offs, ebytes, AccType_VEC];
V[t] = rval;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2143

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

else // memop == MemOp_STORE
// extract from one lane of 128-bit register
Mem[address+offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
offs = offs + ebytes;
t = (t + 1) MOD 32;
if wback then
if m != 31
offs =
if n == 31
SP[] =
else
X[n] =

then
X[m];
then
address + offs;
address + offs;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2144

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.329

STNP (SIMD&FP)
Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&FP registers to
memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is
calculated from an address from a base register value and an immediate offset. For information about non-temporal
pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair on page C3-216.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 0 0 0
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 01.
STNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]

128-bit variant
Applies when opc == 10.
STNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
// Empty.

Assembler symbols
<Dt1>

Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt2>

Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Qt1>

Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt2>

Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<St1>

Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<St2>

Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256
to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512
to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.
For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range
-1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2145

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = n != 31;

Operation
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
data1 = V[t];
data2 = V[t2];
Mem[address, dbytes, AccType_VECSTREAM] = data1;
Mem[address+dbytes, dbytes, AccType_VECSTREAM] = data2;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2146

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.330

STP (SIMD&FP)
Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP registers to memory. The address used
for the store is calculated from a base register value and an immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Post-index
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 0 1 0
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STP <St1>, <St2>, [<Xn|SP>], #<imm>

64-bit variant
Applies when opc == 01.
STP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>

128-bit variant
Applies when opc == 10.
STP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;

Pre-index
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 1 1 0
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STP <St1>, <St2>, [<Xn|SP>, #<imm>]!

64-bit variant
Applies when opc == 01.
STP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!

128-bit variant
Applies when opc == 10.
STP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2147

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;

Signed offset
31 30 29 28 27 26 25 24 23 22 21
opc

1 0 1 1 0 1 0 0
L

15 14
imm7

10 9
Rt2

5 4
Rn

0
Rt

32-bit variant
Applies when opc == 00.
STP <St1>, <St2>, [<Xn|SP>{, #<imm>}]

64-bit variant
Applies when opc == 01.
STP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]

128-bit variant
Applies when opc == 10.
STP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;

Assembler symbols
<Dt1>

Is the 64-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt2>

Is the 64-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Qt1>

Is the 128-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt2>

Is the 128-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<St1>

Is the 32-bit name of the first SIMD&FP register to be transferred, encoded in the "Rt" field.

<St2>

Is the 32-bit name of the second SIMD&FP register to be transferred, encoded in the "Rt2" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>

For the 32-bit post-index and 32-bit pre-index variant: is the signed immediate byte offset, a
multiple of 4 in the range -256 to 252, encoded in the "imm7" field as <imm>/4.
For the 32-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in
the range -256 to 252, defaulting to 0 and encoded in the "imm7" field as <imm>/4.
For the 64-bit post-index and 64-bit pre-index variant: is the signed immediate byte offset, a
multiple of 8 in the range -512 to 504, encoded in the "imm7" field as <imm>/8.
For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in
the range -512 to 504, defaulting to 0 and encoded in the "imm7" field as <imm>/8.
For the 128-bit post-index and 128-bit pre-index variant: is the signed immediate byte offset, a
multiple of 16 in the range -1024 to 1008, encoded in the "imm7" field as <imm>/16.

C7-2148

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16
in the range -1024 to 1008, defaulting to 0 and encoded in the "imm7" field as <imm>/16.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
if !postindex then
address = address + offset;
data1 = V[t];
data2 = V[t2];
Mem[address, dbytes, AccType_VEC] = data1;
Mem[address+dbytes, dbytes, AccType_VEC] = data2;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2149

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.331

STR (immediate, SIMD&FP)
Store SIMD&FP register (immediate offset). This instruction stores a single SIMD&FP register to memory. The
address that is used for the store is calculated from a base register value and an immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Post-index
31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 0 0
opc

12 11 10 9
imm9

0 1

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 00.
STR <Bt>, [<Xn|SP>], #<simm>

16-bit variant
Applies when size == 01 && opc == 00.
STR <Ht>, [<Xn|SP>], #<simm>

32-bit variant
Applies when size == 10 && opc == 00.
STR <St>, [<Xn|SP>], #<simm>

64-bit variant
Applies when size == 11 && opc == 00.
STR <Dt>, [<Xn|SP>], #<simm>

128-bit variant
Applies when size == 00 && opc == 10.
STR <Qt>, [<Xn|SP>], #<simm>

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Pre-index
31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 0 0
opc

12 11 10 9
imm9

1 1

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 00.

C7-2150

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

STR <Bt>, [<Xn|SP>, #<simm>]!

16-bit variant
Applies when size == 01 && opc == 00.
STR <Ht>, [<Xn|SP>, #<simm>]!

32-bit variant
Applies when size == 10 && opc == 00.
STR <St>, [<Xn|SP>, #<simm>]!

64-bit variant
Applies when size == 11 && opc == 00.
STR <Dt>, [<Xn|SP>, #<simm>]!

128-bit variant
Applies when size == 00 && opc == 10.
STR <Qt>, [<Xn|SP>, #<simm>]!

Decode for all variants of this encoding
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Unsigned offset
31 30 29 28 27 26 25 24 23 22 21
size 1 1 1 1 0 1 x 0
opc

10 9
imm12

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 00.
STR <Bt>, [<Xn|SP>{, #<pimm>}]

16-bit variant
Applies when size == 01 && opc == 00.
STR <Ht>, [<Xn|SP>{, #<pimm>}]

32-bit variant
Applies when size == 10 && opc == 00.
STR <St>, [<Xn|SP>{, #<pimm>}]

64-bit variant
Applies when size == 11 && opc == 00.
STR <Dt>, [<Xn|SP>{, #<pimm>}]

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2151

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

128-bit variant
Applies when size == 00 && opc == 10.
STR <Qt>, [<Xn|SP>{, #<pimm>}]

Decode for all variants of this encoding
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

Assembler symbols
<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<simm>

Is the signed immediate byte offset, in the range -256 to 255, encoded in the "imm9" field.

<pimm>

For the 8-bit variant: is the optional positive immediate byte offset, in the range 0 to 4095, defaulting
to 0 and encoded in the "imm12" field.
For the 16-bit variant: is the optional positive immediate byte offset, a multiple of 2 in the range 0
to 8190, defaulting to 0 and encoded in the "imm12" field as <pimm>/2.
For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0
to 16380, defaulting to 0 and encoded in the "imm12" field as <pimm>/4.
For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0
to 32760, defaulting to 0 and encoded in the "imm12" field as <pimm>/8.
For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range
0 to 65520, defaulting to 0 and encoded in the "imm12" field as <pimm>/16.

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

Operation for all encodings
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];

C7-2152

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if !postindex then
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;
if wback then
if postindex then
address = address + offset;
if n == 31 then
SP[] = address;
else
X[n] = address;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2153

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.332

STR (register, SIMD&FP)
Store SIMD&FP register (register offset). This instruction stores a single SIMD&FP register to memory. The
address that is used for the store is calculated from a base register value and an offset register value. The offset can
be optionally shifted and extended.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 0 1
opc

16 15
Rm

13 12 11 10 9

option

S 1 0

5 4
Rn

0
Rt

8-fsreg,STR-8-fsreg variant
Applies when size == 00 && opc == 00 && option != 011.
STR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]

8-fsreg,STR-8-fsreg variant
Applies when size == 00 && opc == 00 && option == 011.
STR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]

16-fsreg,STR-16-fsreg variant
Applies when size == 01 && opc == 00.
STR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

32-fsreg,STR-32-fsreg variant
Applies when size == 10 && opc == 00.
STR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

64-fsreg,STR-64-fsreg variant
Applies when size == 11 && opc == 00.
STR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

128-fsreg,STR-128-fsreg variant
Applies when size == 00 && opc == 10.
STR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]

Decode for all variants of this encoding
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
if option<1> == '0' then UNDEFINED;
// sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

Assembler symbols

C7-2154

<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<Wm>

When option<0> is set to 0, is the 32-bit name of the general-purpose index register, encoded in the
"Rm" field.

<Xm>

When option<0> is set to 1, is the 64-bit name of the general-purpose index register, encoded in the
"Rm" field.

<extend>

For the 8-bit variant: is the index extend specifier, encoded in the "option" field. It can have the
following values:
UXTW

when option = 010

SXTW

when option = 110

SXTX

when option = 111

For the 128-bit, 16-bit, 32-bit and 64-bit variant: is the index extend/shift specifier, defaulting to
LSL, and which must be omitted for the LSL option when <amount> is omitted. encoded in the
"option" field. It can have the following values:

<amount>

UXTW

when option = 010

LSL

when option = 011

SXTW

when option = 110

SXTX

when option = 111

For the 8-bit variant: is the index shift amount, it must be #0, encoded in "S" as 0 if omitted, or as 1
if present.
For the 16-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#1

when S = 1

For the 32-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#2

when S = 1

For the 64-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where it
is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:
#0

when S = 0

#3

when S = 1

For the 128-bit variant: is the index shift amount, optional only when <extend> is not LSL. Where
it is permitted to be optional, it defaults to #0. It is encoded in the "S" field. It can have the following
values:

ARM DDI 0487F.c
ID072120

#0

when S = 0

#4

when S = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2155

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH;

Operation
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2156

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.333

STUR (SIMD&FP)
Store SIMD&FP register (unscaled offset). This instruction stores a single SIMD&FP register to memory. The
address that is used for the store is calculated from a base register value and an optional immediate offset.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
size 1 1 1 1 0 0 x 0 0
opc

12 11 10 9
imm9

0 0

5 4
Rn

0
Rt

8-bit variant
Applies when size == 00 && opc == 00.
STUR <Bt>, [<Xn|SP>{, #<simm>}]

16-bit variant
Applies when size == 01 && opc == 00.
STUR <Ht>, [<Xn|SP>{, #<simm>}]

32-bit variant
Applies when size == 10 && opc == 00.
STUR <St>, [<Xn|SP>{, #<simm>}]

64-bit variant
Applies when size == 11 && opc == 00.
STUR <Dt>, [<Xn|SP>{, #<simm>}]

128-bit variant
Applies when size == 00 && opc == 10.
STUR <Qt>, [<Xn|SP>{, #<simm>}]

Decode for all variants of this encoding
integer scale = UInt(opc<1>:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Bt>

Is the 8-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Dt>

Is the 64-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Ht>

Is the 16-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Qt>

Is the 128-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<St>

Is the 32-bit name of the SIMD&FP register to be transferred, encoded in the "Rt" field.

<Xn|SP>

Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2157

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded
in the "imm9" field.

<simm>

Shared decode for all encodings
integer n = UInt(Rn);
integer t = UInt(Rt);
MemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (n != 31);

Operation
if HaveMTEExt() then
SetTagCheckedInstruction(tag_checked);
CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;
if n == 31 then
CheckSPAlignment();
address = SP[];
else
address = X[n];
address = address + offset;
case memop of
when MemOp_STORE
data = V[t];
Mem[address, datasize DIV 8, AccType_VEC] = data;
when MemOp_LOAD
data = Mem[address, datasize DIV 8, AccType_VEC];
V[t] = data;

Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.

C7-2158

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.334

SUB (vector)
Subtract (vector). This instruction subtracts each vector element in the second source SIMD&FP register from the
corresponding vector element in the first source SIMD&FP register, places the result into a vector, and writes the
vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1

5 4
Rn

0
Rd

Scalar variant
SUB <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
!= '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
sub_op = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 1

5 4
Rn

0
Rd

Vector variant
SUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
D

when size = 11

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 0x.

•

size = 10.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2159

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
for e = 0 to elements-1
element1 = Elem[operand1, e,
element2 = Elem[operand2, e,
if sub_op then
Elem[result, e, esize] =
else
Elem[result, e, esize] =

esize];
esize];
element1 - element2;
element1 + element2;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2160

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.335

SUBHN, SUBHN2
Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&FP
register from the corresponding vector element in the first source SIMD&FP register, places the most significant
half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&FP register.
All the values in this instruction are signed integer values.
The results are truncated. For rounded results, see RSUBHN, RSUBHN2.
The SUBHN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the SUBHN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
SUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean round = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2161

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;
for e = 0 to elements-1
element1 = Elem[operand1, e, 2*esize];
element2 = Elem[operand2, e, 2*esize];
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
sum = sum + round_const;
Elem[result, e, esize] = sum<2*esize-1:esize>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2162

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.336

SUDOT (by element)
Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four
signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer
values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding
32-bit element of the destination vector.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 0 0 L M
US

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0

5 4
Rn

0
Rd

Vector variant
SUDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
boolean op1_unsigned = (US == '1');
boolean op2_unsigned = (US == '0');
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer d = UInt(Rd);
integer i = UInt(H:L);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<index>

Is the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the
"H:L" fields.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2163

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
bits(32) res = Elem[operand3, e, 32];
for b = 0 to 3
integer element1 = Int(Elem[operand1, 4*e+b, 8], op1_unsigned);
integer element2 = Int(Elem[operand2, 4*i+b, 8], op2_unsigned);
res = res + element1 * element2;
Elem[result, e, 32] = res;
V[d] = result;

C7-2164

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.337

SUQADD
Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector
elements in the source SIMD&FP register to corresponding signed integer values of the vector elements in the
destination SIMD&FP register, and writes the resulting signed integer values to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 0 1 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
SUQADD <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
SUQADD <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

ARM DDI 0487F.c
ID072120

when size = 00

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2165

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(datasize) operand2 = V[d];
integer op1;
integer op2;
boolean sat;
for e = 0 to elements-1
op1 = Int(Elem[operand, e, esize], !unsigned);
op2 = Int(Elem[operand2, e, esize], unsigned);
(Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2166

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.338

SXTL, SXTL2
Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source
SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements. All the values in this instruction are signed integer values.
The SXTL instruction extracts the source vector from the lower half of the source register, while the SXTL2 instruction
extracts the source vector from the upper half of the source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the SSHLL, SSHLL2 instruction. This means that:
•

The encodings in this description are named to match the encodings of SSHLL, SSHLL2.

•

The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22
0 Q 0 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

0 0 0 1 0 1 0 0 1
immb

5 4
Rn

0
Rd

Vector variant
SXTL{2} <Vd>.<Ta>, <Vn>.<Tb>

is equivalent to
SSHLL{2}

<Vd>.<Ta>, <Vn>.<Tb>, #0

and is the preferred disassembly when BitCount(immh) == 1.

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2167

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.

Operation
The description of SSHLL, SSHLL2 gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C7-2168

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.339

TBL
Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&FP
register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source
table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&FP
register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is
used to describe the table, the first source register describes the lowest bytes of the table.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0

len

0 0 0
op

5 4
Rn

0
Rd

Two register table variant
Applies when len == 01.
TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>

Three register table variant
Applies when len == 10.
TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>

Four register table variant
Applies when len == 11.
TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>

Single register table variant
Applies when len == 00.
TBL <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer
integer
integer
boolean

datasize = if Q == '1' then 128 else 64;
elements = datasize DIV 8;
regs = UInt(len) + 1;
is_tbl = (op == '0');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<Vn>

ARM DDI 0487F.c
ID072120

8B

when Q = 0

16B

when Q = 1

For the four register table, three register table and two register table variant: is the name of the first
SIMD&FP table register, encoded in the "Rn" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2169

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the single register table variant: is the name of the SIMD&FP table register, encoded in the "Rn"
field.
<Vn+1>

Is the name of the second SIMD&FP table register, encoded as "Rn" plus 1 modulo 32.

<Vn+2>

Is the name of the third SIMD&FP table register, encoded as "Rn" plus 2 modulo 32.

<Vn+3>

Is the name of the fourth SIMD&FP table register, encoded as "Rn" plus 3 modulo 32.

<Vm>

Is the name of the SIMD&FP index register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) indices = V[m];
bits(128*regs) table = Zeros();
bits(datasize) result;
integer index;
// Create table from registers
for i = 0 to regs-1
table<128*i+127:128*i> = V[n];
n = (n + 1) MOD 32;
result = if is_tbl then Zeros() else V[d];
for i = 0 to elements-1
index = UInt(Elem[indices, i, 8]);
if index < 16 * regs then
Elem[result, i, 8] = Elem[table, index, 8];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2170

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.340

TBX
Table vector lookup extension. This instruction reads each value from the vector elements in the index source
SIMD&FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to
four source table SIMD&FP registers, places the lookup result in a vector, and writes the vector to the destination
SIMD&FP register. If an index is out of range for the table, the existing value in the vector element of the destination
register is left unchanged. If more than one source register is used to describe the table, the first source register
describes the lowest bytes of the table.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
Rm

0

len

1 0 0
op

5 4
Rn

0
Rd

Two register table variant
Applies when len == 01.
TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>

Three register table variant
Applies when len == 10.
TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>

Four register table variant
Applies when len == 11.
TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>

Single register table variant
Applies when len == 00.
TBX <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer
integer
integer
boolean

datasize = if Q == '1' then 128 else 64;
elements = datasize DIV 8;
regs = UInt(len) + 1;
is_tbl = (op == '0');

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2171

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

For the four register table, three register table and two register table variant: is the name of the first
SIMD&FP table register, encoded in the "Rn" field.

<Vn>

For the single register table variant: is the name of the SIMD&FP table register, encoded in the "Rn"
field.
<Vn+1>

Is the name of the second SIMD&FP table register, encoded as "Rn" plus 1 modulo 32.

<Vn+2>

Is the name of the third SIMD&FP table register, encoded as "Rn" plus 2 modulo 32.

<Vn+3>

Is the name of the fourth SIMD&FP table register, encoded as "Rn" plus 3 modulo 32.

<Vm>

Is the name of the SIMD&FP index register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) indices = V[m];
bits(128*regs) table = Zeros();
bits(datasize) result;
integer index;
// Create table from registers
for i = 0 to regs-1
table<128*i+127:128*i> = V[n];
n = (n + 1) MOD 32;
result = if is_tbl then Zeros() else V[d];
for i = 0 to elements-1
index = UInt(Elem[indices, i, 8]);
if index < 16 * regs then
Elem[result, i, 8] = Elem[table, index, 8];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2172

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.341

TRN1
Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two
source SIMD&FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the
vector to the destination SIMD&FP register. Vector elements from the first source register are placed into
even-numbered elements of the destination vector, starting at zero, while vector elements from the second source
register are placed into odd-numbered elements of the destination vector.

Note
By using this instruction with TRN2, a 2 x 2 matrix can be transposed.
The following figure shows the operation of TRN1 and TRN2 halfword operations where Q = 0.
TRN1.16

TRN2.16

Vn

Vn

3

2

1

0

3

Vd

Vd

Vm

Vm

2

1

0

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
TRN1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2173

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
for p = 0 to pairs-1
Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2174

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.342

TRN2
Transpose vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two
source SIMD&FP registers, places each result into consecutive elements of a vector, and writes the vector to the
destination SIMD&FP register. Vector elements from the first source register are placed into even-numbered
elements of the destination vector, starting at zero, while vector elements from the second source register are placed
into odd-numbered elements of the destination vector.

Note
By using this instruction with TRN1, a 2 x 2 matrix can be transposed.
The following figure shows the operation of TRN1 and TRN2 halfword operations where Q = 0.
TRN1.16

TRN2.16

Vn

Vn

3

2

1

0

3

Vd

Vd

Vm

Vm

2

1

0

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 1 1 0 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
TRN2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2175

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
for p = 0 to pairs-1
Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2176

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.343

UABA
Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second
source SIMD&FP register from the corresponding elements of the first source SIMD&FP register, and accumulates
the absolute values of the results into the elements of the vector of the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 1 1
ac

5 4
Rn

0
Rd

Three registers of the same type variant
UABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean accumulate = (ac == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2177

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<esize-1:0>;
Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2178

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.344

UABAL, UABAL2
Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or
upper half of the second source SIMD&FP register from the corresponding vector elements of the first source
SIMD&FP register, and accumulates the absolute values of the results into the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the source vector elements. All the values
in this instruction are unsigned integer values.
The UABAL instruction extracts each source vector from the lower half of each source register, while the UABAL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 0
op

5 4
Rn

0
Rd

Three registers, not all the same type variant
UABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean accumulate = (op == '0');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2179

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;
result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2180

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.345

UABD
Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source
SIMD&FP register from the corresponding elements of the first source SIMD&FP register, places the the absolute
values of the results into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 0 1
ac

5 4
Rn

0
Rd

Three registers of the same type variant
UABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean accumulate = (ac == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2181

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<esize-1:0>;
Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2182

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.346

UABDL, UABDL2
Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the
second source SIMD&FP register from the corresponding vector elements of the first source SIMD&FP register,
places the absolute value of the result into a vector, and writes the vector to the destination SIMD&FP register. The
destination vector elements are twice as long as the source vector elements. All the values in this instruction are
unsigned integer values.
The UABDL instruction extracts each source vector from the lower half of each source register, while the UABDL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 1 0 0
op

5 4
Rn

0
Rd

Three registers, not all the same type variant
UABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean accumulate = (op == '0');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

ARM DDI 0487F.c
ID072120

when size = 00, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2183

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;
result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
absdiff = Abs(element1-element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2184

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.347

UADALP
Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from
the vector in the source SIMD&FP register and accumulates the results with the vector elements of the destination
SIMD&FP register. The destination vector elements are twice as long as the source vector elements.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 1 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
UADALP <Vd>.<Ta>, <Vn>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV (2 * esize);
acc = (op == '1');
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 00, Q = 0

8H

when size = 00, Q = 1

2S

when size = 01, Q = 0

4S

when size = 01, Q = 1

1D

when size = 10, Q = 0

2D

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2185

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) sum;
integer op1;
integer op2;
if acc then result = V[d];
for e = 0 to elements-1
op1 = Int(Elem[operand, 2*e+0,
op2 = Int(Elem[operand, 2*e+1,
sum = (op1+op2)<2*esize-1:0>;
if acc then
Elem[result, e, 2*esize] =
else
Elem[result, e, 2*esize] =

esize], unsigned);
esize], unsigned);

Elem[result, e, 2*esize] + sum;
sum;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2186

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.348

UADDL, UADDL2
Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source
SIMD&FP register to the corresponding vector element of the second source SIMD&FP register, places the result
into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice
as long as the source vector elements. All the values in this instruction are unsigned integer values.
The UADDL instruction extracts each source vector from the lower half of each source register, while the UADDL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
UADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2187

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2188

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.349

UADDLP
Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the
source SIMD&FP register, places the result into a vector, and writes the vector to the destination SIMD&FP register.
The destination vector elements are twice as long as the source vector elements.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Vector variant
UADDLP <Vd>.<Ta>, <Vn>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV (2 * esize);
acc = (op == '1');
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 00, Q = 0

8H

when size = 00, Q = 1

2S

when size = 01, Q = 0

4S

when size = 01, Q = 1

1D

when size = 10, Q = 0

2D

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2189

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) sum;
integer op1;
integer op2;
if acc then result = V[d];
for e = 0 to elements-1
op1 = Int(Elem[operand, 2*e+0,
op2 = Int(Elem[operand, 2*e+1,
sum = (op1+op2)<2*esize-1:0>;
if acc then
Elem[result, e, 2*esize] =
else
Elem[result, e, 2*esize] =

esize], unsigned);
esize], unsigned);

Elem[result, e, 2*esize] + sum;
sum;

V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2190

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.350

UADDLV
Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&FP register
together, and writes the scalar result to the destination SIMD&FP register. The destination scalar is twice as long as
the source vector elements. All the values in this instruction are unsigned integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 1 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Advanced SIMD variant
UADDLV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
H

when size = 00

S

when size = 01

D

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2191

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer sum;
sum = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
sum = sum + Int(Elem[operand, e, esize], unsigned);
V[d] = sum<2*esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2192

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.351

UADDW, UADDW2
Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&FP register to the
corresponding vector elements in the lower or upper half of the second source SIMD&FP register, places the result
in a vector, and writes the vector to the SIMD&FP destination register. The vector elements of the destination
register and the first source register are twice as long as the vector elements of the second source register. All the
values in this instruction are unsigned integer values.
The UADDW instruction extracts vector elements from the lower half of the second source register, while the UADDW2
instruction extracts vector elements from the upper half of the second source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
UADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2193

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<Tb>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, 2*esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2194

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.352

UCVTF (vector, fixed-point)
Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from
fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the
SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 0 0 1

5 4
Rn

0
Rd

Scalar variant
UCVTF <V><d>, <V><n>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
datasize = esize;
elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 1 1 0 0 1

5 4
Rn

0
Rd

Vector variant
UCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh<3>:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2195

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 000x is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The following encodings are reserved:
•

immh = 0001, Q = x.

•

immh = 1xxx, Q = 0.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<fbits>

For the scalar variant: is the number of fractional bits, in the range 1 to the operand width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 000x is reserved.
For the vector variant: is the number of fractional bits, in the range 1 to the element width, encoded
in the "immh:immb" field. It can have the following values:
(32-Uint(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 0001 is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
for e = 0 to elements-1

C7-2196

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element = Elem[operand, e, esize];
Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2197

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.353

UCVTF (vector, integer)
Unsigned integer Convert to Floating-point (vector). This instruction converts each element in a vector from an
unsigned integer value to a floating-point value using the rounding mode that is specified by the FPCR, and writes
the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

Scalar half precision
ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Scalar half precision variant
UCVTF <Hd>, <Hn>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = esize;
elements = 1;
unsigned = (U == '1');

Scalar single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Scalar single-precision and double-precision variant
UCVTF <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 32
datasize =
elements =
unsigned =

<< UInt(sz);
esize;
1;
(U == '1');

Vector half precision
ARMv8.2

C7-2198

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 1 1 1 1 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Vector half precision variant
UCVTF <Vd>.<T>, <Vn>.<T>

Decode for this encoding
if !HaveFP16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer
integer
integer
boolean

esize = 16;
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Vector single-precision and double-precision
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 0 sz 1 0 0 0 0 1 1 1 0 1 1 0
U

5 4
Rn

0
Rd

Vector single-precision and double-precision variant
UCVTF <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz:Q
integer
integer
integer
boolean

== '10' then UNDEFINED;
esize = 32 << UInt(sz);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hn>

Is the 16-bit name of the SIMD&FP source register, encoded in the "Rn" field.

<V>

Is a width specifier, encoded in the "sz" field. It can have the following values:
S

when sz = 0

D

when sz = 1

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

For the vector half precision variant: is an arrangement specifier, encoded in the "Q" field. It can
have the following values:
4H

ARM DDI 0487F.c
ID072120

when Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2199

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

8H

when Q = 1

For the vector single-precision and double-precision variant: is an arrangement specifier, encoded
in the "sz:Q" field. It can have the following values:
2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

2D

when sz = 1, Q = 1

The encoding sz = 1, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
FPRounding rounding = FPRoundingMode(FPCR);
bits(esize) element;
for e = 0 to elements-1
element = Elem[operand, e, esize];
Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);
V[d] = result;

C7-2200

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.354

UCVTF (scalar, fixed-point)
Unsigned fixed-point Convert to Floating-point (scalar). This instruction converts the unsigned value in the 32-bit
or 64-bit general-purpose source register to a floating-point value using the rounding mode that is specified by the
FPCR, and writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the Security state and
Exception level in which the instruction is executed, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15

sf 0 0 1 1 1 1 0 ftype 0 0 0 0 1 1
rmode opcode

10 9
scale

5 4
Rn

0
Rd

32-bit to half-precision variant
Applies when sf == 0 && ftype == 11.
UCVTF <Hd>, <Wn>, #<fbits>

32-bit to single-precision variant
Applies when sf == 0 && ftype == 00.
UCVTF <Sd>, <Wn>, #<fbits>

32-bit to double-precision variant
Applies when sf == 0 && ftype == 01.
UCVTF <Dd>, <Wn>, #<fbits>

64-bit to half-precision variant
Applies when sf == 1 && ftype == 11.
UCVTF <Hd>, <Xn>, #<fbits>

64-bit to single-precision variant
Applies when sf == 1 && ftype == 00.
UCVTF <Sd>, <Xn>, #<fbits>

64-bit to double-precision variant
Applies when sf == 1 && ftype == 01.
UCVTF <Dd>, <Xn>, #<fbits>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2201

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00' fltsize = 32;
when '01' fltsize = 64;
when '10' UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
if sf == '0' && scale<5> == '0' then UNDEFINED;
integer fracbits = 64 - UInt(scale);
rounding = FPRoundingMode(FPCR);

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

<fbits>

For the 32-bit to double-precision, 32-bit to half-precision and 32-bit to single-precision variant: is
the number of bits after the binary point in the fixed-point source, in the range 1 to 32, encoded as
64 minus "scale".
For the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is
the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as
64 minus "scale".

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
intval = X[n];
fltval = FixedToFP(intval, fracbits, TRUE, FPCR, rounding);
V[d] = fltval;

C7-2202

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.355

UCVTF (scalar, integer)
Unsigned integer Convert to Floating-point (scalar). This instruction converts the unsigned integer value in the
general-purpose source register to a floating-point value using the rounding mode that is specified by the FPCR, and
writes the result to the SIMD&FP destination register.
A floating-point exception can be generated by this instruction. Depending on the settings in FPCR, the exception
results in either a flag being set in FPSR, or a synchronous exception being generated. For more information, see
Floating-point exceptions and exception traps on page D1-2354.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9

sf 0 0 1 1 1 1 0 ftype 1 0 0 0 1 1 0 0 0 0 0 0
rmode opcode

5 4
Rn

0
Rd

32-bit to half-precision variant
Applies when sf == 0 && ftype == 11.
UCVTF <Hd>, <Wn>

32-bit to single-precision variant
Applies when sf == 0 && ftype == 00.
UCVTF <Sd>, <Wn>

32-bit to double-precision variant
Applies when sf == 0 && ftype == 01.
UCVTF <Dd>, <Wn>

64-bit to half-precision variant
Applies when sf == 1 && ftype == 11.
UCVTF <Hd>, <Xn>

64-bit to single-precision variant
Applies when sf == 1 && ftype == 00.
UCVTF <Sd>, <Xn>

64-bit to double-precision variant
Applies when sf == 1 && ftype == 01.
UCVTF <Dd>, <Xn>

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPRounding rounding;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2203

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

case ftype of
when '00'
fltsize = 32;
when '01'
fltsize = 64;
when '10'
UNDEFINED;
when '11'
if HaveFP16Ext() then
fltsize = 16;
else
UNDEFINED;
rounding = FPRoundingMode(FPCR);

Assembler symbols
<Dd>

Is the 64-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Hd>

Is the 16-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Sd>

Is the 32-bit name of the SIMD&FP destination register, encoded in the "Rd" field.

<Xn>

Is the 64-bit name of the general-purpose source register, encoded in the "Rn" field.

<Wn>

Is the 32-bit name of the general-purpose source register, encoded in the "Rn" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(fltsize) fltval;
bits(intsize) intval;
intval = X[n];
fltval = FixedToFP(intval, 0, TRUE, FPCR, rounding);
V[d] = fltval;

C7-2204

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.356

UDOT (by element)
Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit
elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element
in the second source register, accumulating the result into the corresponding 32-bit element of the destination
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

1 1 1 0 H 0

5 4
Rn

0
Rd

Vector variant
UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]

Decode for this encoding
if !HaveDOTPExt() then UNDEFINED;
if size != '10' then UNDEFINED;
boolean signed = (U == '0');
integer
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(M:Rm);
index = UInt(H:L);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<index>

Is the element index, encoded in the "H:L" fields.
Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2205

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) result = V[d];
for e = 0 to elements-1
integer res = 0;
integer element1, element2;
for i = 0 to 3
if signed then
element1 = SInt(Elem[operand1, 4*e+i, esize DIV
element2 = SInt(Elem[operand2, 4*index+i, esize
else
element1 = UInt(Elem[operand1, 4*e+i, esize DIV
element2 = UInt(Elem[operand2, 4*index+i, esize
res = res + element1 * element2;
Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;

C7-2206

4]);
DIV 4]);
4]);
DIV 4]);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.357

UDOT (vector)
Dot Product unsigned arithmetic (vector). This instruction performs the dot product of the four unsigned 8-bit
elements in each 32-bit element of the first source register with the four unsigned 8-bit elements of the
corresponding 32-bit element in the second source register, accumulating the result into the corresponding 32-bit
element of the destination register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
In Armv8.2 and Armv8.3, this is an OPTIONAL instruction. From Armv8.4 it is mandatory for all implementations
to support it.

Note
ID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 0
U

16 15 14 13 12 11 10 9
Rm

1 0 0 1 0 1

5 4
Rn

0
Rd

Vector variant
UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveDOTPExt() then UNDEFINED;
if size != '10' then UNDEFINED;
boolean signed = (U == '0');
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:

<Vm>

ARM DDI 0487F.c
ID072120

2S

8B

when Q = 0

16B

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2207

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
result = V[d];
for e = 0 to elements-1
integer res = 0;
integer element1, element2;
for i = 0 to 3
if signed then
element1 = SInt(Elem[operand1, 4*e+i, esize DIV
element2 = SInt(Elem[operand2, 4*e+i, esize DIV
else
element1 = UInt(Elem[operand1, 4*e+i, esize DIV
element2 = UInt(Elem[operand2, 4*e+i, esize DIV
res = res + element1 * element2;
Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;

C7-2208

4]);
4]);
4]);
4]);

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.358

UHADD
Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source
SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.
The results are truncated. For rounded results, see URHADD.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
UHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2209

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
sum = element1 + element2;
Elem[result, e, esize] = sum<esize:1>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2210

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.359

UHSUB
Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&FP register
from the corresponding vector elements in the first source SIMD&FP register, shifts each result right one bit, places
each result into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
UHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2211

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

element2 = Int(Elem[operand2, e, esize], unsigned);
diff = element1 - element2;
Elem[result, e, esize] = diff<esize:1>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2212

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.360

UMAX
Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source
SIMD&FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to
the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 0 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
UMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2213

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2214

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.361

UMAXP
Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first
source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of
adjacent vector elements in the two source SIMD&FP registers, writes the largest of each pair of unsigned integer
values into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
UMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2215

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer maxmin;
for e = 0 to elements-1
element1 = Int(Elem[concat, 2*e, esize], unsigned);
element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2216

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.362

UMAXV
Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&FP
register, and writes the largest of the values as a scalar to the destination SIMD&FP register. All the values in this
instruction are unsigned integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 1 0 0 0 0 1 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Advanced SIMD variant
UMAXV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean min = (op == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2217

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;
maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
element = Int(Elem[operand, e, esize], unsigned);
maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
V[d] = maxmin<esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2218

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.363

UMIN
Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source
SIMD&FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the
vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 1 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
UMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2219

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2220

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.364

UMINP
Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first
source SIMD&FP register after the vector elements of the second source SIMD&FP register, reads each pair of
adjacent vector elements in the two source SIMD&FP registers, writes the smallest of each pair of unsigned integer
values into a vector, and writes the vector to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 1 1
o1

5 4
Rn

0
Rd

Three registers of the same type variant
UMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<T>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2221

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer maxmin;
for e = 0 to elements-1
element1 = Int(Elem[concat, 2*e, esize], unsigned);
element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
Elem[result, e, esize] = maxmin<esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2222

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.365

UMINV
Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&FP
register, and writes the smallest of the values as a scalar to the destination SIMD&FP register. All the values in this
instruction are unsigned integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 1 0 0 0 1 1 0 1 0 1 0
U
op

5 4
Rn

0
Rd

Advanced SIMD variant
UMINV <V><d>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean min = (op == '1');

Assembler symbols
<V>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

4S

when size = 10, Q = 1

The following encodings are reserved:

ARM DDI 0487F.c
ID072120

•

size = 10, Q = 0.

•

size = 11, Q = x.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2223

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;
maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
element = Int(Elem[operand, e, esize], unsigned);
maxmin = if min then Min(maxmin, element) else Max(maxmin, element);
V[d] = maxmin<esize-1:0>;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2224

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.366

UMLAL, UMLAL2 (by element)
Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or
upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP
register and accumulates the results with the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied.
The UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•
ARM DDI 0487F.c
ID072120

size = 00.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2225

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
else

C7-2226

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2227

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.367

UMLAL, UMLAL2 (vector)
Unsigned Multiply-Add Long (vector). This instruction multiplies the vector elements in the lower or upper half of
the first source SIMD&FP register by the corresponding vector elements of the second source SIMD&FP register,
and accumulates the results with the vector elements of the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.
The UMLAL instruction extracts vector elements from the lower half of the first source register, while the UMLAL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 0 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
sub_op = (o1 == '1');
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

C7-2228

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
accum = Elem[operand3, e, 2*esize] - product;
else
accum = Elem[operand3, e, 2*esize] + product;
Elem[result, e, 2*esize] = accum;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2229

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.368

UMLSL, UMLSL2 (by element)
Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower
or upper half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP
register and subtracts the results from the vector elements of the destination SIMD&FP register. The destination
vector elements are twice as long as the elements that are multiplied.
The UMLSL instruction extracts vector elements from the lower half of the first source register, while the UMLSL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

0 1 1 0 H 0
o2

5 4
Rn

0
Rd

Vector variant
UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean sub_op = (o2 == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:
•
C7-2230

size = 00.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

•

size = 11.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
else

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2231

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2232

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.369

UMLSL, UMLSL2 (vector)
Unsigned Multiply-Subtract Long (vector). This instruction multiplies corresponding vector elements in the lower
or upper half of the two source SIMD&FP registers, and subtracts the results from the vector elements of the
destination SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied.
All the values in this instruction are unsigned integer values.
The UMLSL instruction extracts each source vector from the lower half of each source register, while the UMLSL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer
boolean
boolean

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
sub_op = (o1 == '1');
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2233

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
if sub_op then
accum = Elem[operand3, e, 2*esize] - product;
else
accum = Elem[operand3, e, 2*esize] + product;
Elem[result, e, 2*esize] = accum;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2234

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.370

UMMLA (vector)
Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit
integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source
vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix
accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination
element.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 0 1 1 1 0 1 0 0
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 0 1
B

5 4
Rn

0
Rd

Vector variant
UMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) addend = V[d];
V[d] = MatMulAdd(addend, operand1, operand2, TRUE, TRUE);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2235

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.371

UMOV
Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the
source SIMD&FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination
general-purpose register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias MOV (to general). See Alias conditions for details of when each alias is
preferred.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 0 0 0

16 15 14 13 12 11 10 9
imm5

0 0 1 1 1 1

5 4
Rn

0
Rd

32-bit variant
Applies when Q == 0.
UMOV <Wd>, <Vn>.<Ts>[<index>]

64-reg,UMOV-64-reg variant
Applies when Q == 1 && imm5 == x1000.
UMOV <Xd>, <Vn>.<Ts>[<index>]

Decode for all variants of this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer size;
case Q:imm5 of
when '0xxxx1' size =
when '0xxx10' size =
when '0xx100' size =
when '1x1000' size =
otherwise UNDEFINED;
integer
integer
integer
integer

0;
1;
2;
3;

//
//
//
//

UMOV
UMOV
UMOV
UMOV

Wd,
Wd,
Wd,
Xd,

Vn.B
Vn.H
Vn.S
Vn.D

idxdsize = if imm5<4> == '1' then 128 else 64;
index = UInt(imm5<4:size+1>);
esize = 8 << size;
datasize = if Q == '1' then 64 else 32;

Alias conditions
Alias

is preferred when

MOV (to general)

imm5 == 'x1000'

MOV (to general)

imm5 == 'xx100'

Assembler symbols

C7-2236

<Wd>

Is the 32-bit name of the general-purpose destination register, encoded in the "Rd" field.

<Xd>

Is the 64-bit name of the general-purpose destination register, encoded in the "Rd" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ts>

For the 32-bit variant: is an element size specifier, encoded in the "imm5" field. It can have the
following values:
B

when imm5 = xxxx1

H

when imm5 = xxx10

S

when imm5 = xx100

The encoding imm5 = xx000 is reserved.
For the 64-reg,UMOV-64-reg variant: is an element size specifier, encoded in the "imm5" field. It
can have the following values:
D

when imm5 = x1000

The following encodings are reserved:
•

imm5 = x0000.

•

imm5 = xxxx1.

•

imm5 = xxx10.

•

imm5 = xx100.

For the 32-bit variant: is the element index encoded in the "imm5" field. It can have the following
values:

<index>

imm5<4:1> when imm5 = xxxx1
imm5<4:2> when imm5 = xxx10
imm5<4:3> when imm5 = xx100

The encoding imm5 = xx000 is reserved.
For the 64-reg,UMOV-64-reg variant: is the element index encoded in "imm5<4>".

Operation
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
X[d] = ZeroExtend(Elem[operand, index, esize], datasize);

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2237

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.372

UMULL, UMULL2 (by element)
Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper
half of the first source SIMD&FP register by the specified vector element of the second source SIMD&FP register,
places the results in a vector, and writes the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the elements that are multiplied.
The UMULL instruction extracts vector elements from the lower half of the first source register, while the UMULL2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 1 0 1 1 1 1 size L M
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 H 0

5 4
Rn

0
Rd

Vector variant
UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]

Decode for this encoding
integer idxdsize = if H == '1' then 128 else 64;
integer index;
bit Rmhi;
case size of
when '01' index = UInt(H:L:M); Rmhi = '0';
when '10' index = UInt(H:L); Rmhi = M;
otherwise UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);
integer
integer
integer
integer
boolean

esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;
unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
4S

when size = 01

2D

when size = 10

The following encodings are reserved:

C7-2238

•

size = 00.

•

size = 11.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The following encodings are reserved:
•

size = 00, Q = x.

•

size = 11, Q = x.

Is the name of the second SIMD&FP source register, encoded in the "size:M:Rm" field. It can have
the following values:

<Vm>

0:Rm

when size = 01

M:Rm

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Restricted to V0-V15 when element size <Ts> is H.
Is an element size specifier, encoded in the "size" field. It can have the following values:

<Ts>

H

when size = 01

S

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Is the element index, encoded in the "size:L:H:M" field. It can have the following values:

<index>

H:L:M

when size = 01

H:L

when size = 10

The following encodings are reserved:
•

size = 00.

•

size = 11.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(idxdsize) operand2 = V[m];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
product = (element1*element2)<2*esize-1:0>;
Elem[result, e, 2*esize] = product;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2239

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-2240

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.373

UMULL, UMULL2 (vector)
Unsigned Multiply long (vector). This instruction multiplies corresponding vector elements in the lower or upper
half of the two source SIMD&FP registers, places the result in a vector, and writes the vector to the destination
SIMD&FP register. The destination vector elements are twice as long as the elements that are multiplied. All the
values in this instruction are unsigned integer values.
The UMULL instruction extracts each source vector from the lower half of each source register, while the UMULL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

1 1 0 0 0 0

5 4
Rn

0
Rd

Three registers, not all the same type variant
UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2241

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
Elem[result, e, 2*esize] = (element1*element2)<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2242

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.374

UQADD
Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&FP
registers, places the results into a vector, and writes the vector to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Scalar variant
UQADD <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 0 1 1

5 4
Rn

0
Rd

Vector variant
UQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

ARM DDI 0487F.c
ID072120

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2243

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;
boolean sat;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
sum = element1 + element2;
(Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2244

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.375

UQRSHL
Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source
SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding vector
element of the second source SIMD&FP register, places the results into a vector, and writes the vector to the
destination SIMD&FP register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are rounded. For
truncated results, see UQSHL (immediate).
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 1
R S

5 4
Rn

0
Rd

Scalar variant
UQRSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 1
R S

5 4
Rn

0
Rd

Vector variant
UQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2245

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2246

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.376

UQRSHRN, UQRSHRN2
Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the
source SIMD&FP register, right shifts each result by an immediate value, puts the final result into a vector, and
writes the vector to the lower or upper half of the destination SIMD&FP register. All the values in this instruction
are unsigned integer values. The results are rounded. For truncated results, see UQSHRN, UQSHRN2.
The UQRSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the UQRSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 1 1
op

5 4
Rn

0
Rd

Scalar variant
UQRSHRN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 1 1
op

5 4
Rn

0
Rd

Vector variant
UQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2247

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:

C7-2248

•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2249

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.377

UQSHL (immediate)
Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&FP
register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination
SIMD&FP register. The results are truncated. For rounded results, see UQRSHL.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 1 0 1
op

5 4
Rn

0
Rd

Scalar variant
UQSHL <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh
integer
integer
integer

== '0000' then UNDEFINED;
esize = 8 << HighestSetBit(immh);
datasize = esize;
elements = 1;

integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 1 1 1 0 1
op

5 4
Rn

0
Rd

Vector variant
UQSHL <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;

C7-2250

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;
boolean src_unsigned;
boolean dst_unsigned;
case op:U of
when '00' UNDEFINED;
when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
when '11' src_unsigned = TRUE; dst_unsigned = TRUE;

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

D

when immh = 1xxx

The encoding immh = 0000 is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the left shift amount, in the range 0 to the operand width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

The encoding immh = 0000 is reserved.
For the vector variant: is the left shift amount, in the range 0 to the element width in bits minus 1,
encoded in the "immh:immb" field. It can have the following values:
(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx
(UInt(immh:immb)-64) when immh = 1xxx

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2251

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], src_unsigned) << shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

C7-2252

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.378

UQSHL (register)
Unsigned saturating Shift Left (register). This instruction takes each element in the vector of the first source
SIMD&FP register, shifts the element by a value from the least significant byte of the corresponding element of the
second source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP
register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a right shift. The results are truncated. For
rounded results, see UQRSHL.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 1 1
R S

5 4
Rn

0
Rd

Scalar variant
UQSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 1 1
R S

5 4
Rn

0
Rd

Vector variant
UQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2253

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2254

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.379

UQSHRN, UQSHRN2
Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source
SIMD&FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half
the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination
SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For
rounded results, see UQRSHRN, UQRSHRN2.
The UQSHRN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the UQSHRN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 0 1
op

5 4
Rn

0
Rd

Scalar variant
UQSHRN <Vb><d>, <Va><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then UNDEFINED;
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;
integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 0 1 0 1
op

5 4
Rn

0
Rd

Vector variant
UQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2255

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

integer
integer
integer
integer

esize = 8 << HighestSetBit(immh);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vb>

Is the destination width specifier, encoded in the "immh" field. It can have the following values:
B

when immh = 0001

H

when immh = 001x

S

when immh = 01xx

The following encodings are reserved:

C7-2256

•

immh = 0000.

•

immh = 1xxx.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "immh" field. It can have the following values:
H

when immh = 0001

S

when immh = 001x

D

when immh = 01xx

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to the destination operand width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

The following encodings are reserved:
•

immh = 0000.

•

immh = 1xxx.

For the vector variant: is the right shift amount, in the range 1 to the destination element width in
bits, encoded in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;
for e = 0 to elements-1
element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
Vpart[d, part] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2257

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.380

UQSUB
Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&FP register
from the corresponding element values of the first source SIMD&FP register, places the results into a vector, and
writes the vector to the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1

5 4
Rn

0
Rd

Scalar variant
UQSUB <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 1 1

5 4
Rn

0
Rd

Vector variant
UQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

C7-2258

Is a width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
boolean sat;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
diff = element1 - element2;
(Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2259

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.381

UQXTN, UQXTN2
Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&FP register,
saturates each value to half the original width, places the result into a vector, and writes the vector to the destination
SIMD&FP register. All the values in this instruction are unsigned integer values.
If saturation occurs, the cumulative saturation bit FPSR.QC is set.
The UQXTN instruction writes the vector to the lower half of the destination register and clears the upper half, while
the UQXTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits
of the register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Scalar variant
UQXTN <Vb><d>, <Va><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = esize;
part = 0;
elements = 1;

boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 1 0 1 0 0 1 0
U

5 4
Rn

0
Rd

Vector variant
UQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean unsigned = (U == '1');

C7-2260

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.
<Vb>

Is the destination width specifier, encoded in the "size" field. It can have the following values:
B

when size = 00

H

when size = 01

S

when size = 10

The encoding size = 11 is reserved.
<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<Va>

Is the source width specifier, encoded in the "size" field. It can have the following values:
H

when size = 00

S

when size = 01

D

when size = 10

The encoding size = 11 is reserved.
<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;
for e = 0 to elements-1
element = Elem[operand, e, 2*esize];
(Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2261

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

if sat then FPSR.QC = '1';
Vpart[d, part] = result;

C7-2262

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.382

URECPE
Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&FP register,
calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector
to the destination SIMD&FP register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 0 1 0

5 4
Rn

0
Rd

Vector variant
URECPE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

<T>

2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

The encoding sz = 1, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;
for e = 0 to elements-1
element = Elem[operand, e, 32];
Elem[result, e, 32] = UnsignedRecipEstimate(element);
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2263

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.383

URHADD
Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source
SIMD&FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the
destination SIMD&FP register.
The results are rounded. For truncated results, see UHADD.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 0 1 0 1

5 4
Rn

0
Rd

Three registers of the same type variant
URHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer
integer
integer
if size
integer
integer
integer

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = if Q == '1' then 128 else 64;
elements = datasize DIV esize;

boolean unsigned = (U == '1');

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;

C7-2264

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
Elem[result, e, esize] = (element1+element2+1)<esize:1>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2265

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.384

URSHL
Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source
SIMD&FP register, shifts the vector element by a value from the least significant byte of the corresponding element
of the second source SIMD&FP register, places the results in a vector, and writes the vector to the destination
SIMD&FP register.
If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a rounding right shift.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 1
R S

5 4
Rn

0
Rd

Scalar variant
URSHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 1 0 1
R S

5 4
Rn

0
Rd

Vector variant
URSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

C7-2266

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
when size = 11

D

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2267

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.385

URSHR
Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP
register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the
destination SIMD&FP register. All the values in this instruction are unsigned integer values. The results are
rounded. For truncated results, see USHR.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 0 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
URSHR <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 0 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
URSHR <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

C7-2268

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2269

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.386

URSQRTE
Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&FP
register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the
vector to the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 1 sz 1 0 0 0 0 1 1 1 0 0 1 0

5 4
Rn

0
Rd

Vector variant
URSQRTE <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

Assembler symbols
Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vd>

Is an arrangement specifier, encoded in the "sz:Q" field. It can have the following values:

<T>

2S

when sz = 0, Q = 0

4S

when sz = 0, Q = 1

The encoding sz = 1, Q = x is reserved.
Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Vn>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;
for e = 0 to elements-1
element = Elem[operand, e, 32];
Elem[result, e, 32] = UnsignedRSqrtEstimate(element);
V[d] = result;

C7-2270

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.387

URSRA
Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the
source SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the
vector elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values.
The results are rounded. For truncated results, see USRA.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 1 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
URSRA <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 1 1 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
URSRA <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

ARM DDI 0487F.c
ID072120

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2271

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

C7-2272

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.388

USDOT (vector)
Dot Product vector form with unsigned and signed integers. This instruction performs the dot product of the four
unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer
values in the corresponding 32-bit element of the second source register, accumulating the result into the
corresponding 32-bit element of the destination register.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 1 0 0

16 15 14 13 12 11 10 9
Rm

1 0 0 1 1 1

5 4
Rn

0
Rd

Vector variant
USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
for e = 0 to elements-1
bits(32) res = Elem[operand3, e, 32];
for b = 0 to 3
integer element1 = UInt(Elem[operand1, 4*e+b, 8]);
integer element2 = SInt(Elem[operand2, 4*e+b, 8]);
res = res + element1 * element2;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2273

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Elem[result, e, 32] = res;
V[d] = result;

C7-2274

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.389

USDOT (by element)
Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four
unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer
values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding
32-bit element of the destination register.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20 19
0 Q 0 0 1 1 1 1 1 0 L M
US

16 15 14 13 12 11 10 9
Rm

1 1 1 1 H 0

5 4
Rn

0
Rd

Vector variant
USDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
boolean op1_unsigned = (US == '1');
boolean op2_unsigned = (US == '0');
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer d = UInt(Rd);
integer i = UInt(H:L);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
2S

when Q = 0

4S

when Q = 1

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "Q" field. It can have the following values:
8B

when Q = 0

16B

when Q = 1

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "M:Rm" fields.

<index>

Is the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the
"H:L" fields.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2275

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

for e = 0 to elements-1
bits(32) res = Elem[operand3, e, 32];
for b = 0 to 3
integer element1 = Int(Elem[operand1, 4*e+b, 8], op1_unsigned);
integer element2 = Int(Elem[operand2, 4*i+b, 8], op2_unsigned);
res = res + element1 * element2;
Elem[result, e, 32] = res;
V[d] = result;

C7-2276

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.390

USHL
Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&FP
register, shifts each element by a value from the least significant byte of the corresponding element of the second
source SIMD&FP register, places the results in a vector, and writes the vector to the destination SIMD&FP register.
If the shift value is positive, the operation is a left shift. If the shift value is negative, it is a truncating right shift. For
a rounding shift, see URSHL.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20
0 1 1 1 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 1
R S

5 4
Rn

0
Rd

Scalar variant
USHL <V><d>, <V><n>, <V><m>

Decode for this encoding
integer
integer
integer
integer
integer
integer
boolean
boolean
boolean
if S ==

d = UInt(Rd);
n = UInt(Rn);
m = UInt(Rm);
esize = 8 << UInt(size);
datasize = esize;
elements = 1;
unsigned = (U == '1');
rounding = (R == '1');
saturating = (S == '1');
'0' && size != '11' then UNDEFINED;

Vector
31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 1 0 0 0 1
R S

5 4
Rn

0
Rd

Vector variant
USHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2277

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
when size = 11

D

The following encodings are reserved:
•

size = 0x.

•

size = 10.

<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<m>

Is the number of the second SIMD&FP source register, encoded in the "Rm" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer
integer
integer
boolean

round_const = 0;
shift;
element;
sat;

for e = 0 to elements-1
shift = SInt(Elem[operand2, e, esize]<7:0>);
if rounding then
round_const = 1 << (-shift - 1);
// 0 for left shift, 2^(n-1) for right shift
element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
if saturating then
(Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
if sat then FPSR.QC = '1';
else
Elem[result, e, esize] = element<esize-1:0>;
V[d] = result;

C7-2278

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2279

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.391

USHLL, USHLL2
Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the
source SIMD&FP register, shifts the unsigned integer value left by the specified number of bits, places the result
into a vector, and writes the vector to the destination SIMD&FP register. The destination vector elements are twice
as long as the source vector elements.
The USHLL instruction extracts vector elements from the lower half of the source register, while the USHLL2 instruction
extracts vector elements from the upper half of the source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is used by the alias UXTL, UXTL2. See Alias conditions for details of when each alias is preferred.

31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

1 0 1 0 0 1

5 4
Rn

0
Rd

Vector variant
USHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3> == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
integer shift = UInt(immh:immb) - esize;
boolean unsigned = (U == '1');

Alias conditions
Alias

is preferred when

UXTL, UXTL2

immb == '000' && BitCount(immh) == 1

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1

C7-2280

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.
Is the left shift amount, in the range 0 to the source element width in bits minus 1, encoded in the
"immh:immb" field. It can have the following values:

<shift>

(UInt(immh:immb)-8)

when immh = 0001

(UInt(immh:immb)-16) when immh = 001x
(UInt(immh:immb)-32) when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(datasize*2) result;
integer element;
for e = 0 to elements-1
element = Int(Elem[operand, e, esize], unsigned) << shift;
Elem[result, e, 2*esize] = element<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2281

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.392

USHR
Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&FP register, right
shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination
SIMD&FP register. All the values in this instruction are unsigned integer values. The results are truncated. For
rounded results, see URSHR.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 0 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
USHR <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 0 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
USHR <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

C7-2282

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2283

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-2284

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.393

USMMLA (vector)
Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of
unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second
source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix
accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination
element.
From Armv8.2 to Armv8.5, this is an OPTIONAL instruction. From Armv8.6 it is mandatory for implementations that
include Advanced SIMD to support it. ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.

ARMv8.6
31 30 29 28 27 26 25 24 23 22 21 20
0 1 0 0 1 1 1 0 1 0 0
U

16 15 14 13 12 11 10 9
Rm

1 0 1 0 1 1
B

5 4
Rn

0
Rd

Vector variant
USMMLA <Vd>.4S, <Vn>.16B, <Vm>.16B

Decode for this encoding
if !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

Assembler symbols
<Vd>

Is the name of the SIMD&FP third source and destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) addend = V[d];
V[d] = MatMulAdd(addend, operand1, operand2, TRUE, FALSE);

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2285

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.394

USQADD
Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector
elements in the source SIMD&FP register to corresponding unsigned integer values of the vector elements in the
destination SIMD&FP register, and accumulates the resulting unsigned integer values with the vector elements of
the destination SIMD&FP register.
If overflow occurs with any of the results, those results are saturated. If saturation occurs, the cumulative saturation
bit FPSR.QC is set.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 1 1 1 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Scalar variant
USQADD <V><d>, <V><n>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

Vector
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 1 0 1 1 1 0 size 1 0 0 0 0 0 0 0 1 1 1 0
U

5 4
Rn

0
Rd

Vector variant
USQADD <Vd>.<T>, <Vn>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

Assembler symbols
<V>

Is a width specifier, encoded in the "size" field. It can have the following values:
B

C7-2286

when size = 00

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

H

when size = 01

S

when size = 10

D

when size = 11

<d>

Is the number of the SIMD&FP destination register, encoded in the "Rd" field.

<n>

Is the number of the SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(datasize) operand2 = V[d];
integer op1;
integer op2;
boolean sat;
for e = 0 to elements-1
op1 = Int(Elem[operand, e, esize], !unsigned);
op2 = Int(Elem[operand2, e, esize], unsigned);
(Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
if sat then FPSR.QC = '1';
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2287

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.395

USRA
Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source
SIMD&FP register, right shifts each result by an immediate value, and accumulates the final results with the vector
elements of the destination SIMD&FP register. All the values in this instruction are unsigned integer values. The
results are truncated. For rounded results, see URSRA.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

Scalar
31 30 29 28 27 26 25 24 23 22
0 1 1 1 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 1 0 1
o1 o0

5 4
Rn

0
Rd

Scalar variant
USRA <V><d>, <V><n>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh<3> != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;
integer
boolean
boolean
boolean

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Vector
31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

immb

0 0 0 1 0 1
o1 o0

5 4
Rn

0
Rd

Vector variant
USRA <Vd>.<T>, <Vn>.<T>, #<shift>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if immh == '0000' then SEE "Advanced SIMD modified immediate";
if immh<3>:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer
boolean
boolean
boolean

C7-2288

shift = (esize * 2) - UInt(immh:immb);
unsigned = (U == '1');
round = (o1 == '1');
accumulate = (o0 == '1');

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Assembler symbols
<V>

Is a width specifier, encoded in the "immh" field. It can have the following values:
D

when immh = 1xxx

The encoding immh = 0xxx is reserved.
<d>

Is the number of the SIMD&FP destination register, in the "Rd" field.

<n>

Is the number of the first SIMD&FP source register, encoded in the "Rn" field.

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

2D

when immh = 1xxx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = 0 is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<shift>

For the scalar variant: is the right shift amount, in the range 1 to 64, encoded in the "immh:immb"
field. It can have the following values:
(128-UInt(immh:immb)) when immh = 1xxx

The encoding immh = 0xxx is reserved.
For the vector variant: is the right shift amount, in the range 1 to the element width in bits, encoded
in the "immh:immb" field. It can have the following values:
(16-UInt(immh:immb)) when immh = 0001
(32-UInt(immh:immb)) when immh = 001x
(64-UInt(immh:immb)) when immh = 01xx
(128-UInt(immh:immb)) when immh = 1xxx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.

Operation for all encodings
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;
V[d] = result;

ARM DDI 0487F.c
ID072120

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2289

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Operational information
If PSTATE.DIT is 1:
•

•

C7-2290

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.396

USUBL, USUBL2
Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second
source SIMD&FP register from the corresponding vector element of the first source SIMD&FP register, places the
result into a vector, and writes the vector to the destination SIMD&FP register. All the values in this instruction are
unsigned integer values. The destination vector elements are twice as long as the source vector elements.
The USUBL instruction extracts each source vector from the lower half of each source register, while the USUBL2
instruction extracts each source vector from the upper half of each source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 0 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
USUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2291

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<Vm>

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = Vpart[n, part];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2292

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.397

USUBW, USUBW2
Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&FP register
from the corresponding vector element in the lower or upper half of the first source SIMD&FP register, places the
result in a vector, and writes the vector to the SIMD&FP destination register. All the values in this instruction are
signed integer values.
The vector elements of the destination register and the first source register are twice as long as the vector elements
of the second source register.
The USUBW instruction extracts vector elements from the lower half of the first source register, while the USUBW2
instruction extracts vector elements from the upper half of the first source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 1 0 1 1 1 0 size 1
U

16 15 14 13 12 11 10 9
Rm

0 0 1 1 0 0
o1

5 4
Rn

0
Rd

Three registers, not all the same type variant
USUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

when size = 00

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2293

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:

<Tb>

8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize) operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;
for e = 0 to elements-1
element1 = Int(Elem[operand1, e, 2*esize], unsigned);
element2 = Int(Elem[operand2, e, esize], unsigned);
if sub_op then
sum = element1 - element2;
else
sum = element1 + element2;
Elem[result, e, 2*esize] = sum<2*esize-1:0>;
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2294

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.398

UXTL, UXTL2
Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source
SIMD&FP register into a vector, and writes the vector to the destination SIMD&FP register. The destination vector
elements are twice as long as the source vector elements.
The UXTL instruction extracts vector elements from the lower half of the source register, while the UXTL2 instruction
extracts vector elements from the upper half of the source register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.
This instruction is an alias of the USHLL, USHLL2 instruction. This means that:
•

The encodings in this description are named to match the encodings of USHLL, USHLL2.

•

The description of USHLL, USHLL2 gives the operational pseudocode for this instruction.

31 30 29 28 27 26 25 24 23 22
0 Q 1 0 1 1 1 1 0
U

19 18
!=0000
immh

16 15 14 13 12 11 10 9

0 0 0 1 0 1 0 0 1
immb

5 4
Rn

0
Rd

Vector variant
UXTL{2} <Vd>.<Ta>, <Vn>.<Tb>

is equivalent to
USHLL{2}

<Vd>.<Ta>, <Vn>.<Tb>, #0

and is the preferred disassembly when BitCount(immh) == 1.

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Ta>

Is an arrangement specifier, encoded in the "immh" field. It can have the following values:
8H

when immh = 0001

4S

when immh = 001x

2D

when immh = 01xx

See Advanced SIMD modified immediate on page C4-351 when immh = 0000.
The encoding immh = 1xxx is reserved.

ARM DDI 0487F.c
ID072120

<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Tb>

Is an arrangement specifier, encoded in the "immh:Q" field. It can have the following values:
8B

when immh = 0001, Q = 0

16B

when immh = 0001, Q = 1

4H

when immh = 001x, Q = 0

8H

when immh = 001x, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2295

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2S

when immh = 01xx, Q = 0

4S

when immh = 01xx, Q = 1

See Advanced SIMD modified immediate on page C4-351 when immh = 0000, Q = x.
The encoding immh = 1xxx, Q = x is reserved.

Operation
The description of USHLL, USHLL2 gives the operational pseudocode for this instruction.

Operational information
If PSTATE.DIT is 1:
•

•

C7-2296

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.399

UZP1
Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source
SIMD&FP registers, starting at zero, places the result from the first source register into consecutive elements in the
lower half of a vector, and the result from the second source register into consecutive elements in the upper half of
a vector, and writes the vector to the destination SIMD&FP register.

Note
This instruction can be used with UZP2 to de-interleave two vectors.
The following figure shows the operation of UZP1 and UZP2 with the arrangement specifier 8B.
Vn
Vm

A7
B7

A6
B6

A5
B5

A4
B4

A3
B3

A2
B2

UZP1.8, doubleword
Vd

B6

B4

B2

B0

A6

A4

A1
B1

A0
B0

UZP2.8, doubleword
A2

A0

Vd

B7

B5

B3

B1

A7

A5

A3

A1

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 0 0 1 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
UZP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2297

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operandl = V[n];
bits(datasize) operandh = V[m];
bits(datasize) result;
bits(datasize*2) zipped = operandh:operandl;
for e = 0 to elements-1
Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2298

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.400

UZP2
Unzip vectors (secondary). This instruction reads corresponding odd-numbered vector elements from the two
source SIMD&FP registers, places the result from the first source register into consecutive elements in the lower
half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector,
and writes the vector to the destination SIMD&FP register.

Note
This instruction can be used with UZP1 to de-interleave two vectors.
The following figure shows the operation of UZP1 and UZP2 with the arrangement specifier 8B.
Vn
Vm

A7
B7

A6
B6

A5
B5

A4
B4

A3
B3

A2
B2

UZP1.8, doubleword
Vd

B6

B4

B2

B0

A6

A4

A1
B1

A0
B0

UZP2.8, doubleword
A2

A0

Vd

B7

B5

B3

B1

A7

A5

A3

A1

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 1 0 1 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
UZP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);

Assembler symbols

ARM DDI 0487F.c
ID072120

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2299

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operandl = V[n];
bits(datasize) operandh = V[m];
bits(datasize) result;
bits(datasize*2) zipped = operandh:operandl;
for e = 0 to elements-1
Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

C7-2300

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.401

XAR
Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors in the two source SIMD&FP
registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate
value, and writes the result to the destination SIMD&FP register.
This instruction is implemented only when FEAT_SHA3 is implemented.

ARMv8.2
31 30 29 28 27 26 25 24 23 22 21 20
1 1 0 0 1 1 1 0 1 0 0

16 15
Rm

10 9
imm6

5 4
Rn

0
Rd

Advanced SIMD variant
XAR <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>

Decode for this encoding
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

Assembler symbols
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

<imm6>

Is a rotation right, encoded in "imm6".

Operation
AArch64.CheckFPAdvSIMDEnabled();
bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) tmp;
tmp = Vn EOR Vm;
V[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2301

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.402

XTN, XTN2
Extract Narrow. This instruction reads each vector element from the source SIMD&FP register, narrows each value
to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the
destination SIMD&FP register. The destination vector elements are half as long as the source vector elements.
The XTN instruction writes the vector to the lower half of the destination register and clears the upper half, while the
XTN2 instruction writes the vector to the upper half of the destination register without affecting the other bits of the
register.
Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
0 Q 0 0 1 1 1 0 size 1 0 0 0 0 1 0 0 1 0 1 0

5 4
Rn

0
Rd

Vector variant
XTN{2} <Vd>.<Tb>, <Vn>.<Ta>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
if size
integer
integer
integer
integer

== '11' then UNDEFINED;
esize = 8 << UInt(size);
datasize = 64;
part = UInt(Q);
elements = datasize DIV esize;

Assembler symbols
2

Is the second and upper half specifier. If present it causes the operation to be performed on the upper
64 bits of the registers holding the narrower elements, and is encoded in the "Q" field. It can have
the following values:
[absent]

when Q = 0

[present] when Q = 1
<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<Tb>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

4S

when size = 10, Q = 1

The encoding size = 11, Q = x is reserved.
<Vn>

Is the name of the SIMD&FP source register, encoded in the "Rn" field.

<Ta>

Is an arrangement specifier, encoded in the "size" field. It can have the following values:
8H

C7-2302

when size = 00

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4S

when size = 01

2D

when size = 10

The encoding size = 11 is reserved.

Operation
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
for e = 0 to elements-1
element = Elem[operand, e, 2*esize];
Elem[result, e, esize] = element<esize-1:0>;
Vpart[d, part] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2303

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.403

ZIP1
Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&FP
registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination
SIMD&FP register. The first pair from the first source register is placed into the two lowest vector elements, with
subsequent pairs taken alternately from each source register.

Note
This instruction can be used with ZIP2 to interleave two vectors.
The following figure shows the operation of ZIP1 and ZIP2 with the arrangement specifier 8B.
Vn
Vm

A7
B7

A6
B6

A5
B5

A4
B4

A3
B3

A2
B2

ZIP1.8, doubleword
Vd

B3

A3

B2

A2

B1

A1
B1

A0
B0

ZIP2.8, doubleword
A1

B0

Vd

A0

B7

A7

B6

A6

B5

A5

B4

A4

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 0 1 1 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
ZIP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

Assembler symbols

C7-2304

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer base = part * pairs;
for p = 0 to pairs-1
Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2305

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

C7.2.404

ZIP2
Zip vectors (secondary). This instruction reads adjacent vector elements from the upper half of two source
SIMD&FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the
destination SIMD&FP register. The first pair from the first source register is placed into the two lowest vector
elements, with subsequent pairs taken alternately from each source register.

Note
This instruction can be used with ZIP1 to interleave two vectors.
The following figure shows the operation of ZIP1 and ZIP2 with the arrangement specifier 8B.
Vn
Vm

A7
B7

A6
B6

A5
B5

A4
B4

A3
B3

A2
B2

ZIP1.8, doubleword
Vd

B3

A3

B2

A2

B1

A1
B1

A0
B0

ZIP2.8, doubleword
A1

B0

Vd

A0

B7

A7

B6

A6

B5

A5

B4

A4

Depending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, and the current Security state
and Exception level, an attempt to execute the instruction might be trapped.

31 30 29 28 27 26 25 24 23 22 21 20
0 Q 0 0 1 1 1 0 size 0

16 15 14 13 12 11 10 9
Rm

0 1 1 1 1 0
op

5 4
Rn

0
Rd

Advanced SIMD variant
ZIP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>

Decode for this encoding
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

Assembler symbols

C7-2306

<Vd>

Is the name of the SIMD&FP destination register, encoded in the "Rd" field.

<T>

Is an arrangement specifier, encoded in the "size:Q" field. It can have the following values:
8B

when size = 00, Q = 0

16B

when size = 00, Q = 1

4H

when size = 01, Q = 0

8H

when size = 01, Q = 1

2S

when size = 10, Q = 0

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

ARM DDI 0487F.c
ID072120

A64 Advanced SIMD and Floating-point Instruction Descriptions
C7.2 Alphabetical list of A64 Advanced SIMD and floating-point instructions

4S

when size = 10, Q = 1

2D

when size = 11, Q = 1

The encoding size = 11, Q = 0 is reserved.
<Vn>

Is the name of the first SIMD&FP source register, encoded in the "Rn" field.

<Vm>

Is the name of the second SIMD&FP source register, encoded in the "Rm" field.

Operation
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer base = part * pairs;
for p = 0 to pairs-1
Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];
V[d] = result;

Operational information
If PSTATE.DIT is 1:
•

•

ARM DDI 0487F.c
ID072120

The execution time of this instruction is independent of:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

The response of this instruction to asynchronous exceptions does not vary based on:
—

The values of the data supplied in any of its registers.

—

The values of the NZCV flags.

Copyright © 2013-2020 Arm Limited or its affiliates. All rights reserved.
Non-Confidential

C7-2307

